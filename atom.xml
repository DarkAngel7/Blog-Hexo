<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dark Angel</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.darkangel7.com/"/>
  <updated>2017-05-05T09:24:15.000Z</updated>
  <id>http://blog.darkangel7.com/</id>
  
  <author>
    <name>Dark Angel</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS中NSUserDefaults的黑科技</title>
    <link href="http://blog.darkangel7.com/2017/05/05/iOS%E4%B8%ADNSUserDefaults%E7%9A%84%E9%BB%91%E7%A7%91%E6%8A%80/"/>
    <id>http://blog.darkangel7.com/2017/05/05/iOS中NSUserDefaults的黑科技/</id>
    <published>2017-05-05T04:18:12.000Z</published>
    <updated>2017-05-05T09:24:15.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在iOS开发中，我们时常需要保存一些数据，或者希望在用户下次打开App时，依然可以保留一些设置等，比如<strong>主题设置</strong>、<strong>语言设置</strong>，那么我们一般会选择使用<code>NSUserDefaults</code>作为轻量级数据持久化方案。这里不对其他的数据持久化方案（如Plist、归档、Sqlite3、CoreData等）进行探讨，主要来介绍一下<code>NSUserDefaults</code>中的一些黑科技。</p>
<h1 id="NSUserDefaults简介"><a href="#NSUserDefaults简介" class="headerlink" title="NSUserDefaults简介"></a>NSUserDefaults简介</h1><p><code>NSUserDefaults</code>在Foundation框架中被定义，用来存储和读取一些轻量级数据。其本质是操作plist文件。</p>
<p>它比其他数据持久化方案的优点在于：</p>
<ul>
<li>轻量级。</li>
<li>方便快捷直接使用。</li>
<li>支持<code>NSData</code>, <code>NSString</code>, <code>NSNumber</code>, <code>NSDate</code>, <code>NSArray</code> and  <code>NSDictionary</code>。</li>
</ul>
<p>缺点在于：</p>
<ul>
<li>不适合大量数据。</li>
<li>无法存储自定义<code>model</code>。</li>
</ul>
<h1 id="黑科技"><a href="#黑科技" class="headerlink" title="黑科技"></a>黑科技</h1><p>一些<code>NSUserDefaults</code>最基础的用法，这里就不赘述了。说到黑科技，一般指的是鲜为人知而又十分厉害的技术。这里主要介绍两个黑科技。</p>
<h2 id="还原默认值"><a href="#还原默认值" class="headerlink" title="还原默认值"></a>还原默认值</h2><p>一般<code>NSUserDefaults</code>使用，都会保存一些自定义的Key和Value，其实这个不涉及还原默认值的问题。其实有些时候，是需要修改其中的系统默认值的。比如应用内切换中英文，就需要修改<code>AppleLanguages</code>的value。既然修改了系统默认值，怎么还原默认值呢？</p>
<p>我们先来看一下修改前的：</p>
<pre><code>po [NSUserDefaults standardUserDefaults].dictionaryRepresentation

{
    ...
    AppleLanguages =     (
        en,
        &quot;zh-Hans-US&quot;
    );
    AppleLocale = &quot;en_US&quot;;
    ...
}
</code></pre><p>可以看到<code>AppleLanguages</code>对应的是一个数组，如果我们在App内想切换成中文，执行</p>
<pre><code class="objective-c">[[NSUserDefaults standardUserDefaults] setObject:@[@&quot;zh-Hans&quot;] forKey:@&quot;AppleLanguages&quot;];
</code></pre>
<p>再次看下修改后</p>
<pre><code>po [NSUserDefaults standardUserDefaults].dictionaryRepresentation

{
    ...
    AppleLanguages =     (
        zh-Hans
    );
    AppleLocale = &quot;en_US&quot;;
    ...
}
</code></pre><p>好吧，这个<code>AppleLanguages</code>字段的值已经被记录了。这时候，kill客户端，重新打开客户端，发现，这个值肯定不会变。那么如果这个时候用户在系统设置中切换到了日语，那么我想在客户端中通过<strong>跟随手机系统</strong>的设置，还原到日语，该怎么办呢？</p>
<p>或许你会想到记录初始值，只要提前记录，在还原时再set回去就可以了。嗯~没毛病，可是在什么地方什么时候记录初始值呢？这个<code>AppleLanguages</code>字段其实就是系统的语言默认值，你已经把它改过了，如果在你改过之后用户又修改了系统语言，那你是拿不到新默认值的，所以这条路是走不通的。</p>
<p>那怎么实现还原默认值呢？看下这个方法：</p>
<pre><code>/*!
 -setObject:forKey: immediately stores a value (or removes the value if nil is passed as the value) for the provided key in the search list entry for the receiver&#39;s suite name in the current user and any host, then asynchronously stores the value persistently, where it is made available to other processes.
 */
- (void)setObject:(nullable id)value forKey:(NSString *)defaultName;
</code></pre><p>这个方法Document中并没有描述过多，基本都是在强调<code>value</code>必须是<code>NSData</code>, <code>NSString</code>, <code>NSNumber</code>, <code>NSDate</code>, <code>NSArray</code> and  <code>NSDictionary</code>中的一种，且<code>NSArray</code> and  <code>NSDictionary</code>中的值也必须是Plist支持的类型。在注释中有强调，<code>removes the value if nil is passed as the value</code>，传nil等同于删除这个键值对。</p>
<pre><code>/// -removeObjectForKey: is equivalent to -[... setObject:nil forKey:defaultName]
- (void)removeObjectForKey:(NSString *)defaultName;
</code></pre><p>其实这里才是关键</p>
<pre><code>[[NSUserDefaults standardUserDefaults] setObject:nil forKey:@&quot;AppleLanguages&quot;];
//or
[[NSUserDefaults standardUserDefaults] removeObjectForKey:@&quot;AppleLanguages&quot;];
</code></pre><p>然后再次</p>
<pre><code>po [NSUserDefaults standardUserDefaults].dictionaryRepresentation

{
    ...
    AppleLanguages =     (
        en,
        &quot;zh-Hans-US&quot;
    );
    AppleLocale = &quot;en_US&quot;;
    ...
}
</code></pre><p>你会发现，WTF，居然这个字段还存在，且还原成了默认值，厉害了word哥。本方法是本人历经各种坑之后发现的，且官方文档中没有任何提及，只能说Apple爸爸任性。</p>
<h2 id="巧用SuiteName"><a href="#巧用SuiteName" class="headerlink" title="巧用SuiteName"></a>巧用SuiteName</h2><pre><code>- (nullable instancetype)initWithSuiteName:(nullable NSString *)suitename NS_AVAILABLE(10_9, 7_0) NS_DESIGNATED_INITIALIZER;
</code></pre><p>这个方法，想必各位不会陌生，在跨App间通信或者主App与Extension共享数据，都会用到，一般配合使用的是<strong>App Groups</strong>。</p>
<h3 id="App-Groups数据共享"><a href="#App-Groups数据共享" class="headerlink" title="App Groups数据共享"></a>App Groups数据共享</h3><p>在App Groups中使用，一般两个App都需要加入同一个Group。<img src="http://ww1.sinaimg.cn/large/006tNbRwly1ffajfof2qdj30x00cqjsl.jpg" alt="">然后在两个App分别使用</p>
<pre><code class="objective-c">- (NSUserDefaults *)userDefaults
{
    return [[NSUserDefaults alloc] initWithSuiteName:@&quot;group.urwork.autosignin&quot;];    //name需要是Group的id
}
</code></pre>
<p>来存储和读取数据，即可实现数据共享。</p>
<h3 id="超微型简单方便易用数据库"><a href="#超微型简单方便易用数据库" class="headerlink" title="超微型简单方便易用数据库"></a>超微型简单方便易用数据库</h3><p>这里，其实主要介绍一下<code>initWithSuiteName:</code>的另一个用途，我称之为<strong>超微型简单方便易用数据库</strong>。</p>
<p><strong>需求</strong>：后台同学最近太忙（😳这不是理由），需要客户端同学临时开发一个本地的浏览历史功能。简单的说就是在客户端本地保存每个用户浏览的文章记录。</p>
<p><strong>吐糟</strong>：好吧，时间紧，任务重，功能先上线，后续再优化已经是一个习惯了😳。</p>
<p><strong>实现方案</strong>：简单，本地存个字典（或者Plist文件），每个key是一个用户id，value是一个数组，数组里的每个元素是一个字典，这个字典里有<code>articleId</code>、<code>title</code>、<code>imgUrl</code>、<code>...</code>。结构大概是这样：</p>
<pre><code>{
  &quot;10086&quot; : [
    {
      &quot;articleId&quot; : 1,
      &quot;imgUrl&quot; : &quot;https://img.xxx.com/abcdefg.png&quot;,
      &quot;title&quot; : &quot;中国历史&quot;,
      ...
    },
    {
      &quot;articleId&quot; : 2,
      &quot;imgUrl&quot; : &quot;https://img.xxx.com/abcdefg.png&quot;,
      &quot;title&quot; : &quot;中国教育&quot;,
      ...
    },
    ...
  ],
  &quot;10087&quot; : [
    {
      &quot;articleId&quot; : 2,
      &quot;imgUrl&quot; : &quot;https://img.xxx.com/abcdefg.png&quot;,
      &quot;title&quot; : &quot;中国教育&quot;,
      ...
    },
    ...
  ]
}
</code></pre><p>看起来OK，但是小伙伴们，性能问题还是要考虑的。我想获取某个用户的浏览历史，需要把文件整体读到内存中，然后用<code>dict[@&quot;10086&quot;]</code>的方法，得到这个用户的浏览历史<code>Array</code>，用户少还好，多了，每次读取的IO操作会很耗时，对性能有影响。</p>
<p>可能你会说用数据库啊什么的，当然可以，但是又是需要依赖一堆第三方，还要写好多代码，创建好多类。我就是想简单实现一下，有没有更好的方法呢？当然有，<strong>超微型简单方便易用数据库</strong>。</p>
<p>每个用户都可以用一个<code>NSUserDefaults</code>来代替，每个用户的浏览历史，可以直接用<code>setObject:forKey:</code>的方式来存储，如：</p>
<pre><code class="objective-c">//这个跟App Groups没有关系
//已有则读取，没有则创建
NSUserDefaults *userDefaults = [[NSUserDefaults alloc] initWithSuiteName:@&quot;10086&quot;];
//存储
[userDefaults setObject:history forKey:@&quot;ArticleBrowsingHistory&quot;];
//读取
NSArray *history = [userDefaults objectForKey:@&quot;ArticleBrowsingHistory&quot;];
</code></pre>
<p>所有用户相对独立，每个用户是一个plist文件，在沙盒目录<code>/Library/Preferences/</code>中，<img src="http://ww2.sinaimg.cn/large/006tNbRwly1ffalfnmhudj30z007kab7.jpg" alt="">想删除也很容易，直接删除这个文件即可。</p>
<p>其实这个<strong>超微型简单方便易用数据库</strong>还可以实现好多功能，看你怎么操作了。如果你的App没有后台，不同用户的主题设置、语言设置可能不同，都可以通过这个来存储。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实很多我们很常用的东西都有很多我们未发掘出的用途，生活也是同样，学会发现，一切会更美好。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在iOS开发中，我们时常需要保存一些数据，或者希望在用户下次打开App时，依然可以保留一些设置等，比如&lt;strong&gt;主题设置&lt;/stron
    
    </summary>
    
    
      <category term="iOS技术分享" scheme="http://blog.darkangel7.com/tags/iOS%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>在iOS App内优雅的动态切换语言</title>
    <link href="http://blog.darkangel7.com/2017/05/04/%E5%9C%A8iOSApp%E5%86%85%E4%BC%98%E9%9B%85%E7%9A%84%E5%8A%A8%E6%80%81%E5%88%87%E6%8D%A2%E8%AF%AD%E8%A8%80/"/>
    <id>http://blog.darkangel7.com/2017/05/04/在iOSApp内优雅的动态切换语言/</id>
    <published>2017-05-04T03:46:56.000Z</published>
    <updated>2017-05-05T09:28:31.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>随着公司业务的发展，App版本的迭代，相信不少App都需要英文化（国际化）。App英文化，不外乎这三点：</p>
<ol>
<li>纯代码中引用的strings国际化；</li>
<li>Storyboard/Xib国际化；</li>
<li>Info.plist国际化。</li>
</ol>
<p>具体这三种分别如何操作，怎么国际化，这里不再赘述。一般App做了国际化，那么在用户切换手机系统Settings里的Language时，App就会切换成对应的语言（前提是做过该语言国际化）。那么如果想实现<strong>微博</strong>和<strong>微信</strong>等App，在App内部实现切换语言，应该怎么做呢？如何做，才能更加优雅的动态切换语言呢？</p>
<p>下面，讲一讲如何在iOS App内优雅的动态切换语言。</p>
<h1 id="调研"><a href="#调研" class="headerlink" title="调研"></a>调研</h1><p>如果有相关需求，一般成熟的App都会怎么做呢？这里我们来看一下<strong>微博</strong>和<strong>微信</strong>。</p>
<p><strong>微博</strong>：</p>
<p><img src="http://ww3.sinaimg.cn/large/006tKfTcly1ff9jfo5a8ig306y0cctz0.gif" alt=""></p>
<p><strong>微信</strong>：</p>
<p><img src="http://ww1.sinaimg.cn/large/006tKfTcly1ff9d5ezj9jg30680b3kif.gif" alt=""></p>
<p>对比一下可以看出，微博整体的效果比微信好很多，丝滑流畅。</p>
<p><strong><em>这里注意一下细节</em></strong>：我在微博的个人中心是故意上滑了一下，然后点击进入设置，进行语言切换，可以看到切换时很自然，然后返回个人中心时，页面<code>scrollView</code>的<code>contentOffset</code>并没有发生变化，由此可以推测：</p>
<p><strong><u>微博的思路是，在切换语言时，发送通知<code>NSNotification</code>，所有的UI控件监听通知，然后在适当的时候刷新UI</u></strong>。那么其实这么写，需要做的东西很多，或是通过Base类来实现，或是通过<code>runtime</code>实现，总之<code>Button</code>、<code>Label</code>、<code>TextField</code>等等都需要有一套统一的更新机制，可能不是一个最简单的办法。</p>
<p><strong><u>而微信切换的方案是，刷新<code>keyWindow</code>的<code>rootViewController</code>，然后跳转到设置页，所以你会看到切换语言的一瞬间界面出现匪夷所思的bug，如下图</u></strong></p>
<p><img src="http://ww1.sinaimg.cn/large/006tKfTcly1ff9iduf60aj306y0cbjrm.jpg" alt=""></p>
<p>其实微信的方案是个最简单的方案，只不过没有处理好这个小系统bug。</p>
<h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><h2 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h2><h3 id="NSBundle"><a href="#NSBundle" class="headerlink" title="NSBundle"></a>NSBundle</h3><p>其实大家应该知道，无论是代码还是Storyboard/Xib，显示的国际化字符串都会走这个方法，传入一个<code>key</code>，获取<code>localizedString</code>。</p>
<p><code>NSBundle</code>的方法：</p>
<pre><code class="objective-c">- (NSString *)localizedStringForKey:(NSString *)key value:(nullable NSString *)value table:(nullable NSString *)tableName;
</code></pre>
<p>比如我们常用的宏<code>NSLocalizedString(@&quot;done&quot;, nil)</code></p>
<pre><code class="objective-c">#define NSLocalizedString(key, comment) \
        [NSBundle.mainBundle localizedStringForKey:(key) value:@&quot;&quot; table:nil]
</code></pre>
<p>那么为何，系统切换语言的时候，此方法返回的就是对应语言（前提做了该语言的国际化）的字符串呢？原因在是哪个<code>bundle</code>调用了这个方法，一般默认的都是<code>NSBundle.mainBundle</code>这个对象。</p>
<pre><code> po [NSBundle allBundles]

&lt;__NSArrayI 0x608000052f60&gt;(
NSBundle &lt;/Users/DarkAngel/Library/Developer/CoreSimulator/Devices/CF831783-E4A6-4EC2-AB99-E04304331C3A/data/Containers/Bundle/Application/B391ED77-F57B-4B5E-9E53-CFD1245583D8/LanguageSettingsDemo.app/en.lproj&gt; (not yet loaded),
NSBundle &lt;/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/Frameworks/UIKit.framework/Artwork.bundle&gt; (not yet loaded),
DABundle &lt;/Users/DarkAngel/Library/Developer/CoreSimulator/Devices/CF831783-E4A6-4EC2-AB99-E04304331C3A/data/Containers/Bundle/Application/B391ED77-F57B-4B5E-9E53-CFD1245583D8/LanguageSettingsDemo.app&gt; (loaded)
)
</code></pre><p>可以看到有默认加载的bundle，还有个没加载的en bundle。所以，切换语言，其实只要切换了<code>bundle</code>对象，就可以让这个<code>bundle</code>根据<code>key</code>返回不同的<code>localizedString</code>。</p>
<h3 id="NSUserDefaults"><a href="#NSUserDefaults" class="headerlink" title="NSUserDefaults"></a>NSUserDefaults</h3><p>其实语言设置，只要修改<code>AppleLanguages</code>对应的值就好了。这样才能加载正确语言的<code>Storyboard/Xib</code>，以及一些<code>resources</code>(图片之类的)。</p>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>方案其实很简单，每次切换语言，把用户选择的语言保存在本地，同时更改<code>bundle</code>对象，然后刷新页面就可以了。</p>
<p><img src="http://ww2.sinaimg.cn/large/006tKfTcly1ff9ji4gz3kg306y0cce09.gif" alt=""></p>
<h2 id="技术细节"><a href="#技术细节" class="headerlink" title="技术细节"></a>技术细节</h2><h3 id="保存用户设置"><a href="#保存用户设置" class="headerlink" title="保存用户设置"></a>保存用户设置</h3><p>很简单，保存在<code>NSUserDefaults</code>里。</p>
<p>这里需要说明的是<strong>跟随手机系统</strong>，即清除用户自定义设置，只需要将<code>AppleLanguages</code>字段设为<code>nil</code>即可。</p>
<p>但是当<code>AppleLanguages</code>字段设为nil，你再去获取它的值时，会发现他已经变成了系统语言的默认值。这里可以参考<a href="http://blog.darkangel7.com/2017/05/05/iOS中NSUserDefaults的黑科技/">这篇文章</a>。</p>
<p>.h</p>
<pre><code class="objective-c">/**
 设置类
 */
@interface UWConfig : NSObject
/**
 用户自定义使用的语言，当传nil时，等同于resetSystemLanguage
 */
@property (class, nonatomic, strong, nullable) NSString *userLanguage;
/**
 重置系统语言
 */
+ (void)resetSystemLanguage;
@end
</code></pre>
<p>.m</p>
<pre><code class="objective-c">#import &quot;UWConfig.h&quot;

static NSString *const UWUserLanguageKey = @&quot;UWUserLanguageKey&quot;;
#define STANDARD_USER_DEFAULT  [NSUserDefaults standardUserDefaults]

@implementation UWConfig
+ (void)setUserLanguage:(NSString *)userLanguage
{
    //跟随手机系统
    if (!userLanguage.length) {
        [self resetSystemLanguage];
        return;
    }
    //用户自定义
    [STANDARD_USER_DEFAULT setValue:userLanguage forKey:UWUserLanguageKey];
    [STANDARD_USER_DEFAULT setValue:@[userLanguage] forKey:@&quot;AppleLanguages&quot;];
    [STANDARD_USER_DEFAULT synchronize];
}

+ (NSString *)userLanguage
{
    return [STANDARD_USER_DEFAULT valueForKey:UWUserLanguageKey];
}

/**
 重置系统语言
 */
+ (void)resetSystemLanguage
{
    [STANDARD_USER_DEFAULT removeObjectForKey:UWUserLanguageKey];
    [STANDARD_USER_DEFAULT setValue:nil forKey:@&quot;AppleLanguages&quot;];
    [STANDARD_USER_DEFAULT synchronize];
}

@end
</code></pre>
<p>在需要的地方调用即可，如</p>
<pre><code class="objective-c">   if (indexPath.row == 0) {
        [UWConfig setUserLanguage:nil];
    } else if (indexPath.row == 1) {
        [UWConfig setUserLanguage:@&quot;zh-Hans&quot;];
    } else {
        [UWConfig setUserLanguage:@&quot;en&quot;];
    }
</code></pre>
<h3 id="切换Bundle"><a href="#切换Bundle" class="headerlink" title="切换Bundle"></a>切换Bundle</h3><p>当需要展示内容时，才需要用到<code>bundle</code>，我们要手动切换<code>bundle</code>对象，就用到了这几个方法：</p>
<pre><code class="objective-c">+ (nullable instancetype)bundleWithPath:(NSString *)path;
- (nullable instancetype)initWithPath:(NSString *)path NS_DESIGNATED_INITIALIZER;

+ (nullable instancetype)bundleWithURL:(NSURL *)url NS_AVAILABLE(10_6, 4_0);
- (nullable instancetype)initWithURL:(NSURL *)url NS_AVAILABLE(10_6, 4_0);
</code></pre>
<p>这里直接上代码</p>
<p>.h</p>
<pre><code class="objective-c">@interface NSBundle (UWUtils)

+ (BOOL)isChineseLanguage;

+ (NSString *)currentLanguage;

@end
</code></pre>
<p>.m</p>
<pre><code class="objective-c">#import &quot;NSBundle+UWUtils.h&quot;

@interface UWBundle : NSBundle

@end

@implementation NSBundle (UWUtils)

+ (BOOL)isChineseLanguage
{
    NSString *currentLanguage = [self currentLanguage];
    if ([currentLanguage hasPrefix:@&quot;zh-Hans&quot;]) {
        return YES;
    } else {
        return NO;
    }
}

+ (NSString *)currentLanguage
{
    return [UWConfig userLanguage] ? : [NSLocale preferredLanguages].firstObject;
}

+ (void)load
{
    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{
        //动态继承、交换，方法类似KVO，通过修改[NSBundle mainBundle]对象的isa指针，使其指向它的子类UWBundle，这样便可以调用子类的方法；其实这里也可以使用method_swizzling来交换mainBundle的实现，来动态判断，可以同样实现。
        object_setClass([NSBundle mainBundle], [UWBundle class]);
    });
}

@end

@implementation UWBundle

- (NSString *)localizedStringForKey:(NSString *)key value:(NSString *)value table:(NSString *)tableName
{
    if ([UWBundle uw_mainBundle]) {
        return [[UWBundle uw_mainBundle] localizedStringForKey:key value:value table:tableName];
    } else {
        return [super localizedStringForKey:key value:value table:tableName];
    }
}

+ (NSBundle *)uw_mainBundle
{
    if ([NSBundle currentLanguage].length) {
        NSString *path = [[NSBundle mainBundle] pathForResource:[NSBundle currentLanguage] ofType:@&quot;lproj&quot;];
        if (path.length) {
            return [NSBundle bundleWithPath:path];
        }
    }
    return nil;
}

@end
</code></pre>
<p>这里涉及到了<code>runtime</code>的使用，代码中有注释，这里就不展开了。</p>
<h3 id="刷新页面"><a href="#刷新页面" class="headerlink" title="刷新页面"></a>刷新页面</h3><p>用微信的思路，简单化，不必要处理很多，我们只要替换<code>keyWindow</code>的<code>rootViewController</code>就好，同时解决微信的bug。</p>
<pre><code class="objective-c">    UITabBarController *tbc = [[UIStoryboard storyboardWithName:@&quot;Main&quot; bundle:[NSBundle mainBundle]] instantiateInitialViewController];
    //我这里的storyboard为了便于多人合作，这里只包含根tabBarController和多个nvc，每个nvc只有自己的rootViewController
    //跳转到个人中心
    tbc.selectedIndex = 4;
    //创建设置页面
    UWSettingViewController *vc1 = [[UIStoryboard storyboardWithName:@&quot;Main&quot; bundle:[NSBundle mainBundle]] instantiateViewControllerWithIdentifier:NSStringFromClass([UWSettingViewController class])];
    vc1.hidesBottomBarWhenPushed = YES;
    //创建语言切换页
    UWLanguageSettingsViewController *vc2 = [[UIStoryboard storyboardWithName:@&quot;Main&quot; bundle:[NSBundle mainBundle]] instantiateViewControllerWithIdentifier:NSStringFromClass([UWLanguageSettingsViewController class])];
    vc2.hidesBottomBarWhenPushed = YES;
    UINavigationController *nvc = tbc.selectedViewController;
    //备用
    NSMutableArray *vcs = nvc.viewControllers.mutableCopy;
    [vcs addObjectsFromArray:@[vc1, vc2]];
    //解决奇怪的动画bug。异步执行
    dispatch_async(dispatch_get_main_queue(), ^{
        //注意刷新rootViewController的时机，在主线程异步执行
        //先刷新rootViewController
        [UIApplication sharedApplication].keyWindow.rootViewController = tbc;
        //然后再给个人中心的nvc设置viewControllers
        nvc.viewControllers = vcs;
        //一些UI提示，可以提供更友好的用户交互（也可以删掉）
        [UWProgressHUD showLoadingWithMessage:NSLocalizedString(UWSettingMessage, nil)];
        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(.5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
            [UWProgressHUD dismiss];
        });
    });
</code></pre>
<p>整体下来，就可以实现在App内优雅的切换语言。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实在实践过程中，坑还是很多的，欢迎提问。</p>
<p>下面附上个简单的<a href="https://github.com/DarkAngel7/Demos-LanguageSettingsDemo/" target="_blank" rel="external">Demo</a>，是上面说的简化版本，大家有需要可以下载看下。里面有小福利哦，慢慢找吧~</p>
<p>最后，<a href="https://itunes.apple.com/cn/app/you-ke-gong-chang/id1034170822?mt=8" target="_blank" rel="external">优客工场</a>欢迎您。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;随着公司业务的发展，App版本的迭代，相信不少App都需要英文化（国际化）。App英文化，不外乎这三点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;纯代码中
    
    </summary>
    
    
      <category term="iOS技术分享" scheme="http://blog.darkangel7.com/tags/iOS%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>Jenkins部署MacOS Slave实现持续集成(iOS)</title>
    <link href="http://blog.darkangel7.com/2017/04/28/Jenkins%E9%83%A8%E7%BD%B2MacOS%20Slave%E5%AE%9E%E7%8E%B0%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90(iOS)/"/>
    <id>http://blog.darkangel7.com/2017/04/28/Jenkins部署MacOS Slave实现持续集成(iOS)/</id>
    <published>2017-04-28T10:49:16.000Z</published>
    <updated>2017-05-04T04:30:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>解决Linux服务器上的Jenkins无法构建Xcode工程</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于Linux服务器无法安装Xcode，所以Jenkins无法通过shell来调用xcodebuild、xcrun等命令来构建Xcode工程，因此无法持续集成，敏捷开发。下面介绍一种配置Jenkins节点的方式，来实现Linux上的Jenkins构建Xcode工程，并上传ipa到蒲公英pgyer来进行测试。</p>
<h2 id="一、配置MacOS-Slave"><a href="#一、配置MacOS-Slave" class="headerlink" title="一、配置MacOS Slave"></a>一、配置MacOS Slave</h2><p>Jenkins有个强大的功能，配置Slave(奴隶)服务器，来实现分布式部署构建。具体步骤如下：</p>
<h3 id="1-配置Mac电脑。"><a href="#1-配置Mac电脑。" class="headerlink" title="1. 配置Mac电脑。"></a>1. 配置Mac电脑。</h3><p>在<strong>系统偏好设置</strong> &gt; <strong>共享</strong> 中开启 <strong>远程登录</strong>，如下图：<br><img src="https://ww3.sinaimg.cn/large/006tNc79ly1ff2hls2iauj31140tidjg.jpg" alt=""> </p>
<h3 id="2-创建节点。"><a href="#2-创建节点。" class="headerlink" title="2. 创建节点。"></a>2. 创建节点。</h3><p>Jenkins &gt; 系统管理 &gt;  管理节点 &gt; 新建节点，输入节点名称，记得勾选 <code>Permanent Agent</code>，点击OK。</p>
<h3 id="3-配置节点。"><a href="#3-配置节点。" class="headerlink" title="3. 配置节点。"></a>3. 配置节点。</h3><p><img src="https://ww2.sinaimg.cn/large/006tNc79ly1ff2hfwxx8ej31eg0ts0wt.jpg" alt="">其中要保证<code>/User/Shared/Jenkins/</code>目录的权限为ssh链接的用户可读写。</p>
<p>Host是Mac的ip地址，Credentials是ssh登录Mac时需要的账户和密码。可以添加一个</p>
<p><img src="https://ww4.sinaimg.cn/large/006tNc79ly1ff2hhcg0f1j31gq0r842o.jpg" alt=""></p>
<p><strong>下面的部分很重要</strong>：<img src="https://ww2.sinaimg.cn/large/006tNc79ly1ff2hiwj7mpj31gs0p4dj8.jpg" alt=""></p>
<p>PATH环境变量，需要在Mac上通过</p>
<pre><code>echo $PATH
/opt/iOSOpenDev/bin:/opt/local/bin:/opt/local/sbin:/opt/local/bin:/opt/local/sbin:/opt/local/bin:/opt/local/sbin:/opt/local/bin:/opt/local/sbin:/opt/local/bin:/opt/local/sbin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/opt/local/bin:/opt/local/sbin/
</code></pre><p>获取，然后copy过去。</p>
<p>Keychains and Provisioning Profiles路径要填写正确。没有这个选项的安装<a href="http://wiki.jenkins-ci.org/display/JENKINS/Keychains+and+Provisioning+Profiles+Plugin" target="_blank" rel="external">Keychains and Provisioning Profiles Management</a>插件。</p>
<h3 id="4-最后保存。"><a href="#4-最后保存。" class="headerlink" title="4. 最后保存。"></a>4. 最后保存。</h3><p>如果看到</p>
<p><img src="https://ww2.sinaimg.cn/large/006tNc79ly1ff2hwlrqw8j30e203uglm.jpg" alt=""></p>
<p>即添加Mac Slave成功，且Mac Slave在线。若连不上，请反复确认<strong>远程工作目录</strong>的权限。</p>
<h2 id="二、配置Jenkins系统设置。"><a href="#二、配置Jenkins系统设置。" class="headerlink" title="二、配置Jenkins系统设置。"></a>二、配置Jenkins系统设置。</h2><h3 id="1-上传证书和描述文件。"><a href="#1-上传证书和描述文件。" class="headerlink" title="1. 上传证书和描述文件。"></a>1. 上传证书和描述文件。</h3><p>在 <strong>Jenkins</strong> &gt; <strong>系统管理</strong> &gt; <strong>Keychains and Provisioning Profiles Management</strong>中上传打包用的证书和描述文件。如下图：</p>
<p><img src="https://ww4.sinaimg.cn/large/006tNc79ly1ff2jcabj18j31kw0tijyh.jpg" alt=""></p>
<p><img src="https://ww2.sinaimg.cn/large/006tNc79ly1ff2jclndwnj31jy0siwic.jpg" alt=""></p>
<p>保存。</p>
<h3 id="2-在-Jenkins-gt-系统管理-gt-系统设置（全局设置）中设置："><a href="#2-在-Jenkins-gt-系统管理-gt-系统设置（全局设置）中设置：" class="headerlink" title="2. 在 Jenkins &gt; 系统管理 &gt; 系统设置（全局设置）中设置："></a>2. 在 <strong>Jenkins</strong> &gt; <strong>系统管理</strong> &gt; <strong>系统设置</strong>（全局设置）中设置：</h3><p><img src="https://ww1.sinaimg.cn/large/006tNc79ly1ff2j6764qgj31ei0t6adx.jpg" alt=""></p>
<p>很关键。<strong>Keychain</strong>的路径和密码需要填写Mac中登录用户的密码。</p>
<h3 id="3-在-Jenkins-gt-系统管理-gt-Configure-Global-Security-中配置："><a href="#3-在-Jenkins-gt-系统管理-gt-Configure-Global-Security-中配置：" class="headerlink" title="3. 在 Jenkins &gt; 系统管理 &gt; Configure Global Security 中配置："></a>3. 在 <strong>Jenkins</strong> &gt; <strong>系统管理</strong> &gt; <strong>Configure Global Security</strong> 中配置：</h3><p><img src="https://ww2.sinaimg.cn/large/006tNc79ly1ff2j8ffcsrj31jw0ckjt4.jpg" alt=""></p>
<p>开启Safe HTML。</p>
<h2 id="三、配置iOS项目。"><a href="#三、配置iOS项目。" class="headerlink" title="三、配置iOS项目。"></a>三、配置iOS项目。</h2><h3 id="1-安装插件。"><a href="#1-安装插件。" class="headerlink" title="1. 安装插件。"></a>1. 安装插件。</h3><p>安装 <code>build-name-setter</code>、<code>description setter plugin</code>插件。</p>
<h3 id="2-Jenkins-gt-新建。"><a href="#2-Jenkins-gt-新建。" class="headerlink" title="2. Jenkins &gt; 新建。"></a>2. <strong>Jenkins</strong> &gt; <strong>新建</strong>。</h3><p><img src="https://ww2.sinaimg.cn/large/006tNc79ly1ff2iw797sjj318q0vidm6.jpg" alt=""></p>
<h3 id="3-General"><a href="#3-General" class="headerlink" title="3. General."></a>3. <strong>General</strong>.</h3><p><img src="https://ww3.sinaimg.cn/large/006tNc79ly1ff2jedt21qj31kw0u2afo.jpg" alt=""></p>
<p>这里添加了参数化构建过程，为了在每次Build时，可以填写更新说明，所以这里天添加了名为<code>News</code>的参数，当用户构建时填写了内容，可以在之后的脚本中通过<code>${News}</code>来获取<code>News</code>的值。</p>
<p><img src="https://ww1.sinaimg.cn/large/006tNc79ly1ff2jf005ogj31kw0o1q5k.jpg" alt=""></p>
<p>这里指定Mac Slave服务器作为构建Xcode工程的Slave服务器，Xcode打包构建全部交给这个节点（Slave服务器）来完成。</p>
<p><img src="https://ww1.sinaimg.cn/large/006tNc79ly1ff2jfc0bfij31kw0d2jsv.jpg" alt=""></p>
<h3 id="4-源码管理。"><a href="#4-源码管理。" class="headerlink" title="4. 源码管理。"></a>4. 源码管理。</h3><p><img src="https://ww4.sinaimg.cn/large/006tNc79ly1ff2jh0iaijj31jk0uk41x.jpg" alt=""></p>
<p>这里填写本地或者远程的代码仓库（如gitlab或者git）。下面的Branch填写指定分支。</p>
<h3 id="5-构建触发器。"><a href="#5-构建触发器。" class="headerlink" title="5. 构建触发器。"></a>5. 构建触发器。</h3><p>这里暂时不设置，设置了可以自动化测试，和其他脚本配合使用。</p>
<h3 id="6-构建环境。"><a href="#6-构建环境。" class="headerlink" title="6. 构建环境。"></a>6. 构建环境。</h3><p><img src="https://ww1.sinaimg.cn/large/006tNc79ly1ff2jqxdzccj31kw0txq9d.jpg" alt=""></p>
<p><img src="https://ww3.sinaimg.cn/large/006tNc79ly1ff2jssknawj31kw0pnn2s.jpg" alt=""></p>
<p>把之前上传的证书和描述文件添加上。</p>
<p>设置Build名称，这里添加了自定义名称。注意，高级里面只勾选第一个，不要勾选 <code>Set build name after build ends</code>，否则会报错。</p>
<h3 id="7-构建"><a href="#7-构建" class="headerlink" title="7. 构建"></a>7. 构建</h3><p><img src="https://ww2.sinaimg.cn/large/006tNc79ly1ff2jwre537j31kw0pygr0.jpg" alt=""></p>
<p>这里使用的脚本。</p>
<pre><code>export LANG=&quot;en_US.UTF-8&quot;

security -v unlock-keychain -p &quot;yourpassword&quot;

ipa_name=&quot;URWork_iOS_beta&quot;
build_path=&quot;${WORKSPACE}/build/&quot;
fastlane gym --workspace URWorkClient.xcworkspace --scheme URWorkClient --clean --configuration Beta --export_method ad-hoc --output_name ${ipa_name} --output_directory ${build_path}

curl -F &quot;file=@${build_path}${ipa_name}.ipa&quot; \
-F &quot;uKey=yourUKey&quot; \
-F &quot;_api_key=yourApiKey&quot; \
-F &quot;updateDescription=${News}&quot; \
https://www.pgyer.com/apiv1/app/upload
</code></pre><h4 id="最重要、最重要、最重要："><a href="#最重要、最重要、最重要：" class="headerlink" title="最重要、最重要、最重要："></a><strong>最重要、最重要、最重要：</strong></h4><p>Linux服务器上的Jenkins调用Mac Slave时，是通过之前设置的<strong>SSH</strong>登录的方式，而Apple为了安全，在ssh登录时，是不允许读取<strong>Keychains</strong>（钥匙串）的，所以 <code>security -v unlock-keychain -p &quot;yourpassword&quot;</code>这行命令就很重要了。在构建打包前，先解锁Keychains。</p>
<p>当然这里 <strong>fastlane</strong> 已经提前通过<strong>Homebrew</strong>安装好了，这里不再赘述。</p>
<blockquote>
<p><em>整体脚本的流程是，先解锁Keychain，然后用fastlane快速打包，最后上传到蒲公英平台，等待测试。</em></p>
</blockquote>
<h3 id="8-构建后操作。"><a href="#8-构建后操作。" class="headerlink" title="8. 构建后操作。"></a>8. 构建后操作。</h3><p><img src="https://ww2.sinaimg.cn/large/006tNc79ly1ff2k7cb7ptj31kw0ktjue.jpg" alt=""></p>
<p>附代码：</p>
<pre><code>&lt;h3&gt;更新说明:&lt;/h3&gt;&lt;p&gt;${News}&lt;/p&gt;&lt;a href=&quot;http://www.pgyer.com/urwork_ios&quot; style=&quot;display:block;margin:10px 0px;&quot; target=&quot;_blank&quot;&gt;点击跳转到下载页&lt;/a&gt;&lt;/br&gt;&lt;img src=&quot;http://www.pgyer.com/app/qrcode/urwork_ios&quot;&gt;
</code></pre><p>构建完成后，把之前用户输入的<strong>更新说明</strong>以及<strong>蒲公英下载地址</strong>和<strong>二维码</strong>通通显示在Build Description中。</p>
<h2 id="四、整体测试"><a href="#四、整体测试" class="headerlink" title="四、整体测试"></a>四、整体测试</h2><h3 id="1-打开Jenkins。"><a href="#1-打开Jenkins。" class="headerlink" title="1. 打开Jenkins。"></a>1. 打开Jenkins。</h3><p><img src="https://ww1.sinaimg.cn/large/006tNc79ly1ff2kbajk7cj31kw0u6jxm.jpg" alt=""></p>
<h3 id="2-点击develop-iOS。"><a href="#2-点击develop-iOS。" class="headerlink" title="2. 点击develop_iOS。"></a>2. 点击develop_iOS。</h3><p><img src="https://ww1.sinaimg.cn/large/006tNc79ly1ff2kang8dkj31kw0tf7c5.jpg" alt=""></p>
<h3 id="3-点击Build-with-Parameters"><a href="#3-点击Build-with-Parameters" class="headerlink" title="3. 点击Build with Parameters."></a>3. 点击Build with Parameters.</h3><p><img src="https://ww2.sinaimg.cn/large/006tNc79ly1ff2kdk1zdfj31kw0tktds.jpg" alt=""></p>
<h3 id="4-开始构建。"><a href="#4-开始构建。" class="headerlink" title="4. 开始构建。"></a>4. 开始构建。</h3><p><img src="https://ww4.sinaimg.cn/large/006tNc79ly1ff2keezip1j31kw0tf10n.jpg" alt=""></p>
<h3 id="5-等待构建完成即可。"><a href="#5-等待构建完成即可。" class="headerlink" title="5. 等待构建完成即可。"></a>5. 等待构建完成即可。</h3><p>这里也可以查看构建进度：点击最新的一次构建</p>
<p><img src="https://ww3.sinaimg.cn/large/006tNc79ly1ff2kg18untj31kw0s1tdq.jpg" alt=""></p>
<p>点击Console Output<br><img src="https://ww4.sinaimg.cn/large/006tNc79ly1ff2kgpirr9j31kw0sj13w.jpg" alt=""></p>
<p>在这里可以查看一些日志，如果出错了，也可以在这里查询。</p>
<h2 id="五、总结。"><a href="#五、总结。" class="headerlink" title="五、总结。"></a>五、总结。</h2><p>使用Jenkins打包Xcode工程整体过程很曲折，坑很多，按照这些来，可能还会遇到一些问题，附上一些链接，以供参考。</p>
<h2 id="附"><a href="#附" class="headerlink" title="附"></a>附</h2><ul>
<li><a href="http://www.jianshu.com/p/371595ef08fe" target="_blank" rel="external">Jenkins+ Xcode+ 蒲公英 实现IOS自动化打包和分发</a></li>
<li><a href="http://www.jianshu.com/p/41ecb06ae95f" target="_blank" rel="external">手把手教你利用Jenkins持续集成iOS项目</a></li>
<li><a href="http://www.jianshu.com/p/62fa8083b45c" target="_blank" rel="external">Jenkins签名问题</a></li>
<li><a href="https://www.pgyer.com/doc/view/jenkins_ios" target="_blank" rel="external">使用 Jenkins 实现持续集成 (iOS)</a></li>
<li><a href="https://www.pgyer.com/doc/view/jenkins" target="_blank" rel="external">使用 Jenkins 实现持续集成 (Android)</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;解决Linux服务器上的Jenkins无法构建Xcode工程&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;由于Linux服务器无法安装Xcode，所以Jenkins无法通
    
    </summary>
    
    
      <category term="iOS技术分享" scheme="http://blog.darkangel7.com/tags/iOS%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+Github的Blog搭建</title>
    <link href="http://blog.darkangel7.com/2016/08/19/Hexo+Github%E7%9A%84Blog%E6%90%AD%E5%BB%BA/"/>
    <id>http://blog.darkangel7.com/2016/08/19/Hexo+Github的Blog搭建/</id>
    <published>2016-08-19T04:40:16.000Z</published>
    <updated>2017-05-08T02:38:09.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装："><a href="#安装：" class="headerlink" title="安装："></a>安装：</h1><h2 id="一、安装Homebrew"><a href="#一、安装Homebrew" class="headerlink" title="一、安装Homebrew"></a>一、安装Homebrew</h2><p>Mac上已经安装了ruby环境，只需要输入</p>
<pre><code>ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;
</code></pre><h2 id="二、安装node-js"><a href="#二、安装node-js" class="headerlink" title="二、安装node.js"></a>二、安装node.js</h2><pre><code>sudo brew install node
</code></pre><h2 id="三、安装Hexo"><a href="#三、安装Hexo" class="headerlink" title="三、安装Hexo"></a>三、安装Hexo</h2><p>Hexo是基于node.js的博客系统，这里安装就可以了。</p>
<pre><code>sudo npm install -g hexo 
npm install hexo-renderer-ejs --save
npm install hexo-renderer-stylus --save
npm install hexo-renderer-marked --save
</code></pre><p>安装完成后，找一个放blog的目录</p>
<pre><code>cd ~/Blog
</code></pre><p>然后执行初始化</p>
<pre><code>hexo init
</code></pre><p>然后可以直接预览hello word.md</p>
<pre><code>hexo g
hexo s
=&gt; [info] Hexo is running at localhost:4000/. Press Ctrl+C to stop.
</code></pre><p>g是generate, s是server，还有d是deploy（部署）推荐用首字母，方便快捷。</p>
<h2 id="四、创建Blog-Repository"><a href="#四、创建Blog-Repository" class="headerlink" title="四、创建Blog Repository"></a>四、创建Blog Repository</h2><p>在自己的Github创建Blog的仓库，如Blog-Hexo，命名无所谓。记住勾选README。</p>
<p><img src="http://ww4.sinaimg.cn/large/65e4f1e6jw1f72qarsjd9j20va0aydh0.jpg" alt="repository1"></p>
<p><img src="http://ww2.sinaimg.cn/large/65e4f1e6jw1f72qbhppqfj214a0sqq6q.jpg" alt="repository2"><br>创建完毕，直接进行到下一步。</p>
<h2 id="五、购买域名"><a href="#五、购买域名" class="headerlink" title="五、购买域名"></a>五、购买域名</h2><p>推荐在万网购买，国外的Godaddy也可以。以万网为例：<br>买好域名实名认证了之后，到<code>控制台</code> - <code>云解析DNS</code>中添加一个解析，如：</p>
<p><img src="http://ww4.sinaimg.cn/large/65e4f1e6jw1f72qblgcswj21kw01qglt.jpg" alt=""></p>
<p>CNAME映射到自己的xxx.github.io。这里的xxx是你的在github的名称，我的是<code>DarkAngel7</code>。<br>在终端中输入</p>
<pre><code>dig blog.darkangel7.com +nostats +nocomments +nocmd
</code></pre><p>如果出现下面的结果，证明解析成功。</p>
<pre><code>DarkAngel-MacBook-Pro-2:Blog DarkAngel$ dig blog.darkangel7.com +nostats +nocomments +nocmd

; &lt;&lt;&gt;&gt; DiG 9.8.3-P1 &lt;&lt;&gt;&gt; blog.darkangel7.com +nostats +nocomments +nocmd
;; global options: +cmd
;blog.darkangel7.com.        IN    A
blog.darkangel7.com.    30    IN    CNAME    darkangel7.github.io.
darkangel7.github.io.    2516    IN    CNAME    github.map.fastly.net.
github.map.fastly.net.    30    IN    CNAME    prod.github.map.fastlylb.net.
prod.github.map.fastlylb.net. 30 IN    A    151.101.100.133
</code></pre><h2 id="六、Deploy"><a href="#六、Deploy" class="headerlink" title="六、Deploy"></a>六、Deploy</h2><p>上一步完成域名到github pages的单向映射。本步完成github到域名的映射，完成输入域名解析到对应的内容。</p>
<p>首先在Blog/source里创建CNAME</p>
<pre><code>cd source
touch CNAME
vi CNAME
</code></pre><p>输入你在上一步CNAME的域名，建立映射关系。</p>
<pre><code>blog.darkangel7.com
</code></pre><p>修改<code>_config.yml</code>文件，配置一些东西。</p>
<pre><code># Deployment
## Docs: https://hexo.io/docs/deployment.html
deploy:
      type: git
      repository: git@github.com:DarkAngel7/Blog-Hexo.git
</code></pre><p>安装git插件</p>
<pre><code>npm install hexo-deployer-git --save
</code></pre><p>这里repository的地址可以是https的，也可以是git的，只不过git需要SSH证书，一般用https就可以了，如果出现443错误，替换成git。</p>
<p>然后在Blog目录下</p>
<pre><code>hexo g -d
</code></pre><p>生成静态文件并且部署出去，不出意外，已经可以外网访问了。</p>
<h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><h2 id="一、访问速度"><a href="#一、访问速度" class="headerlink" title="一、访问速度"></a>一、访问速度</h2><p>由于Google被墙，大部分主题中引用的jquery都会因为超时（可以Blog目录下搜索google），而造成页面访问很慢，这里需要将jquery改为百度的<br>​    </p>
<pre><code>&lt;script src=&quot;//apps.bdimg.com/libs/jquery/2.0.3/jquery.min.js&quot;&gt;&lt;/script&gt;
</code></pre><h2 id="二、RSS订阅"><a href="#二、RSS订阅" class="headerlink" title="二、RSS订阅"></a>二、RSS订阅</h2><p>输入命令</p>
<pre><code>$ npm install hexo-generator-feed --save
</code></pre><p>然后在_config.yml中，添加<br>​    </p>
<pre><code>rss: /atom.xml
feed:
     type: atom
    path: atom.xml
     limit: 20
</code></pre><h2 id="三、搜索支持"><a href="#三、搜索支持" class="headerlink" title="三、搜索支持"></a>三、搜索支持</h2><p>现在在百度和Google是搜不到你的网站的，为了让搜索引擎搜索到，需要做一些工作。</p>
<p>搜索引擎入口</p>
<ul>
<li><a href="https://www.google.com/webmasters/tools/home?hl=zh-CN" target="_blank" rel="external">Google搜索引擎提交入口</a></li>
<li><a href="http://www.baidu.com/search/url_submit.htm" target="_blank" rel="external">百度搜索引擎入口</a></li>
</ul>
<p>添加sitemap.xml：</p>
<p>首先输入：</p>
<pre><code>npm install hexo-generator-sitemap --save
npm install hexo-generator-baidu-sitemap --save    
npm install hexo-baidu-url-submit --save
</code></pre><p>前两个插件用于生成sitemap，后一个插件用于主动推送链接到百度（<strong>防止百度爬虫抓取失败，导致百度搜不到您的博客</strong>，这里有一篇<a href="http://guochenglai.com/2016/09/26/baidu-crow-github-page/" target="_blank" rel="external">关于百度无法爬取Github Pages静态网站解决方案</a>）。</p>
<p>然后在<code>_config.yml</code>文件中添加</p>
<pre><code>sitemap:
         path: sitemap.xml
baidusitemap:
         path: baidusitemap.xml

## BaiduUrlSubmit: http://hui-wang.info/2016/10/23/Hexo插件之百度主动提交链接/    
baidu_url_submit:        ##主动推送新文章到百度
  count: 3 ## 比如3，代表提交最新的三个链接
  host: blog.darkangel7.com ## 在百度站长平台中注册的域名
  token: your_token ## 请注意这是您的秘钥， 请不要发布在公众仓库里!
  path: baidu_urls.txt ## 文本文档的地址， 新链接会保存在此文本文档里

##同时要检查这里有没有URL值，必须包含是百度站长平台注册的域名，比如 
# URL
url: http://blog.darkangel7.com
root: /
permalink: :year/:month/:day/:title/

##最后，加入新的deployer，如
deploy:
- type: git
  repository: git@github.com:DarkAngel7/Blog-Hexo.git
- type: baidu_url_submitter  ## 百度链接主动推送
</code></pre><p>先验证网站所有权，下载html，mv到Blog/themes/yourtheme/source目录下，执行</p>
<pre><code>hexo g -d
</code></pre><p>验证成功后，添加百度自动推送脚本，最好在<code>head.ejs</code>中添加百度自动推送的代码，至于<code>head.ejs</code>文件位置，在你使用的theme文件夹下搜索吧。<br>谷歌的话，在<code>抓取</code>-<code>站点地图</code>里面添加就好。</p>
<p>这样主动推送与自动推送结合，能很好的提高您文章的曝光率。    </p>
<h2 id="四、评论功能"><a href="#四、评论功能" class="headerlink" title="四、评论功能"></a>四、评论功能</h2><p>可以使用<a href="http://duoshuo.com" target="_blank" rel="external">多说</a>来提供评论功能。首先，在<code>_config.yml</code>文件中添加</p>
<pre><code># Duoshuo
duoshuo_shortname: yoursite.doushuo.com
</code></pre><p>  然后，搜索themes文件夹下，你使用的theme文件目录下的<code>commemt.ejs</code>（不同的theme可能位置不同，请自行寻找）。修改如下：</p>
<pre><code> &lt;div id=&quot;comment&quot; class=&quot;comments-area&quot;&gt;
     &lt;% if(config.duoshuo_shortname) { %&gt;
     &lt;! -- 多说的代码 --&gt; 
     &lt;% } %&gt; 
&lt;/div&gt;    

 如果报关于data-thread-key的错误，则改成下面这样：
 &lt;div class=&quot;ds-thread&quot; data-thread-key=&quot;&lt;%= page.path %&gt;&quot; data-title=&quot;&lt;%= page.title %&gt;&quot; data-url=&quot;&lt;%= page.permalink %&gt;&quot;&gt;&lt;/div    &gt;
</code></pre><h2 id="五、分享功能"><a href="#五、分享功能" class="headerlink" title="五、分享功能"></a>五、分享功能</h2><p>可以在Blog目录下搜索<code>post/share</code>，一般在<code>article.ejs</code>文件中，或者<code>post.ejs</code>文件中，然后替换</p>
<pre><code>&lt;%- partial(&#39;post/author&#39;) %&gt;
</code></pre><p>为<a href="http://share.baidu.com/code" target="_blank" rel="external">百度分享</a>提供的代码。</p>
<h2 id="六、个人信息完善"><a href="#六、个人信息完善" class="headerlink" title="六、个人信息完善"></a>六、个人信息完善</h2><p>网站的信息一般都在<code>Blog/_config.yml</code>中修改。</p>
<p>关于Theme，去官方提供的<a href="https://github.com/tommy351/hexo/wiki/Themes" target="_blank" rel="external">主题列表</a>中选个现成的，按照里面的方法pull下来，如light主题</p>
<pre><code>$ git clone git://github.com/tommy351/hexo-theme-light.git themes/light
</code></pre><p>然后在<code>_config.yml</code>配置文件中设置：</p>
<pre><code>theme: light
</code></pre><p>关于主题的优化，一般在<code>themes/yourtheme/_config.yml</code>中配置。</p>
<h1 id="写文章"><a href="#写文章" class="headerlink" title="写文章"></a>写文章</h1><p>在Blog目录下，创建</p>
<pre><code>hexo new 文章题目
</code></pre><p>然后用Markdown编写，写好后save。</p>
<pre><code>hexo g
hexo s
</code></pre><p>生成，然后在本地localhost:4000预览一下，如果没有问题，就可以发布了。</p>
<pre><code>hexo d
</code></pre><p>所有的文章都是放在<code>Blog/source/_posts/</code>目录下的，可以随时编辑修改。</p>
<h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>还有一些其他的修改，这里就不一一提了，等待你慢慢发现。现在快开始写作吧~~</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;安装：&quot;&gt;&lt;a href=&quot;#安装：&quot; class=&quot;headerlink&quot; title=&quot;安装：&quot;&gt;&lt;/a&gt;安装：&lt;/h1&gt;&lt;h2 id=&quot;一、安装Homebrew&quot;&gt;&lt;a href=&quot;#一、安装Homebrew&quot; class=&quot;headerlink&quot; titl
    
    </summary>
    
    
  </entry>
  
</feed>
