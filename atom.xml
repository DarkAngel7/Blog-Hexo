<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dark Angel</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.darkangel7.com/"/>
  <updated>2018-01-28T04:28:06.000Z</updated>
  <id>http://blog.darkangel7.com/</id>
  
  <author>
    <name>Dark Angel</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>贴吧问题及答案</title>
    <link href="http://blog.darkangel7.com/2018/01/25/%E8%B4%B4%E5%90%A7%E9%97%AE%E9%A2%98%E5%8F%8A%E7%AD%94%E6%A1%88/"/>
    <id>http://blog.darkangel7.com/2018/01/25/贴吧问题及答案/</id>
    <published>2018-01-25T02:25:48.000Z</published>
    <updated>2018-01-28T04:28:06.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1月25日-中午1-30分-10W"><a href="#1月25日-中午1-30分-10W" class="headerlink" title="1月25日 中午1:30分 10W"></a>1月25日 中午1:30分 10W</h1><p>1、经典米奇形象中，米奇的鞋子是什么颜色<br>[‘红色’, ‘黄色’, ‘黑色’]<br>正确为：<strong>黄色</strong></p>
<p>2、动画赖以存在的前提是人眼的什么功能<br>[‘拷贝招式’, ‘未来视’, ‘视觉暂留’]<br>正确为：<strong>视觉暂留</strong></p>
<p>3、“五大三粗”中的“三粗”不包括？(吧友：我是初学者<br>[‘腿粗’, ‘脖子粗’, ‘胳膊粗’]<br>正确为：<strong>胳膊粗</strong></p>
<p>4、以下哪一个吧不是关于明星的吧<br>[‘生个女孩吧’, ‘鹿角柱属吧’, ‘摸摸猫头吧’]<br>正确为：<strong>鹿角柱属吧</strong></p>
<p>5、《荷马史诗》中诱拐走美人海伦的是<br>[‘帕里斯王子’, ‘斯巴达王廷达柔斯’, ‘阿喀琉斯’]<br>正确为：<strong>帕里斯王子</strong></p>
<p>6、高尔夫球中的“第19洞”指的是？（来自：阿斯顿将军1<br>[‘第19个球洞’, ‘加赛球’, ‘会所酒馆’]<br>正确为：<strong>会所酒馆</strong></p>
<p>7、《非人哉》漫画中，哪吒直播时使用的网名是什么<br>[‘降龙使者’, ‘藕丝泥霸’, ‘芭比金刚’]<br>正确为：<strong>藕丝泥霸</strong></p>
<p>8、以下不属于“中国十大传世名画”的是<br>[‘捣练图’, ‘汉宫春晓图’, ‘五牛图’]<br>正确为：<strong>捣练图</strong></p>
<h1 id="1月25日-20-30-10W"><a href="#1月25日-20-30-10W" class="headerlink" title="1月25日 20:30 10W"></a>1月25日 20:30 10W</h1><p>1、根据敦煌壁画故事改编的国产动画是<br>[‘《莽荒记》’, ‘《九色鹿》’, ‘《孔雀的火焰》’]<br>正确为：<strong>《九色鹿》</strong></p>
<p>2、《魔卡少女樱》中，小樱使用哪张牌降伏了“影牌”<br>[‘光牌’, ‘暗牌’, ‘风牌’]<br>正确为：<strong>风牌</strong></p>
<p>3、飙车圣地秋名山因几个发夹弯而出名<br>[‘三个四连发夹弯’, ‘四个五连发夹弯’, ‘五个六连发夹弯’]<br>正确为：<strong>四个五连发夹弯</strong></p>
<p>4、动画《灵契》中，端木熙和杨敬华的关系是<br>[‘有利益牵扯的合作伙伴’, ‘相爱的情侣’, ‘出生入死的好兄弟’]<br>正确为：<strong>出生入死的好兄弟</strong></p>
<p>5、《歌剧魅影》改编自哪一类爱情小说<br>[‘巴洛克式爱情小说’, ‘哥特式爱情小说’, ‘洛可可式爱情小说’]<br>正确为：<strong>哥特式爱情小说</strong></p>
<p>6、想在贴吧问一个关于C语言的简单问题，会被大神建议去<br>[‘神奇海螺吧’, ‘程序猴吧’, ‘背锅吧’]<br>正确为：<strong>神奇海螺吧</strong></p>
<p>7、没抓到，蒙吧，建议弄个复活卡</p>
<p>8、中国古代四大名琴及其所有者对应错误的是<br>[‘司马相如，绿绮’, ‘楚庄王，绕梁’, ‘伯牙，焦尾’]<br>正确为：<strong>伯牙，焦尾</strong></p>
<h1 id="1月26日-13-30-10W"><a href="#1月26日-13-30-10W" class="headerlink" title="1月26日 13:30 10W"></a>1月26日 13:30 10W</h1><p>1、以下哪一位是因“红枣枸杞保温杯”再次走红<br>[‘窦唯’, ‘赵明义’, ‘汪峰’]<br>正确为：<strong>赵明义</strong></p>
<p>2、足球明星贝克汉姆的女儿的小名叫<br>[‘小七’, ‘小四月’, ‘小西北’]<br>正确为：<strong>小七</strong></p>
<p>3、“我买几个橘子去。你就在此地，不要走动”出自<br>[‘《荷塘月色》’, ‘《父亲》’, ‘《背影》’]<br>正确为：<strong>《背影》</strong></p>
<p>4、以下哪位足坛球星的绰号是“盛世美颜”<br>[‘贝克汉姆’, ‘科斯塔’, ‘卡卡’]<br>正确为：<strong>科斯塔</strong></p>
<p>5、半程马拉松有多少公里<br>[‘23.69km’, ‘22.195km’, ‘21.0975km’]<br>正确为：<strong>21.0975km</strong></p>
<p>6、结婚十五周年是叫什么婚？<br>[‘水晶婚’, ‘红宝石婚’, ‘蓝宝石婚’]<br>正确为：<strong>水晶婚</strong></p>
<p>7、『猫屎咖啡』又被称作<strong>__</strong>猫咖啡<br>[‘哈瓦那棕（猫）’, ‘麝香（猫）’, ‘暹罗（猫）’]<br>正确为：<strong>麝香（猫）</strong></p>
<p>8、太阳光传播到地球，大约需要多长时间<br>[‘6分钟左右’, ‘10分钟左右’, ‘8分钟左右’]<br>正确为：<strong>8分钟左右</strong></p>
<h1 id="1月27日-13-30-10W"><a href="#1月27日-13-30-10W" class="headerlink" title="1月27日 13:30 10W"></a>1月27日 13:30 10W</h1><p>1、“人生就像一盒巧克力，你永远不知道下一块是什么味道？”出自<br>[‘《当幸福来敲门》’, ‘《雨人》’, ‘《阿甘正传》’]<br>正确为：<strong>《阿甘正传》</strong></p>
<p>2、著名表情包“葛优躺”中，葛优穿的上衣是<br>[‘白底粉花毛衣’, ‘白底粉花T恤’, ‘白底粉花衬衣’]<br>正确为：<strong>白底粉花T恤</strong></p>
<p>3、截止到2018年，贴吧一共建立了多少个吧<br>[‘500多万’, ‘1000多万’, ‘2000多万’]<br>正确为：<strong>2000多万</strong></p>
<p>4、在《绝地求生》游戏中可乘坐人数最多的载具是什么<br>[‘拖拉机’, ‘巴士’, ‘飞机’]<br>正确为：<strong>飞机</strong></p>
<p>5、《西游记》中，盘丝洞里共有几只蜘蛛？（吧友：ningxue511<br>[‘6只’, ‘7只’, ‘8只’]<br>正确为：<strong>7只</strong></p>
<p>6、《蓝精灵之歌》中“在那山的那边海的那边有一群蓝精灵”下一句是<br>[‘他们活泼又调皮’, ‘他们活泼又聪明’, ‘他们调皮又聪明’]<br>正确为：<strong>他们活泼又聪明</strong></p>
<p>7、扑克牌中黑桃Q是谁<br>[‘雅典娜’, ‘圣女贞德’, ‘伊丽莎白女王’]<br>正确为：<strong>雅典娜</strong></p>
<p>8、全球拥有搜索引擎核心技术的国家有多少个<br>[‘3个’, ‘4个’, ‘5个’]<br>正确为：<strong>4个</strong></p>
<h1 id="1月27日-20-30-10W"><a href="#1月27日-20-30-10W" class="headerlink" title="1月27日 20:30 10W"></a>1月27日 20:30 10W</h1><p>1、王者荣耀中，鲁班的智商是<br>[‘150’, ‘250’, ‘500’]<br>正确为：<strong>250</strong></p>
<p>2、以下哪一个不是科比穿过的球衣号码<br>[‘1’, ‘24’, ‘8’]<br>正确为：<strong>1</strong></p>
<p>3、哈士奇的学名是<br>[‘阿拉斯加雪橇犬’, ‘爱斯基摩雪橇犬’, ‘西伯利亚雪橇犬’]<br>正确为：<strong>西伯利亚雪橇犬</strong></p>
<p>4、人气组合TFBOYS是什么时候出道的<br>[‘2012.8.6’, ‘2013.8.6’, ‘2014.8.6’]<br>正确为：<strong>2013.8.6</strong></p>
<p>5、2018年是贴吧建立的多少周年<br>[‘10周年’, ‘15周年’, ‘20周年’]<br>正确为：<strong>15周年</strong></p>
<p>6、鲱鱼罐头是哪一个国家的传统美食？（吧友：山楂不是渣<br>[‘芬兰’, ‘挪威’, ‘瑞典’]<br>正确为：<strong>瑞典</strong></p>
<p>7、“书香门第”的“书香”是指<br>[‘油墨的清香’, ‘芸香的芬芳’, ‘竹简的清香’]<br>正确为：<strong>芸香的芬芳</strong></p>
<p>8、《三国演义》里蜀国五虎上将不包括哪位人物？（吧友：修马斯特）<br>[‘马超’, ‘黄忠’, ‘魏延’]<br>正确为：<strong>魏延</strong></p>
<h1 id="1月28日-13-30-10W"><a href="#1月28日-13-30-10W" class="headerlink" title="1月28日 13:30 10W"></a>1月28日 13:30 10W</h1><p>系统崩了没抓到题</p>
<p>8、“杏林春暖”最初是赞扬哪位名医？（吧友：雅洛1226）<br>[‘孙思邈’, ‘董奉’, ‘李时珍’]<br>正确为：<strong>董奉</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1月25日-中午1-30分-10W&quot;&gt;&lt;a href=&quot;#1月25日-中午1-30分-10W&quot; class=&quot;headerlink&quot; title=&quot;1月25日 中午1:30分 10W&quot;&gt;&lt;/a&gt;1月25日 中午1:30分 10W&lt;/h1&gt;&lt;p&gt;1、经典米奇形象中，
    
    </summary>
    
    
      <category term="问答" scheme="http://blog.darkangel7.com/tags/%E9%97%AE%E7%AD%94/"/>
    
  </entry>
  
  <entry>
    <title>6月</title>
    <link href="http://blog.darkangel7.com/2017/06/19/6%E6%9C%88/"/>
    <id>http://blog.darkangel7.com/2017/06/19/6月/</id>
    <published>2017-06-19T02:02:44.000Z</published>
    <updated>2017-06-19T05:42:34.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/5912049-1c337aa5780ff456.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="你在听吗？"></p>
<p>6月。</p>
<p>你好。</p>
<p>5月。</p>
<p>再见。</p>
<p>想写的文字。</p>
<p>想听的歌曲。</p>
<p>想学的知识。</p>
<p>想流浪的心。</p>
<p>思绪凌乱。</p>
<p>像迷雾中的自己。</p>
<p>模糊不清。</p>
<p>想做一个梦。</p>
<p>等到醒来时。</p>
<p>学会了歌唱。</p>
<p>精通了Swift。</p>
<p>熟练了English。</p>
<p>看过了喜欢的电影。</p>
<p>完成了所有想做的事情。</p>
<p>时间。</p>
<p>可不可以再慢一点。</p>
<p>让我可以变成。</p>
<p>我想要的自己。</p>
<p>疯狂地喜欢上了一首歌。</p>
<p><a href="http://music.163.com/#/m/song?id=560079" target="_blank" rel="external">あなたに出会わなければ~夏雪冬花~</a></p>
<p>单曲循环。</p>
<p>内心。</p>
<p>波涛汹涌。</p>
<p>然后归于平静。</p>
<p>Continue To Work Hard.</p>
<p>There’s No Reason.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/5912049-1c337aa5780ff456.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; 
    
    </summary>
    
    
      <category term="随笔" scheme="http://blog.darkangel7.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>如何用最快速度撸个最简单的markdown编辑器</title>
    <link href="http://blog.darkangel7.com/2017/05/16/%E5%A6%82%E4%BD%95%E7%94%A8%E6%9C%80%E5%BF%AB%E9%80%9F%E5%BA%A6%E6%92%B8%E4%B8%AA%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84markdown%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    <id>http://blog.darkangel7.com/2017/05/16/如何用最快速度撸个最简单的markdown编辑器/</id>
    <published>2017-05-16T07:29:38.000Z</published>
    <updated>2017-05-18T12:10:15.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1ffprjqeqhbj313k0iwgrw.jpg" alt="44281095-7821-49F2-9D89-82460D6263DB"></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>相信不少小伙伴看过笔者前面发的《<strong>iOS中UIWebView与WKWebView、JavaScript与OC交互、Cookie管理看我就够</strong>》系列了吧，文章中笔者介绍过很多关于Native与JS交互的使用。今天呢，笔者来用最快速度撸个最简单的<code>Markdown</code>编辑器。</p>
<p>其实iOS原生Markdown编辑器的实现方式有很多，Github上面也有一些比较厉害的库，本着不重复造轮子的原则，<code>markdown</code>纯文本转<code>html</code>字符串这部分就不自己实现了，其他部分笔者用<code>JavaScriptCore</code>结合JS和OC（Swift其实也一样），来实现一个简单的<code>Markdown</code>编辑器。</p>
<p>这篇文章不是为了教大家如何开发<code>Markdown</code>编辑器，而是为广大iOS开发者打开一个新的思路，我们能使用的不只是iOS开源库，有了<code>JavaScriptCore</code>，即便脱离开<code>WebView</code>，我们也是可以使用<code>JavaScript</code>开源库的~😊</p>
<p>下面为小伙伴介绍下具体的实现细节，<a href="https://github.com/DarkAngel7/DAMarkdownEditor" target="_blank" rel="external">源码已上传Github</a>，希望小伙伴们喜欢的给个Star。</p>
<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>如何在iOS上实现一个<code>markdown</code>编辑器呢？让我们来分析下。</p>
<ul>
<li>首先，既然是编辑器，那应该会用到<code>UITextView</code>控件。</li>
<li>其次，用户是在<code>UITextView</code>上输入的文本，那作为一个编辑器，应该会有预览功能，点击预览则可以看到html页面。</li>
<li>再次，点击预览实现的是<code>markdown</code>纯文本转<code>html</code>字符串，怎么实现呢？</li>
<li>最后，考虑给<code>UITextView</code>的<code>inputAccessoryView</code>添加一些用户常用的按钮，比如“#、link、img”等，便于用户操作。</li>
</ul>
<h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><p>上面提到的是笔者在做一个<code>markdown</code>编辑器时的思路，其实这个很重要，小伙伴们在遇到问题和处理问题时，也应该先整体思考，分析一下，然后得出实现方案，最后再去落实，养成一个好的习惯。</p>
<p>笔者的方案如下：</p>
<ul>
<li>页面结构：一个<code>UIViewController</code>上面放一个<code>UITextView</code>，顶部<code>NavigationBar</code>上面放个<strong>预览</strong>按钮和<strong>保存</strong>按钮。点击预览，查看编辑好的预览页；点击保存，保存当前文章到沙盒目录（真的业务需求的话可能是发送）。</li>
<li><code>UITextView</code>的<code>markdown</code>纯文本转<code>html</code>字符串，<a href="https://github.com/showdownjs/showdown" target="_blank" rel="external">通过成熟的<code>js</code>来实现</a>，至于交互，使用<code>JavaScriptCore</code>（不重复造轮子，就不自己写正则处理了）。</li>
<li>预览页直接用<code>WebView</code>加载<code>html</code>字符串即可。</li>
</ul>
<h1 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h1><h2 id="搭建UI"><a href="#搭建UI" class="headerlink" title="搭建UI"></a>搭建UI</h2><p>这个So easy，分分钟~如下图</p>
<p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1ffpljo5k99j31kw0wlh03.jpg" alt="63DAF661-7D46-42D2-BDAC-935FDEA66532"></p>
<p>上面的图足够明确了吧~</p>
<p>编辑页中持有一个<code>JSContext</code>对象，同时持有一个<code>inputBar</code>，一个<code>TextView</code>（正文），一个<code>UITextField</code>（标题）。</p>
<p>预览页中是一个<code>UIWebView</code>（也可以是<code>WKWebView</code>）。</p>
<h2 id="逻辑处理"><a href="#逻辑处理" class="headerlink" title="逻辑处理"></a>逻辑处理</h2><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p><code>EditViewController</code>中首先实现初始化方法。</p>
<pre><code class="objective-c">- (void)initialize
{
    self.textView.textContainerInset = UIEdgeInsetsMake(10, 5, 10, 5);
    //错误回调
    [self.jsContext setExceptionHandler:^(JSContext *context, JSValue *exception){
        NSLog(@&quot;%@&quot;, exception.toString);
    }];

    //markdown -&gt; html  js参考 https://github.com/showdownjs/showdown
    static NSString *js;
    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{
        js = [NSString stringWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@&quot;showdown&quot; ofType:@&quot;js&quot;] encoding:NSUTF8StringEncoding error:nil];
    });
    //加载js
    [self.jsContext evaluateScript:js];

    //注入function  markdown -&gt; html，使用时，可以通过 convert(&#39;xxx&#39;); 调用
    NSString *jsFunction = @&quot;\
                            function convert(md) { \
                                return (new showdown.Converter()).makeHtml(md);\
                            }&quot;;
    [self.jsContext evaluateScript:jsFunction];
}
</code></pre>
<p>上面的代码中，我们提前给<code>jsContext</code>注入<code>showdown.js</code>文件，然后可以使用<code>(new showdown.Converter()).makeHtml(md);</code>的方法来将<code>markdown</code>字符串转换为<code>html</code>字符串。那么我们也提前注入了一个方法<code>convert</code> <code>function</code>来供我们自己调用。</p>
<h3 id="添加工具栏"><a href="#添加工具栏" class="headerlink" title="添加工具栏"></a>添加工具栏</h3><p>有一些字符，比如”*、-“等都是很常用的，这里我们添加一个工具栏，便于用户快捷操作。我们在初始化方法<code>initialize</code>中添加如下的方法。</p>
<pre><code class="objective-c">self.textView.inputAccessoryView = self.inputBar;
</code></pre>
<p>当用户点击inputBar上的按钮时，触发事件：</p>
<pre><code class="objective-c">/**
 点击了toolBar上面的item

 @param item item
 */
- (IBAction)inputBarItemClicked:(UIBarButtonItem *)item
{
    NSString *title = item.title;
    //插入的文本内容
    NSString *insertText;
    //插入文本内容后，移动光标到指定位置
    NSRange selectedRange = self.textView.selectedRange;
    if ([title isEqualToString:@&quot;link&quot;]) {
        insertText = @&quot;[]()&quot;;
        selectedRange.location += 1;    //移动到 [ 后面
    } else if ([title isEqualToString:@&quot;img&quot;]) {
        insertText = @&quot;![]()&quot;;
        selectedRange.location += 4;    //移动到 ( 后面
    } else {
        insertText = title;
        selectedRange.location += title.length; //移动到插入文本的最后
    }
    //插入文本
    [self.textView insertText:insertText];
    //移动光标
    self.textView.selectedRange = selectedRange;
}
</code></pre>
<p>效果如下</p>
<p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1ffpqjn9wngg30aa0iahdt.gif" alt="工具栏输入"></p>
<h3 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h3><p>此时用户可以愉悦地编辑内容，当用户编辑完成时，可以点击预览。预览的方法实现：</p>
<pre><code class="objective-c">/**
 预览

 @param sender item
 */
- (IBAction)preview:(id)sender
{
    //标题不能为空
    if (!self.titleTextField.text.length) {
        [self showMessage:@&quot;请先填写文章标题&quot;];
        return;
    }
    //跳转到预览页
    [self performSegueWithIdentifier:kShowPreviewSegueId sender:self];
}

#pragma mark - Setters and Getters

- (NSString *)htmlString
{
    //markdown -&gt; html
    JSValue *jsFunctionValue = self.jsContext[@&quot;convert&quot;];
    JSValue *htmlValue = [jsFunctionValue callWithArguments:@[self.textView.text]];
    return [NSString stringWithFormat:@&quot;\
            &lt;html&gt;\
                &lt;head&gt;\
                    &lt;title&gt;%@&lt;/title&gt;\
                &lt;/head&gt;\
                &lt;body&gt;\
                    %@\
                &lt;/body&gt;\
            &lt;/html&gt;\
            &quot;, self.titleTextField.text, htmlValue.toString];
}

#pragma mark - Navigation

- (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender
{
    //跳转到预览页
    if ([segue.identifier isEqualToString:kShowPreviewSegueId]) {
        PreviewViewController *vc = segue.destinationViewController;
        vc.htmlString = [self htmlString];
        vc.title = self.titleTextField.text;
    }
}
</code></pre>
<p>点击预览，跳转到<code>PreviewViewController</code>页面，同时传递<code>htmlString</code>。这里如何获取<code>htmlString</code>呢？之前我们在<code>initialize</code>方法里，提前注入了名为<code>convert</code>的方法，现在我们来调用它</p>
<pre><code class="objective-c">JSValue *jsFunctionValue = self.jsContext[@&quot;convert&quot;];
JSValue *htmlValue = [jsFunctionValue callWithArguments:@[self.textView.text]];
</code></pre>
<p>那我们很容易获取到了<code>markdown</code>文本转换成<code>html</code>的字符串了，然后我们给这个字符串完善下，添加上<code>html</code>标签、<code>head</code>标签以及页面的<code>title</code>，然后传递给预览页，直接展示就OK了。</p>
<p>效果如下图</p>
<p><img src="http://ww2.sinaimg.cn/large/006tNc79ly1ffpqvmwpzfg30ac0ir49m.gif" alt="点击预览"></p>
<h3 id="保存"><a href="#保存" class="headerlink" title="保存"></a>保存</h3><p>其实保存，这里只是简单实现，保存到沙盒。实际业务需求，很可能是一个发送按钮，上传到服务器，或者是分享到其他的App。这里简单介绍下保存到沙盒。下面上代码</p>
<pre><code class="objective-c">/**
 保存到沙盒目录

 @param sender item
 */
- (IBAction)save:(id)sender
{
    //标题不能为空
    if (!self.titleTextField.text.length) {
        [self showMessage:@&quot;请先填写文章标题&quot;];
        return;
    }
    NSData *data = [self.textView.text dataUsingEncoding:NSUTF8StringEncoding];
    NSString *documentPath = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES).firstObject;
    NSString *filePath = [documentPath stringByAppendingPathComponent:[NSString stringWithFormat:@&quot;%@.md&quot;, self.titleTextField.text]];
    //写入文件
    [data writeToFile:filePath atomically:YES];
    NSLog(@&quot;md成功保存，地址%@&quot;, filePath);
    [self showMessage:@&quot;保存成功&quot;];
}
</code></pre>
<p>保存的时候，直接保存源码到本地，就好了，文件命名为<code>标题.md</code>。</p>
<p>当我点击保存时，保存到本地，同时输出</p>
<pre><code>DAMarkdownEditor[9717:192504] md成功保存，地址/Users/DarkAngel/Library/Developer/CoreSimulator/Devices/CF831783-E4A6-4EC2-AB99-E04304331C3A/data/Containers/Data/Application/A7837233-9EC3-4E4C-94CB-252329746176/Documents/A test title.md
</code></pre><p>我们用Safari，Cmd+Shift+G，打开上面的地址可以看到</p>
<p><img src="http://ww3.sinaimg.cn/large/006tNc79ly1ffpqsm8tfjj316s0o8jyj.jpg" alt="FC42EBA3-1996-4266-A7BC-9B2363F40E04"></p>
<p>打开这个文件，可以查看下，源码就是我们输入的内容。</p>
<p>其实到这里，我们已经完成一个简单的<code>Markdown</code>编辑器。但是小伙伴们可能会说，预览的<code>html</code>太丑了，中间的代码块都没有高亮。那如何解决呢？</p>
<h2 id="美化样式"><a href="#美化样式" class="headerlink" title="美化样式"></a>美化样式</h2><p>如果你拥有一点点前端知识，你会立刻想到，少了一个好看的<code>css</code>样式。我们可以通过给<code>html</code>添加<code>css</code>，来使页面看起来更好看。</p>
<p>下面我们在<code>- (NSString *)htmlString</code>方法中，给html添加css，这里我本地添加了一个<code>css</code>文件，直接读取并拼接到<code>head</code>标签中</p>
<pre><code class="objective-c">- (NSString *)htmlString
{
    //markdown -&gt; html
    JSValue *jsFunctionValue = self.jsContext[@&quot;convert&quot;];
    JSValue *htmlValue = [jsFunctionValue callWithArguments:@[self.textView.text]];
    //加载css样式
    static NSString *css;
    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{
        css = [NSString stringWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@&quot;markdown&quot; ofType:@&quot;css&quot;] encoding:NSUTF8StringEncoding error:nil];
    });
    return [NSString stringWithFormat:@&quot;\
            &lt;html&gt;\
                &lt;head&gt;\
                    &lt;title&gt;%@&lt;/title&gt;\
                    &lt;style&gt;%@&lt;/style&gt;\
                &lt;/head&gt;\
                &lt;body&gt;\
                    %@\
                &lt;/body&gt;\
            &lt;/html&gt;\
            &quot;, self.titleTextField.text, css, htmlValue.toString];
}
</code></pre>
<p>好啦，让我们再点击预览一下</p>
<p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1ffpr28i2xlg30ac0ir7f7.gif" alt="添加css后，点击预览"></p>
<p>这下好看多了，如果小伙伴们想要自定义样式，只需要修改css文件就OK啦，当然Github上有很多好看的样式哦~可以找找看，也可以自己修改下css。</p>
<p>至此，我们的<code>Markdown</code>编辑器就完成了，<code>EditViewController</code>一共181行，<code>PreviewViewController</code>一共38行，加上一个简单的<code>Storyboard</code>，我们的编辑器非常清爽。后续，再可以优化下页面的UI、InputBar中多添加一些快捷按钮，优化下UE，我们就可以上传AppStore啦~</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>上面我们用很少的代码，很少的时间完成了一个简单的<code>Markdown</code>编辑器，又一次证明了<code>JavaScriptCore</code>的强大，同时也证明了前端如此火热的今天，Native开发依然是王道。</p>
<p><code>Github</code>前十的开源项目中，有<strong>六</strong>款是基于<code>JavaScript</code>语言的。可能有些小伙伴作为一个Native端开发，会很方，很多小伙伴开始学习前端，学习js。当然，学习新的东西本就无可厚非。但我相信，被动学习的不在少数。</p>
<p>那么，我们可不可以利用它，结合Native打造更好的App呢？答案是：一定可以。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ww2.sinaimg.cn/large/006tNc79ly1ffprjqeqhbj313k0iwgrw.jpg&quot; alt=&quot;44281095-7821-49F2-9D89-82460D6263DB&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;
    
    </summary>
    
    
      <category term="iOS技术分享" scheme="http://blog.darkangel7.com/tags/iOS%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>iOS中UIWebView与WKWebView、JavaScript与OC交互、Cookie管理看我就够（下）</title>
    <link href="http://blog.darkangel7.com/2017/05/11/iOS%E4%B8%ADUIWebView%E4%B8%8EWKWebView%E3%80%81JavaScript%E4%B8%8EOC%E4%BA%A4%E4%BA%92%E3%80%81Cookie%E7%AE%A1%E7%90%86%E7%9C%8B%E6%88%91%E5%B0%B1%E5%A4%9F%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>http://blog.darkangel7.com/2017/05/11/iOS中UIWebView与WKWebView、JavaScript与OC交互、Cookie管理看我就够（下）/</id>
    <published>2017-05-11T06:25:40.000Z</published>
    <updated>2017-05-12T12:00:03.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1fff1sa06wrj30sg0iwwi9.jpg" alt=""></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在前面的文章中，我们介绍了<code>UIWebView</code>、<code>WKWebView</code>一些使用，与JS的交互和一些坑，相信看过的小伙伴们，已经大概清楚了吧，如果有问题，欢迎提问。</p>
<p>本文是本系列文章的最后一篇，主要为小伙伴们分享下<strong>Safari调试</strong>、<strong>与前端的配合</strong>以及<strong>实际应用中一些需求的实现等</strong>：</p>
<ul>
<li><a href="http://blog.darkangel7.com/2016/09/01/iOS中UIWebView与WKWebView、JavaScript与OC交互、Cookie管理看我就够（上）/">iOS中UIWebView与WKWebView、JavaScript与OC交互、Cookie管理看我就够（上）</a></li>
<li><a href="http://blog.darkangel7.com/2017/05/10/iOS中UIWebView与WKWebView、JavaScript与OC交互、Cookie管理看我就够（中）/">iOS中UIWebView与WKWebView、JavaScript与OC交互、Cookie管理看我就够（中）</a></li>
<li>iOS中UIWebView与WKWebView、JavaScript与OC交互、Cookie管理看我就够（下）</li>
</ul>
<p>关于文中提到的一些内容，这里我准备了个<a href="https://github.com/DarkAngel7/Demos-WebViewDemo" target="_blank" rel="external">Demo</a>，有需要的小伙伴可以下载。</p>
<h1 id="Safari调试"><a href="#Safari调试" class="headerlink" title="Safari调试"></a>Safari调试</h1><p>在前面的文章中，查看网页的Cookie，其实已经用到了Safari调试。笔者觉得Safari调试功能真的很有用，通过它可以轻松定位问题的所在。也因此，公司中App一旦有问题出现，不管是客户端的问题，还是前端的问题，找问题的重任都落到了笔者的身上呢。这一度是一个困扰😪。想象一下，h5页面的一个bug，App端帮忙快速定位，并且告知h5相关开发人员该如何修复，是多么伟大的一件事情。</p>
<p>下面来简单讲讲怎么用Safari调试。</p>
<h2 id="开启Safari开发菜单"><a href="#开启Safari开发菜单" class="headerlink" title="开启Safari开发菜单"></a>开启Safari开发菜单</h2><p>在Mac的Safari偏好设置中，开启开发菜单。具体步骤为：<strong>Safari -&gt; 偏好设置… -&gt; 高级 -&gt; 勾选在菜单栏显示“开发”菜单</strong>。</p>
<p><img src="http://ww3.sinaimg.cn/large/006tNbRwly1ffhhv5gt96j31as0w0dus.jpg" alt="B49417E2-433A-4650-8BF7-AF941E8B6670"></p>
<h2 id="iPhone开启Web检查器"><a href="#iPhone开启Web检查器" class="headerlink" title="iPhone开启Web检查器"></a>iPhone开启Web检查器</h2><p>具体步骤为：<strong>设置 -&gt; Safari -&gt; 高级 -&gt; Web 检查器</strong>。</p>
<p><img src="http://ww1.sinaimg.cn/large/006tNbRwly1ffhi80ocj7j31kw0yugzs.jpg" alt="8AECBA1E-FF4A-4D7F-8D74-E224035EA418"></p>
<h2 id="运行App"><a href="#运行App" class="headerlink" title="运行App"></a>运行App</h2><p>打开项目，Cmd + R 运行，打开想调试的Web页面。</p>
<p><img src="http://ww4.sinaimg.cn/large/006tNbRwly1ffhiit6h9oj30ku12agvo.jpg" width="30%"></p>
<h2 id="调试对应的页面"><a href="#调试对应的页面" class="headerlink" title="调试对应的页面"></a>调试对应的页面</h2><p>打开<strong>Safari -&gt; 开发 -&gt; 设备 -&gt; URL。</strong></p>
<p><img src="http://ww1.sinaimg.cn/large/006tNbRwly1ffhiovms7ej31kw0w2kjl.jpg" alt="5B046813-A658-45B4-9ED2-A1480BA5EE99"></p>
<p>选中的页面会变成蓝色，点击然后打开了如下的界面。</p>
<p><img src="http://ww2.sinaimg.cn/large/006tNbRwly1ffhiqs8pnnj31jk104wx4.jpg" alt="693A55F1-ADD7-4D84-B8D1-4B669D3CF561"></p>
<p>这个页面就很像<code>Windows</code> 平台<code>Chrome</code>的<code>F12</code>。可以打断点：</p>
<p><img src="http://ww1.sinaimg.cn/large/006tNbRwly1ffhjiak74qj31jk1044df.jpg" alt="7A23FD0A-40A9-48D9-B53E-B721F455C1D5"></p>
<p>查看断点</p>
<p><img src="http://ww2.sinaimg.cn/large/006tNbRwly1ffhjk62o3bj31jk104gxb.jpg" alt="E2ABC34F-D227-4A71-AC0C-7C3AC9B730F9"></p>
<p>查看Cookie</p>
<p><img src="http://ww3.sinaimg.cn/large/006tNbRwly1ffhjl2y69zj31jk104n6a.jpg" alt="0E90DD8A-B178-4EF3-BF8C-F90C6E3A278F"></p>
<p>打印Cookie或者元素<br><img src="http://ww3.sinaimg.cn/large/006tNbRwly1ffhjmbt52kj31jk104tgk.jpg" alt="834DB431-32B4-44EC-BED2-05E3D124FFBA"></p>
<p>比如我在这里Alert页面的title，输入 <code>alert(document.title);</code>，你会在模拟器中看到弹窗</p>
<p><img src="http://ww3.sinaimg.cn/large/006tNbRwly1ffhjo6usmvj31j40zkart.jpg" alt="550D157D-0F2E-41E1-B5E3-85928FFCBCAC"></p>
<p>整体十分有用，操作的体验跟<code>Xcode</code>很像，小伙伴们自行探索。</p>
<h1 id="与前端配合解决bug"><a href="#与前端配合解决bug" class="headerlink" title="与前端配合解决bug"></a>与前端配合解决bug</h1><p>前端有一些问题，在浏览器中是无法调试的，很可能只在App内的浏览器中才会复现。这个时候你可以期待前端开发人员会使用<code>Xcode</code>和<code>Safari</code>调试来解决bug，或者靠自己。毕竟大家的目标一致，给用户提供一个更好的App，解决所有已知问题。</p>
<p>这里我举个例子，运用Safari调试来解决一个前端的bug。</p>
<p>比如新做的h5页面中，有一个分享按钮，点击调用原生的分享，但是发现，点击之后没有反应了，什么问题呢？是Native端实现有问题，还是前端写的有问题呢？如图</p>
<p><img src="http://ww1.sinaimg.cn/large/006tNbRwly1ffhjxcad71j30ko0gy75u.jpg" width="30%"></p>
<p>我们来帮忙看下吧，打开Safari <strong>Web 检查器</strong>，定位到资源，并且在share方法中添加断点，如图</p>
<p><img src="http://ww1.sinaimg.cn/large/006tNbRwly1ffhk1xng71j31jk1044ag.jpg" alt="76A2E384-0A07-4DA0-8D5C-61DB988C4AE0"></p>
<p>会发现，并没有断住，而是页面直接报错了，仔细查看错误描述，share方法里多了一个<code>“/”</code>，因此报错了。当我点击分享按钮时<img src="http://ww3.sinaimg.cn/large/006tNbRwly1ffhk3hpu55j312q036aaw.jpg" alt="6792A001-7ACC-4336-BF1E-6A03983C74E1">会发现，提示找不到变量<code>share</code>。这里我需要说明一下：</p>
<blockquote>
<p>当js中报错的时候，报错位置所在的函数以及报错位置之后的代码，都不会执行，所以我点击分享时，提示的是找不到方法，因为js的语法不对，报错了，这里解析不出来，所以也就没有了<code>share</code>、<code>testAddMethod</code>和之后的函数。</p>
<p>那么当我点击分享下面的按钮是，调用share下面定义的方法也就会提示找不到对应的函数了。<img src="http://ww2.sinaimg.cn/large/006tNbRwly1ffhk6n0oozj30ko02mwen.jpg" width="50%"></p>
<p><img src="http://ww2.sinaimg.cn/large/006tNbRwly1ffhk88lyzkj311i03o76a.jpg" alt=""></p>
</blockquote>
<p>至此，问题找到了，只要告之前端开发人员即可，让他修复即可。</p>
<p>实际遇到的问题可能要复杂的多，可以通过断点，以及控制台打印一些js变量的值，DOM操作来寻找问题，解决问题。希望可以帮助到小伙伴们。</p>
<h1 id="实际应用中一些需求的实现"><a href="#实际应用中一些需求的实现" class="headerlink" title="实际应用中一些需求的实现"></a>实际应用中一些需求的实现</h1><h2 id="自定义浏览器UserAgent"><a href="#自定义浏览器UserAgent" class="headerlink" title="自定义浏览器UserAgent"></a>自定义浏览器UserAgent</h2><p>这个其实在App开发中，比较重要。比如常见的微信、支付宝App等，都有自己的<code>UserAgent</code>，而UA最常用来判断在哪个App内，一般App的下载页中只有一个按钮”点击下载”，当用户点击该按钮时，在微信中则跳转到应用宝，否则跳转到AppStore。那么如何区分在哪个App中呢？就是js判断UA。</p>
<pre><code class="javascript">//js中判断
if (navigator.userAgent.indexOf(&quot;MicroMessenger&quot;) !== -1) {
   //在微信中
}
</code></pre>
<p>关于自定义UA，这个<code>UIWebView</code>不提供Api，而<code>WKWebView</code>提供Api，前文中也说明过，就是调用<code>customUserAgent</code>属性。</p>
<pre><code class="objective-c">self.webView.customUserAgent = @&quot;WebViewDemo/1.0.0&quot;;    //自定义UA，只支持WKWebView
</code></pre>
<p>而有没有其他的方法实现自定义浏览器UserAgent呢？有。</p>
<pre><code class="objective-c">//最好在AppDelegate中就提前设置
@implementation AppDelegate


- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
    // Override point for customization after application launch.

    //设置自定义UserAgent
    [self setCustomUserAgent];
    return YES;
}

- (void)setCustomUserAgent
{
    //get the original user-agent of webview
    UIWebView *webView = [[UIWebView alloc] initWithFrame:CGRectZero];
    NSString *oldAgent = [webView stringByEvaluatingJavaScriptFromString:@&quot;navigator.userAgent&quot;];
    //add my info to the new agent
    NSString *newAgent = [oldAgent stringByAppendingFormat:@&quot; %@&quot;, @&quot;WebViewDemo/1.0.0&quot;];
    //regist the new agent
    NSDictionary *dictionnary = [[NSDictionary alloc] initWithObjectsAndKeys:newAgent, @&quot;UserAgent&quot;, newAgent, @&quot;User-Agent&quot;, nil];
    [[NSUserDefaults standardUserDefaults] registerDefaults:dictionnary];
}

@end
</code></pre>
<p>上面的代码，展示了在原有<code>UserAgent</code>的基础上，添加一些自定义的内容。</p>
<p><img src="http://ww3.sinaimg.cn/large/006tNbRwly1ffhl5fhh31j31jq0b8tca.jpg" alt="6F9FAD1A-DBD6-4FA6-89CC-28921D57646E"></p>
<p>可以看到原本的UA后面已经有我们添加的内容了<code>WebViewDemo/1.0.0</code>。</p>
<p>这里需要说明的是：</p>
<blockquote>
<ol>
<li>通过<code>NSUserDefaults</code>设置自定义UserAgent，可以同时作用于<code>UIWebView</code>和<code>WKWebView</code>。</li>
<li><code>WKWebView</code>的<code>customUserAgent</code>属性，优先级高于<code>NSUserDefaults</code>，当同时设置时，显示<code>customUserAgent</code>的值。如上图。</li>
</ol>
</blockquote>
<h2 id="Native与H5共享登录状态"><a href="#Native与H5共享登录状态" class="headerlink" title="Native与H5共享登录状态"></a>Native与H5共享登录状态</h2><p>这个需求在前面的文章中针对<code>WKWebView</code>和<code>UIWebView</code>分别单独做过介绍。维持登录状态，依赖的是相同的<code>Cookie</code>。</p>
<p><code>UIWebView</code>实现起来基本不需要做额外的操作，只要保证<code>sharedHTTPCookieStorage</code>中的<code>Cookie</code>是没问题的。</p>
<p><code>WKWebView</code>实现起来相对麻烦，有很多坑，这里不再详细描述，小伙伴们可以看下上篇文章中<strong>Cookie管理</strong>一节。</p>
<h2 id="Native预览H5页面中的image"><a href="#Native预览H5页面中的image" class="headerlink" title="Native预览H5页面中的image"></a>Native预览H5页面中的image</h2><p>这个需求，应该是一个比较常见的需求。在微信中浏览网页时，看到喜欢的图片，你会点击图片查看大图，然后长按图片保存。</p>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>如果你的项目中有这样的需求的话，可能你需要做如下的分析。</p>
<blockquote>
<ol>
<li>如果想在Native预览H5中的image，最需要的是什么？是图片的链接。如果能有缩略图更好了。</li>
<li>只要获取了链接，就可以跳转到一个<code>ViewController</code>中，预览图片，后续长按保存自然水到渠成。</li>
<li>那应该如何获取图片的链接呢？通过JS -&gt; OC 传递图片url。</li>
</ol>
</blockquote>
<p>这里，究竟如何实现获取图片链接，取决于你用的是<code>UIWebView</code>还是<code>WKWebView</code>。</p>
<h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3><blockquote>
<p>当页面<strong>加载完成后</strong>，给html页面中所有<strong>无默认点击事件</strong>的<code>&lt;img&gt;</code><strong>添加点击事件</strong>，当用户点击时，拿到所有参数。</p>
<p>（其实这不是最好的方案，最好的解决方案是，跟前端约定一下，哪些图片需要预览，哪些img标签的id统一，或者有个特定的属性，这样客户端可以根据id找到这些img标签）</p>
</blockquote>
<p>首先，Html中有个img标签</p>
<pre><code class="html">&lt;img src=&quot;http://cc.cocimg.com/api/uploads/170425/b2d6e7ea5b3172e6c39120b7bfd662fb.jpg&quot;&gt;
</code></pre>
<p>我先写好一个<code>ImgAddClickEvent.js</code>文件，来实现给所有无默认点击事件的<code>&lt;img&gt;</code>添加点击事件。</p>
<pre><code class="javascript">//获取所有img标签
var imgs = document.getElementsByTagName(&quot;img&quot;);
//获取所有的imgUrl
var imgUrls = new Array();
var x = 0;
var y = 0;
var width = 0;
var height = 0;
for (var i = 0; i &lt; imgs.length; i++) {
    var img = imgs[i];
    //如果图片链接存在
    if (img.src || img.getAttribute(&#39;data-src&#39;)) {
        //添加到图片链接数组中
        imgUrls.push(img.src || img.getAttribute(&#39;data-src&#39;));
        //如果图片没有默认的onclick事件，且父元素不是a标签，则添加onclick事件，当用户点击时，把图片链接回传给Native
        if (!img.onclick &amp;&amp; img.parentElement.tagName !== &quot;A&quot;) {
            //给图片添加下标的属性
            img.index = i; //记录下标
            //添加点击事件，并且回传选中的图片链接、下标、屏幕上的位置、全部的图片数组等
            img.onclick = function() {
                x = this.getBoundingClientRect().left;
                y = this.getBoundingClientRect().top;
                x = x + document.documentElement.scrollLeft;
                y = y + document.documentElement.scrollTop;
                width = this.width;
                height = this.height;
                var imgInfo = {
                    imgUrl: this.src || this.getAttribute(&#39;data-src&#39;),
                    x: x,
                    y: y,
                    width: width,
                    height: height,
                    index: this.index,
                    imgUrls: imgUrls
                };
                //UIWebView使用
                h5ImageDidClick(imgInfo);
            }
        }
    }
}

function h5ImageDidClick(info) {
    //WKWebView使用
    window.webkit.messageHandlers.imageDidClick.postMessage(info);
}
</code></pre>
<p>下面分别介绍<code>UIWebView</code>和<code>WKWebView</code>如何实现。</p>
<h3 id="UIWebView实现"><a href="#UIWebView实现" class="headerlink" title="UIWebView实现"></a>UIWebView实现</h3><p><code>UIWebView</code>直接使用<code>JavaScriptCore</code>给<code>&lt;img&gt;</code>添加<code>onclick</code>方法为OC的实现即可。</p>
<pre><code class="objective-c">- (void)webViewDidFinishLoad:(UIWebView *)webView {
    [self convertJSFunctionsToOCMethods];
}

- (void)convertJSFunctionsToOCMethods {
    //获取该UIWebview的javascript上下文
    //self持有jsContext
    //@property (nonatomic, strong) JSContext *jsContext;
    self.jsContext = [self.webView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;];

      //先注入给图片添加点击事件的js
    //防止频繁IO操作，造成性能影响
    static NSString *jsSource;
    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{
        jsSource = [NSString stringWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@&quot;ImgAddClickEvent&quot; ofType:@&quot;js&quot;] encoding:NSUTF8StringEncoding error:nil];
    });
    [self.jsContext evaluateScript:jsSource];
    //替换回调方法
    self.jsContext[@&quot;h5ImageDidClick&quot;] = ^(NSDictionary *imgInfo) {
        NSLog(@&quot;UIWebView点击了html上的图片，信息是：%@&quot;, imgInfo);
    };
}
</code></pre>
<h3 id="WKWebView实现"><a href="#WKWebView实现" class="headerlink" title="WKWebView实现"></a>WKWebView实现</h3><p>而<code>WKWebView</code>实现，需要使用<code>WKUserScript</code>和<code>scriptMessageHandler</code>，下面简单介绍下，详细实现，见Demo。</p>
<p><code>WKWebView</code>的<code>UIViewController</code>中实现如下</p>
<pre><code class="objective-c">/**
 页面中的所有img标签添加点击事件
 */
- (void)imgAddClickEvent {
    //防止频繁IO操作，造成性能影响
    static NSString *jsSource;
    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{
        jsSource = [NSString stringWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@&quot;ImgAddClickEvent&quot; ofType:@&quot;js&quot;] encoding:NSUTF8StringEncoding error:nil];
    });
    //添加自定义的脚本
    WKUserScript *js = [[WKUserScript alloc] initWithSource:jsSource injectionTime:WKUserScriptInjectionTimeAtDocumentEnd forMainFrameOnly:NO];
    [self.webView.configuration.userContentController addUserScript:js];
    //注册回调
    [self.webView.configuration.userContentController addScriptMessageHandler:self name:@&quot;imageDidClick&quot;];
}

- (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message {
    if ([message.name isEqualToString:@&quot;imageDidClick&quot;]) {
        //点击了html上的图片
        NSLog(@&quot;点击了html上的图片，参数为%@&quot;, message.body);
    }
}
</code></pre>
<p>当我点击这个标签时，因为我添加了onclick事件，在OC端我会接收到回调。因此打印出log</p>
<p><img src="http://ww3.sinaimg.cn/large/006tNbRwly1ffhp6sn0xnj318k0ie7eq.jpg" alt="0B6DFD21-5707-419E-9918-5AA6792D0CAD"></p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><blockquote>
<p> 上面无论是<code>UIWebView</code>还是<code>WKWebView</code>，参数中的x，y是不包含自定义scrollView的contentInset的，如果要获取图片在手机屏幕上的位置：</p>
<pre><code class="objective-c"> x = x + self.webView.scrollView.contentInset.left;
 y = y + self.webView.scrollView.contentInset.top;
</code></pre>
</blockquote>
<p>拿到了这些信息，想必，你可以实现一个十分完美的<strong>图片预览效果</strong>了。</p>
<h2 id="Native加载并缓存H5页面中的img"><a href="#Native加载并缓存H5页面中的img" class="headerlink" title="Native加载并缓存H5页面中的img"></a>Native加载并缓存H5页面中的img</h2><p>因为页面中的img标签加载图片的网络请求是由<code>WebView</code>管理的，所以要想Native接管图片的下载，只有2条路：</p>
<blockquote>
<ol>
<li>在页面加载前，把页面中img标签的src换成一张native的占位图或者””，并且把img.src传递到native，在native下载图片或者读取缓存完毕后，再把相应的img标签的src设置成本地的，如img.src =”native cache url”。整体交互是JS-&gt;Native, Native -&gt; JS。</li>
<li><code>NSURLProtocol</code>拦截<code>WebView</code>的所有图片请求，交由我们自己管理。</li>
</ol>
</blockquote>
<p>比较有可行性的是方法2。但也只限于<code>UIWebView</code>。<code>WKWebView</code>上篇文中说过，虽然有私有Api，但是笔者不推荐使用。</p>
<p>先说下，为何方法1不可行。首先，页面加载前，是在什么时候呢？如果h5不做修改，全部交由Native端处理，是没有办法修改html的，因为<code>UIWebView</code>和<code>WKWebView</code>都没有提供一个Api，在图片加载之前告诉你html是什么内容，所以这个方法是走不通的。除非你用<code>loadHTMLString</code>的方法加载，加载前先替换img的src。但是<code>loadHTMLString</code>的方法，又加载不到Web端的js和css，只能用于本地拼接完整<code>HTML String</code>的情况，不适用于一般的场景。So，这条路是走不通的，局限性太大了。</p>
<p>方法2的核心思路就是拦截请求，最核心的是在你的<code>NSURLProtocol</code>子类中，实现这个方法</p>
<pre><code class="objective-c">+ (BOOL)canInitWithRequest:(NSURLRequest *)request {
    //处理过不再处理
    if ([NSURLProtocol propertyForKey:DAURLProtocolHandledKey inRequest:request]) {
        return NO;
    }
    //根据request header中的 accept 来判断是否加载图片
    /*
    {
     &quot;Accept&quot; = &quot;image/png,image/svg+xml,image/*;q=0.8,*\/*;q=0.5\&quot;;
     &quot;User-Agent&quot; = &quot;Mozilla/5.0 (iPhone; CPU iPhone OS 10_3 like Mac OS X) AppleWebKit/603.1.30 (KHTML, like Gecko) Mobile/14E269 WebViewDemo/1.0.0&quot;;
    }
     */
    NSDictionary *headers = request.allHTTPHeaderFields;
    NSString *accept = headers[@&quot;Accept&quot;];
    if (accept.length &gt;= @&quot;image&quot;.length &amp;&amp; [accept rangeOfString:@&quot;image&quot;].location != NSNotFound) {
        return YES;
    }
    return NO;
}
</code></pre>
<p>当拦截到图片请求时，再做后续的处理，下面写一些伪代码</p>
<pre><code class="objective-c">+ (NSURLRequest *)canonicalRequestForRequest:(NSURLRequest *)request {
    return request;
}
+ (BOOL)requestIsCacheEquivalent:(NSURLRequest *)a toRequest:(NSURLRequest *)b {
    return [super requestIsCacheEquivalent:a toRequest:b];
}
- (void)startLoading {
    NSMutableURLRequest *mutableReqeust = [[self request] mutableCopy];
    //这里也可以添加一些自定义的header，看具体需求
    //标记该request已经处理过
    [NSURLProtocol setProperty:@(YES) forKey:DAURLProtocolHandledKey inRequest:mutableReqeust];

    //这里NSURLProtocolClient的相关方法都要调用
    //比如 [self.client URLProtocol:self didLoadData:data];
    .....
}
- (void)stopLoading {
    .....
}
</code></pre>
<p>这部分代码，Demo中并没有完全实现，如果小伙伴们有兴趣研究下具体的实现，可以参考<a href="http://www.cocoachina.com/ios/20141225/10765.html" target="_blank" rel="external">这篇文章</a>， 笔者这里就不多说了。</p>
<h2 id="Native分享H5页面到微信、QQ等"><a href="#Native分享H5页面到微信、QQ等" class="headerlink" title="Native分享H5页面到微信、QQ等"></a>Native分享H5页面到微信、QQ等</h2><p>这个需求，其实我在前面的文章中针对<code>UIWebView</code>和<code>WKWebView</code>都已经做了很详细的介绍。这里，简单分享下如何获取分享的内容。</p>
<p>一般分享到微信或者QQ至少需要的参数是</p>
<blockquote>
<ol>
<li>Title（主标题）</li>
<li>Description（副标题或者描述）</li>
<li>ThumbnailImage（缩略图）</li>
<li>WebpageUrl（h5页面的链接）</li>
</ol>
</blockquote>
<p>这些参数，都怎么获取呢？通过OC-&gt;JS的方式，获取。当然你也可以自定义。</p>
<pre><code class="javascript">var title = document.title;
var desc = document.getElementsByTagName(&quot;article&quot;)[0].textContent;     //或者 document.body.innerText; 或者  document.getElementById(&quot;yourId&quot;).innerText; 
var thumbnailImageUrl = document.getElementsByTagName(&quot;img&quot;)[0].src;    //或者看需求取哪个
var webpageUrl = location.href;
</code></pre>
<p>具体如何用OC调用JS获取这些值，这里就不多说了，看过前面文章的小伙伴，可以自行实现。</p>
<h2 id="Native为H5提供一套Native-Api（微信、支付宝小程序）"><a href="#Native为H5提供一套Native-Api（微信、支付宝小程序）" class="headerlink" title="Native为H5提供一套Native Api（微信、支付宝小程序）"></a>Native为H5提供一套Native Api（微信、支付宝小程序）</h2><p>很多时候，Native与H5交互得深了，必定会有一些更深层次的需求。比如h5想控制页面的pop、push、present，想调用Native的Share，想调用Native的扫描二维码功能，获取扫描结果……</p>
<p>那么近半年比较🔥的小程序，微信提供的一些Api（扫码、选择照片等）都是如何实现的呢？很明显，native提供的。</p>
<p>笔者作为支付宝小程序（尚未发布）的内测用户之一，也接触了支付宝小程序，其中也有很多Api是native提供的。</p>
<p>其实这就涉及到一个完整的Native与JS交互的流程，<strong>从JS-&gt;Native到Native-&gt;JS</strong>。也就是前面介绍过的，异步回调结果。这个不局限于iOS，Android也是同样的。</p>
<p>首先，我们为H5提供一套Api，那自然Api是暴露给js的，所以这些Api也是js的。笔者封装了一个接口文件：<code>NativeApi.js</code>（在最新的<a href="https://github.com/DarkAngel7/Demos-WebViewDemo" target="_blank" rel="external">Demo</a>中有）。下面针对一些需求，分析下封装和实现。其中用到了<strong>js闭包</strong>，需要一点js知识。</p>
<h3 id="分享"><a href="#分享" class="headerlink" title="分享"></a>分享</h3><p>前面的文章中，笔者最常举的一个例子就是分享，Native为H5提供原生的分享方法，h5调用后可以获取分享结果（成功or失败）。这里针对分享这个如何实现，就不赘述了。笔者直接贴上适用于<code>WKWebView</code>的<code>js</code>代码。</p>
<pre><code class="javascript">/**
 * Native为H5提供的Api接口
 *
 * @type {js对象}
 */
var DANativeApi = (function() {

    var NativeApi = {
        /**
         * 分享
         * @param  {js对象} shareInfo 分享信息和回调
         * @return {void}           无同步返回值，异步返回分享结果 true or false
         */
        share: function(shareInfo) {
            if (shareInfo == undefined || shareInfo == null || typeof(shareInfo) !== &quot;object&quot;) {
                alert(&quot;参数&quot; + JSON.stringify(shareInfo) + &quot;不合法&quot;);
            } else {
                alert(&quot;分享的参数为&quot; + JSON.stringify(shareInfo));
            }
            //调用native端
            _nativeShare(shareInfo);
        }
    }

    //下面是一些私有函数
    /**
     * Native端实现，适用于WKWebView，UIWebView如何实现，小伙伴自己动脑筋吧~
     * @param  {js对象} shareInfo 分享的信息和回调
     * @return {void}           无同步返回值，异步返回
     */
    function _nativeShare(shareInfo) {
        //用于WKWebView，因为WKWebView并没有办法把js function传递过去，因此需要特殊处理一下
        //把js function转换为字符串，oc端调用时 (&lt;js function string&gt;)(true); 即可
        //如果有回调函数，且为function
        var callbackFunction = shareInfo.result;
        if (callbackFunction != undefined &amp;&amp; callbackFunction != null &amp;&amp; typeof(callbackFunction) === &quot;function&quot;) {
            shareInfo.result = callbackFunction.toString();
        }
        //js -&gt; oc 
        // 至于Android端，也可以，比如 window.jsInterface.nativeShare(JSON.stringify(shareInfo));
        window.webkit.messageHandlers.nativeShare.postMessage(shareInfo);
    }

    //闭包，把Api对象返回
    return NativeApi;
})();

/*

//调用时，分享
DANativeApi.share({
    title: document.title,
    desc: &quot;&quot;,
    url: location.href,
    imgUrl: &quot;&quot;,
    result: function(res) {
        // body...
        alert(&quot;分享结果为：&quot; + JSON.stringify(res));
    }
});

 */
</code></pre>
<p>Native端不贴了，小伙伴们看Demo吧。</p>
<h3 id="从通讯录选择联系人"><a href="#从通讯录选择联系人" class="headerlink" title="从通讯录选择联系人"></a>从通讯录选择联系人</h3><p>这里笔者再举个从通讯录选择联系人的例子，从js到native，再从native到js。</p>
<p>首先js端，添加如下实现</p>
<pre><code class="javascript">/**
 * Native为H5提供的Api接口
 *
 * @type {js对象}
 */
var DANativeApi = (function() {

    var NativeApi = {
        /**
         * 从通讯录选择联系人
         * @return {void} 无同步返回值，异步返回选择的结果
         */
        choosePhoneContact: function(param) {
            //具体是否需要判断
            //调用native端
            _nativeChoosePhoneContact(param);
        }
    }

    //下面是一些私有函数
    /**
     * Native端实现选择联系人，并异步返回结果
     * @param  {[type]} param [description]
     * @return {[type]}       [description]
     */
    function _nativeChoosePhoneContact(param) {
        var callbackFunction = param.completion;
        if (callbackFunction != undefined &amp;&amp; callbackFunction != null &amp;&amp; typeof(callbackFunction) === &quot;function&quot;) {
            param.completion = callbackFunction.toString();
        }
        //js -&gt; oc 
        window.webkit.messageHandlers.nativeChoosePhoneContact.postMessage(param);
    }

    //闭包，把Api对象返回
    return NativeApi;
})();

/*
//选择联系人
DANativeApi.choosePhoneContact({
    completion: function(res) {
        alert(&quot;选择联系人的结果为：&quot; + JSON.stringify(res));
    }
});
 */
</code></pre>
<p>OC端依然加载此文件，并注册handler</p>
<pre><code class="objective-c">/**
 添加native端的api
 */
- (void)addNativeApiToJS
{
    //防止频繁IO操作，造成性能影响
    static NSString *nativejsSource;
    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{
        nativejsSource = [NSString stringWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@&quot;NativeApi&quot; ofType:@&quot;js&quot;] encoding:NSUTF8StringEncoding error:nil];
    });
    //添加自定义的脚本
    WKUserScript *js = [[WKUserScript alloc] initWithSource:nativejsSource injectionTime:WKUserScriptInjectionTimeAtDocumentStart forMainFrameOnly:NO];
    [self.webView.configuration.userContentController addUserScript:js];
    //注册回调
    [self.webView.configuration.userContentController addScriptMessageHandler:self name:@&quot;nativeChoosePhoneContact&quot;];
}

#pragma mark - WKScriptMessageHandler  js -&gt; oc

- (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message {
   //选择联系人
   if ([message.name isEqualToString:@&quot;nativeChoosePhoneContact&quot;]) {
        NSLog(@&quot;正在选择联系人&quot;);

        [self selectContactCompletion:^(NSString *name, NSString *phone) {
            NSLog(@&quot;选择完成&quot;);
            //读取js function的字符串
            NSString *jsFunctionString = message.body[@&quot;completion&quot;];
            //拼接调用该方法的js字符串
            NSString *callbackJs = [NSString stringWithFormat:@&quot;(%@)({name: &#39;%@&#39;, mobile: &#39;%@&#39;});&quot;, jsFunctionString, name, phone];
            //执行回调
            [self.webView evaluateJavaScript:callbackJs completionHandler:^(id _Nullable result, NSError * _Nullable error) {

            }];
        }];
    }
}
</code></pre>
<p>具体回调方式，在之前的<code>WKWebView</code>中，讲过了，这里不再赘述，选择联系人用的是<code>Contacts</code>框架，具体的小伙伴可以看Demo。</p>
<p>整体效果如下：</p>
<p><img src="http://ww2.sinaimg.cn/large/006tNbRwly1ffispvqvqeg308z0g0alz.gif" alt="new"></p>
<h3 id="扫描二维码"><a href="#扫描二维码" class="headerlink" title="扫描二维码"></a>扫描二维码</h3><p>相信看过从通讯录选择联系人的实现，小伙伴们可以自行实现扫描二维码了吧~ 快动手尝试一下吧~</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>本文给小伙伴们介绍了下Safari调试，以及其具体运用，并且分享了实际应用中一些需求的实现方式。</p>
<p>结合前面的两篇文章， 相信现在小伙伴们一定对<code>WebView</code>有相当深刻的理解了吧。那么，本系列文章也告一段落了，具体有问题的话，欢迎提问。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/006tNc79ly1fff1sa06wrj30sg0iwwi9.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; titl
    
    </summary>
    
    
      <category term="iOS技术分享" scheme="http://blog.darkangel7.com/tags/iOS%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>iOS中UIWebView与WKWebView、JavaScript与OC交互、Cookie管理看我就够（中）</title>
    <link href="http://blog.darkangel7.com/2017/05/10/iOS%E4%B8%ADUIWebView%E4%B8%8EWKWebView%E3%80%81JavaScript%E4%B8%8EOC%E4%BA%A4%E4%BA%92%E3%80%81Cookie%E7%AE%A1%E7%90%86%E7%9C%8B%E6%88%91%E5%B0%B1%E5%A4%9F%EF%BC%88%E4%B8%AD%EF%BC%89/"/>
    <id>http://blog.darkangel7.com/2017/05/10/iOS中UIWebView与WKWebView、JavaScript与OC交互、Cookie管理看我就够（中）/</id>
    <published>2017-05-10T02:10:09.000Z</published>
    <updated>2017-09-27T11:30:16.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1fff1sa06wrj30sg0iwwi9.jpg" alt=""></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>关于<code>UIWebView</code>的介绍，相信看过<a href="http://blog.darkangel7.com/2016/09/01/iOS中UIWebView与WKWebView、JavaScript与OC交互、Cookie管理看我就够（上）/">上文</a>的小伙伴们，已经大概清楚了吧，如果有问题，欢迎提问。</p>
<p>本文是本系列文章的第二篇，主要为小伙伴们分享下<code>WKWebView</code>相关的内容：</p>
<ul>
<li><a href="http://blog.darkangel7.com/2016/09/01/iOS中UIWebView与WKWebView、JavaScript与OC交互、Cookie管理看我就够（上）/">iOS中UIWebView与WKWebView、JavaScript与OC交互、Cookie管理看我就够（上）</a></li>
<li>iOS中UIWebView与WKWebView、JavaScript与OC交互、Cookie管理看我就够（中）</li>
<li><a href="http://blog.darkangel7.com/2017/05/11/iOS中UIWebView与WKWebView、JavaScript与OC交互、Cookie管理看我就够（下）/">iOS中UIWebView与WKWebView、JavaScript与OC交互、Cookie管理看我就够（下）</a></li>
</ul>
<p>关于文中提到的一些内容，这里我准备了个<a href="https://github.com/DarkAngel7/Demos-WebViewDemo" target="_blank" rel="external">Demo</a>，有需要的小伙伴可以下载。</p>
<h1 id="WKWebView"><a href="#WKWebView" class="headerlink" title="WKWebView"></a>WKWebView</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>WKWebView</code>是Apple于iOS 8.0推出的<code>WebKit</code>中的核心控件，用来替代<code>UIWebView</code>。<code>WKWebView</code>比<code>UIWebView</code>的优势在于：</p>
<ul>
<li><p>更多的支持HTML5的特性</p>
</li>
<li><p>高达60fps的滚动刷新率以及内置手势</p>
</li>
<li>与Safari相同的JavaScript引擎</li>
<li>将UIWebViewDelegate与UIWebView拆分成了14类与3个协议（<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/WebKit/ObjC_classic/index.html" target="_blank" rel="external">官方文档说明</a>）</li>
<li>可以获取加载进度：<code>estimatedProgress</code>（UIWebView需要调用私有Api）</li>
</ul>
<p>作者本人在项目中使用<code>WKWebView</code>也1年多了，确确实实感受到了它的优势，但是同样也感受到了它带来的一些坑。下面来具体的介绍下<code>WKWebView</code>。其实Apple开源了<a href="https://opensource.apple.com/source/WebKit2/" target="_blank" rel="external">WebKit</a>，有兴趣的小伙伴可以研究下它的实现。</p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p><code>WKWebView</code>的创建方法有这两种</p>
<pre><code class="objective-c">/*-initWithFrame: to initialize an instance with the default configuration. 如果使用initWithFrame方法将使用默认的configuration
The initializer copies the specified configuration, so mutating the configuration after invoking the initializer has no effect on the web view. 我们需要先设置configuration，再调用init，在init之后修改configuration则无效
*/
- (instancetype)initWithFrame:(CGRect)frame configuration:(WKWebViewConfiguration *)configuration NS_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder *)coder NS_DESIGNATED_INITIALIZER;
</code></pre>
<p>仔细看第一个方法，比<code>UIWebView</code>多了个<code>configuration</code>，这个配置可以设置很多东西。具体查看<code>WKWebViewConfiguration.h</code>，可以配置js是否支持，画中画是否开启等，这里主要讲两个比较常用的属性。</p>
<p>第一个属性是<code>websiteDataStore</code>。</p>
<pre><code class="objective-c">/*! @abstract The website data store to be used by the web view.
 */
@property (nonatomic, strong) WKWebsiteDataStore *websiteDataStore API_AVAILABLE(macosx(10.11), ios(9.0));
</code></pre>
<p>业界普遍认为 <code>WKWebView</code> 拥有自己的私有存储，它的一些缓存等数据都存在<code>websiteDataStore</code>中，具体增删改查就可以通过<code>WKWebsiteDataStore.h</code>中提供的方法，这里不多说，一般用的时候比较少，真的要清除缓存，简单粗暴的方法是删除沙盒目录中的Cache文件夹。</p>
<p>第二个属性是<code>userContentController</code>。</p>
<pre><code class="objective-c">/*! @abstract The user content controller to associate with the web view.
*/
@property (nonatomic, strong) WKUserContentController *userContentController;
</code></pre>
<p>这个属性很重要，后面讲的js-&gt;oc的交互，以及注入js代码都会用到它。查看<code>WKUserContentController</code>的头文件，你会发现它有如下几个方法：</p>
<pre><code class="objective-c">@interface WKUserContentController : NSObject &lt;NSCoding&gt;
//读取添加过的脚本
@property (nonatomic, readonly, copy) NSArray&lt;WKUserScript *&gt; *userScripts;
//添加脚本
- (void)addUserScript:(WKUserScript *)userScript;
//删除所有添加的脚本
- (void)removeAllUserScripts;
//通过window.webkit.messageHandlers.&lt;name&gt;.postMessage(&lt;messageBody&gt;) 来实现js-&gt;oc传递消息，并添加handler
- (void)addScriptMessageHandler:(id &lt;WKScriptMessageHandler&gt;)scriptMessageHandler name:(NSString *)name;
//删除handler
- (void)removeScriptMessageHandlerForName:(NSString *)name;
@end
</code></pre>
<p>那么整体我创建一个<code>WKWebView</code>的代码如下：</p>
<pre><code class="objective-c">WKWebViewConfiguration *configuration = [[WKWebViewConfiguration alloc] init];
WKUserContentController *controller = [[WKUserContentController alloc] init];
configuration.userContentController = controller;
self.webView = [[WKWebView alloc] initWithFrame:self.view.bounds configuration:configuration];
self.webView.allowsBackForwardNavigationGestures = YES;    //允许右滑返回上个链接，左滑前进
self.webView.allowsLinkPreview = YES; //允许链接3D Touch
self.webView.customUserAgent = @&quot;WebViewDemo/1.0.0&quot;; //自定义UA，UIWebView就没有此功能，后面会讲到通过其他方式实现
self.webView.UIDelegate = self;
self.webView.navigationDelegate = self;
[self.view addSubview:self.webView];
</code></pre>
<h4 id="动态注入js"><a href="#动态注入js" class="headerlink" title="动态注入js"></a>动态注入js</h4><p>通过给<code>userContentController</code>添加<code>WKUserScript</code>，可以实现动态注入js。比如我先注入一个脚本，给每个页面添加一个Cookie</p>
<pre><code class="objective-c">//注入一个Cookie
WKUserScript *newCookieScript = [[WKUserScript alloc] initWithSource:@&quot;document.cookie = &#39;DarkAngelCookie=DarkAngel;&#39;&quot; injectionTime:WKUserScriptInjectionTimeAtDocumentStart forMainFrameOnly:NO];
[controller addUserScript:newCookieScript];
</code></pre>
<p>然后再注入一个脚本，每当页面加载，就会alert当前页面cookie，在OC中的实现</p>
<pre><code class="objective-c">//创建脚本
WKUserScript *cookieScript = [[WKUserScript alloc] initWithSource:@&quot;alert(document.cookie);&quot; injectionTime:WKUserScriptInjectionTimeAtDocumentEnd forMainFrameOnly:NO];
//添加脚本
[controller addUserScript:script];
</code></pre>
<p>这样每当页面出现的时候，会alet弹出当前页面所有的cookie字符串。<img src="http://ww1.sinaimg.cn/large/006tNc79ly1ffgc3n3b8fj30ku12aq38.jpg" width="200px;"></p>
<p>注入的js source可以是任何js字符串，也可以js文件。比如你有很多提供给h5使用的js方法，那么你本地可能就会有一个<code>native_functions.js</code>，你可以通过以下的方式添加</p>
<pre><code class="objective-c">//防止频繁IO操作，造成性能影响
static NSString *jsSource;
static dispatch_once_t onceToken;
  dispatch_once(&amp;onceToken, ^{
      jsSource = [NSString stringWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@&quot;native_functions&quot; ofType:@&quot;js&quot;] encoding:NSUTF8StringEncoding error:nil];
});
//添加自定义的脚本
WKUserScript *js = [[WKUserScript alloc] initWithSource:jsSource injectionTime:WKUserScriptInjectionTimeAtDocumentEnd forMainFrameOnly:NO];
[self.configuration.userContentController addUserScript:js];
</code></pre>
<h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p>加载一个请求或者页面也很简单</p>
<pre><code class="objective-c">- (nullable WKNavigation *)loadRequest:(NSURLRequest *)request;
- (nullable WKNavigation *)loadFileURL:(NSURL *)URL allowingReadAccessToURL:(NSURL *)readAccessURL API_AVAILABLE(macosx(10.11), ios(9.0));
- (nullable WKNavigation *)loadHTMLString:(NSString *)string baseURL:(nullable NSURL *)baseURL;
- (nullable WKNavigation *)loadData:(NSData *)data MIMEType:(NSString *)MIMEType characterEncodingName:(NSString *)characterEncodingName baseURL:(NSURL *)baseURL API_AVAILABLE(macosx(10.11), ios(9.0));
</code></pre>
<p>基本与<code>UIWebView</code>的很相似，但是需要说明的是，加载本地的一个html需要使用<code>loadRequest:</code>方法，使用<code>loadHTMLString:baseURL:</code>方法会有问题。</p>
<pre><code class="objective-c">[self.webView loadRequest:[NSURLRequest requestWithURL:[NSURL fileURLWithPath:[[NSBundle mainBundle] pathForResource:@&quot;test&quot; ofType:@&quot;html&quot;]]]];
</code></pre>
<h4 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h4><p>在<code>WKWebView</code>的头文件，你会发现</p>
<pre><code class="objective-c">@protocol WKNavigationDelegate;    //类似于UIWebView的加载成功、失败、是否允许跳转等
@protocol WKUIDelegate;    //主要是一些alert、打开新窗口之类的
</code></pre>
<p>有两个协议，它将<code>UIWebView</code>的代理协议拆成了一个跳转的协议和一个关于UI的协议。虽说这两个协议中的所有方法都是Optional，但是关于<code>WKUIDelegate</code>协议是有坑的，后面的<strong>各种坑</strong>中会提到。简单说下<code>WKNavigationDelegate</code>中比较常用的方法</p>
<pre><code class="objective-c">//下面这2个方法共同对应了UIWebView的 - (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType;
//先：针对一次action来决定是否允许跳转，action中可以获取request，允许与否都需要调用decisionHandler，比如decisionHandler(WKNavigationActionPolicyCancel);
- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler；
//后：根据response来决定，是否允许跳转，允许与否都需要调用decisionHandler，如decisionHandler(WKNavigationResponsePolicyAllow);
- (void)webView:(WKWebView *)webView decidePolicyForNavigationResponse:(WKNavigationResponse *)navigationResponse decisionHandler:(void (^)(WKNavigationResponsePolicy))decisionHandler;

//开始加载，对应UIWebView的- (void)webViewDidStartLoad:(UIWebView *)webView;
- (void)webView:(WKWebView *)webView didStartProvisionalNavigation:(null_unspecified WKNavigation *)navigation;

//加载成功，对应UIWebView的- (void)webViewDidFinishLoad:(UIWebView *)webView;
- (void)webView:(WKWebView *)webView didFinishNavigation:(null_unspecified WKNavigation *)navigation;

//加载失败，对应UIWebView的- (void)webView:(UIWebView *)webView didFailLoadWithError:(NSError *)error;
- (void)webView:(WKWebView *)webView didFailNavigation:(null_unspecified WKNavigation *)navigation withError:(NSError *)error;
</code></pre>
<p><code>WKUIDelegate</code>这里先不提了，小伙伴们可以参考我<a href="https://github.com/DarkAngel7/Demos-WebViewDemo" target="_blank" rel="external">Demo</a>中的实现。</p>
<h4 id="新属性"><a href="#新属性" class="headerlink" title="新属性"></a>新属性</h4><p><code>WKWebView.h</code>定义了如下几个常用的<code>readonly</code>属性：</p>
<pre><code class="objective-c">@property (nullable, nonatomic, readonly, copy) NSString *title;    //页面的title，终于可以直接获取了
@property (nullable, nonatomic, readonly, copy) NSURL *URL;        //当前webView的URL
@property (nonatomic, readonly, getter=isLoading) BOOL loading;    //是否正在加载
@property (nonatomic, readonly) double estimatedProgress;    //加载的进度
@property (nonatomic, readonly) BOOL canGoBack;    //是否可以后退，跟UIWebView相同
@property (nonatomic, readonly) BOOL canGoForward;    //是否可以前进，跟UIWebView相同
</code></pre>
<p>这些属性都很有用，而且支持KVO，所以我们可以通过KVO观察这些值的变化，以便于我们做出最友好的交互。</p>
<h2 id="JavaScript与Objective-C的交互"><a href="#JavaScript与Objective-C的交互" class="headerlink" title="JavaScript与Objective-C的交互"></a>JavaScript与Objective-C的交互</h2><p>介绍完<code>WKWebView</code>的基本用法，让我们来研究下基于它的js与oc的交互。</p>
<h3 id="OC-gt-JS"><a href="#OC-gt-JS" class="headerlink" title="OC -&gt; JS"></a>OC -&gt; JS</h3><p>这个比较简单，<code>WKWebView</code>提供了一个类似<code>JavaScriptCore</code>的方法</p>
<pre><code class="objective-c">//执行一段js，并将结果返回，如果出错，error则不为空
- (void)evaluateJavaScript:(NSString *)javaScriptString completionHandler:(void (^ _Nullable)(_Nullable id result, NSError * _Nullable error))completionHandler;
</code></pre>
<p>该方法很好的解决了之前文章中提到的<code>UIWebView</code>使用<code>stringByEvaluatingJavaScriptFromString:</code>方法的两个缺点（1. 返回值只能是NSString。2. 报错无法捕获）。比如我想获取页面中的<code>title</code>，除了直接<code>self.webView.title</code>外，还可以通过这个方法：</p>
<pre><code class="objective-c">[self.webView evaluateJavaScript:@&quot;document.title&quot; completionHandler:^(id _Nullable title, NSError * _Nullable error) {
        NSLog(@&quot;调用evaluateJavaScript异步获取title：%@&quot;, title);
}];
</code></pre>
<h3 id="JS-gt-OC"><a href="#JS-gt-OC" class="headerlink" title="JS -&gt; OC"></a>JS -&gt; OC</h3><h4 id="URL拦截"><a href="#URL拦截" class="headerlink" title="URL拦截"></a>URL拦截</h4><p>此方法与上篇文章中<code>UIWebView</code>介绍到的URL拦截方法一致，都是通过自定义Scheme，在链接激活时，拦截该URL，拿到参数，调用OC方法，缺点依然明显。<code>WKWebView</code>实现起来如下：</p>
<p>比如我的链接依然是</p>
<pre><code class="html">&lt;a href=&quot;darkangel://smsLogin?username=12323123&amp;code=892845&quot;&gt;短信验证登录&lt;/a&gt;
</code></pre>
<p>当用户点击这个a标签时，会被拦截</p>
<pre><code class="objective-c">- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler {
    //可以通过navigationAction.navigationType获取跳转类型，如新链接、后退等
    NSURL *URL = navigationAction.request.URL;
    //判断URL是否符合自定义的URL Scheme
    if ([URL.scheme isEqualToString:@&quot;darkangel&quot;]) {
        //根据不同的业务，来执行对应的操作，且获取参数
        if ([URL.host isEqualToString:@&quot;smsLogin&quot;]) {
            NSString *param = URL.query;
            NSLog(@&quot;短信验证码登录, 参数为%@&quot;, param);
            decisionHandler(WKNavigationActionPolicyCancel);
            return;
        }
    }
    decisionHandler(WKNavigationActionPolicyAllow);
    NSLog(@&quot;%@&quot;, NSStringFromSelector(_cmd));
}
</code></pre>
<p>整体实现是与<code>UIWebView</code>十分相似的，这里就不多说了。</p>
<p>这里再次提一下<a href="https://github.com/marcuswestin/WebViewJavascriptBridge" target="_blank" rel="external">WebViewJavascriptBridge</a>，它在最近的新版本中支持了<code>WKWebView</code>。使用的方案同样是<strong>拦截URL</strong>，具体原理在之前的文章中简单描述过，这里不再赘述。下面说下Apple的新方法。</p>
<h4 id="scriptMessageHandler"><a href="#scriptMessageHandler" class="headerlink" title="scriptMessageHandler"></a>scriptMessageHandler</h4><p>这是Apple在<code>WebKit</code>里新增加的方法，位于<code>WKUserContentController.h</code>。</p>
<pre><code class="objective-c">/*! @abstract Adds a script message handler.
 @param scriptMessageHandler The message handler to add.
 @param name The name of the message handler.
 @discussion Adding a scriptMessageHandler adds a function
 window.webkit.messageHandlers.&lt;name&gt;.postMessage(&lt;messageBody&gt;) for all
 frames.
 */
- (void)addScriptMessageHandler:(id &lt;WKScriptMessageHandler&gt;)scriptMessageHandler name:(NSString *)name;

/*! @abstract Removes a script message handler.
 @param name The name of the message handler to remove.
 */
- (void)removeScriptMessageHandlerForName:(NSString *)name;
</code></pre>
<p>其实Apple的注释已经很清楚了，在OC中添加一个scriptMessageHandler，则会在<code>all frames</code>中添加一个js的function： <code>window.webkit.messageHandlers.&lt;name&gt;.postMessage(&lt;messageBody&gt;)</code> 。那么当我在OC中通过如下的方法添加了一个handler，如</p>
<pre><code class="objective-c">[controller addScriptMessageHandler:self name:@&quot;currentCookies&quot;]; //这里self要遵循协 WKScriptMessageHandler
</code></pre>
<p>则当我在js中调用下面的方法时</p>
<pre><code class="javascript">window.webkit.messageHandlers.currentCookies.postMessage(document.cookie);
</code></pre>
<p>我在OC中将会收到<code>WKScriptMessageHandler</code>的回调</p>
<pre><code class="objective-c">- (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message {
    if ([message.name isEqualToString:@&quot;currentCookies&quot;]) {
        NSString *cookiesStr = message.body;    //message.body返回的是一个id类型的对象，所以可以支持很多种js的参数类型(js的function除外)
        NSLog(@&quot;当前的cookie为： %@&quot;, cookiesStr);
    }
}
</code></pre>
<p>当然，记得在适当的地方调用removeScriptMessageHandler</p>
<pre><code class="objective-c">- (void)dealloc {
    //记得移除
    [self.webView.configuration.userContentController removeScriptMessageHandlerForName:@&quot;currentCookies&quot;];
}
</code></pre>
<p>这样就完成了一次完整的JS -&gt; OC的交互。</p>
<p><strong>问题</strong>：</p>
<ol>
<li>该方法还是<strong>没有办法直接获取返回值</strong>。</li>
<li>通过<code>window.webkit.messageHandlers.&lt;name&gt;.postMessage(&lt;messageBody&gt;)</code>传递的messageBody中不能包含js的function，<strong>如果包含了function，那么 OC端将不会收到回调</strong>。</li>
</ol>
<p>对于问题1，我们可以采用异步回调的方式，将返回值返回给js。对于问题2，一般js的参数中包含function是为了异步回调，这里我们可以把js的function转换为字符串，再传递给OC。</p>
<h3 id="实际运用"><a href="#实际运用" class="headerlink" title="实际运用"></a>实际运用</h3><p>关于上述问题1和问题2的结合利用，实现JS -&gt; OC的调用，并且OC -&gt; JS 异步回调结果，这里还是拿分享来举个例子。</p>
<p>比如js端实现了如下的方法（这段js的封装前面的文章里也有提及，小伙伴有问题可以看下之前的）：</p>
<pre><code class="javascript">  /**
   * 分享方法，并且会异步回调分享结果
   * @param  {对象类型} shareData 一个分享数据的对象，包含title,imgUrl,link以及一个回调function
   * @return {void}     无同步返回值
   */
  function shareNew(shareData) {

    //这是该方法的默认实现，上篇文章中有所提及
      var title = shareData.title;
      var imgUrl = shareData.imgUrl;
      var link = shareData.link;
      var result = shareData.result;
      //do something
      //这里模拟异步操作
      setTimeout(function() {
          //2s之后，回调true分享成功
          result(true);
      }, 2000);

      //用于WKWebView，因为WKWebView并没有办法把js function传递过去，因此需要特殊处理一下
      //把js function转换为字符串，oc端调用时 (&lt;js function string&gt;)(true); 即可
      shareData.result = result.toString();
      window.webkit.messageHandlers.shareNew.postMessage(shareData);
  }

  function test() {
     //清空分享结果
    shareResult.innerHTML = &quot;&quot;;

      //调用时，应该
      shareNew({
          title: &quot;title&quot;,
          imgUrl: &quot;http://img.dd.com/xxx.png&quot;,
          link: location.href,
          result: function(res) {
              //这里shareResult 等同于 document.getElementById(&quot;shareResult&quot;)
              shareResult.innerHTML = res ? &quot;success&quot; : &quot;failure&quot;;
          }
      });
  }
</code></pre>
<p>在html页面中我定义了一个a标签来触发test()函数</p>
<pre><code class="html">&lt;a href=&quot;javascript:void(0);&quot; onclick=&quot;test()&quot;&gt;测试新分享&lt;/a&gt;
</code></pre>
<p>在OC端，实现如下</p>
<pre><code class="objective-c">//首先别忘了，在configuration中的userContentController中添加scriptMessageHandler
[controller addScriptMessageHandler:self name:@&quot;shareNew&quot;];    //记得适当时候remove哦


//点击a标签时，则会调用下面的方法
#pragma mark - WKScriptMessageHandler 

- (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message {
    if ([message.name isEqualToString:@&quot;shareNew&quot;]) {
        NSDictionary *shareData = message.body;
        NSLog(@&quot;shareNew分享的数据为： %@&quot;, shareData);
        //模拟异步回调
        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(4 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
            //读取js function的字符串
            NSString *jsFunctionString = shareData[@&quot;result&quot;];
            //拼接调用该方法的js字符串
            NSString *callbackJs = [NSString stringWithFormat:@&quot;(%@)(%d);&quot;, jsFunctionString, NO];    //后面的参数NO为模拟分享失败
            //执行回调
            [self.webView evaluateJavaScript:callbackJs completionHandler:^(id _Nullable result, NSError * _Nullable error) {
                if (!error) {
                    NSLog(@&quot;模拟回调，分享失败&quot;);
                }
            }];
        });
    }
}
</code></pre>
<p>那么当我点击a标签时，html页面上过2s，会显示<strong>success</strong>，然后再过2s，会显示<strong>failure</strong>。<img src="http://ww2.sinaimg.cn/large/006tNc79ly1ffgcsdc7m3g309w0i776l.gif" alt="new"></p>
<p>我们来简单分析一下，点击之后，触发了<code>test()</code>函数，<code>test()</code>中封装了对<code>share()</code>函数的调用，且传了一个对象作为参数，对象中<code>result</code>字段对应的是个匿名函数，紧接着<code>share()</code>函数调用，其中的实现是2s过后，<code>result(true);</code>模拟js异步实现异步回调结果，分享成功。同时<code>share()</code>函数中，因为通过<code>scriptMessageHandler</code>无法传递<code>function</code>，所以先把<code>shareData</code>对象中的result这个匿名<code>function</code>转成<code>String</code>，然后替换<code>shareData</code>对象的<code>result</code>属性为这个<code>String</code>，并回传给OC，OC这边对应JS对象的数据类型是<code>NSDictionary</code>，我们打印并得到了所有参数，同时，把<code>result</code>字段对应的js <code>function String</code>取出来。这里我们延迟4s回调，模拟Native分享的异步过程，在4s后，也就是js中显示<strong>success</strong>的2s过后，调用js的匿名<code>function</code>，并传递参数（分享结果）。调用一个js function的方法是 <code>functionName(argument);</code> ，这里由于这个js的function已经是一个String了，所以我们调用时，需要加上<code>()</code>，如 <code>(functionString)(argument);</code>因此，最终我们通过OC -&gt; JS 的<code>evaluateJavaScript:completionHandler:</code>方法，成功完成了异步回调，并传递给js一个分享失败的结果。</p>
<p>上面的描述看起来很复杂，其实就是先执行了JS的默认实现，后执行了OC的实现。上面的代码展示了如何解决<code>scriptMessageHandler</code>的两个问题，并且实现了一个 JS -&gt; OC、OC -&gt; JS 完整的交互流程。</p>
<h2 id="Cookie管理"><a href="#Cookie管理" class="headerlink" title="Cookie管理"></a>Cookie管理</h2><p>比起<code>UIWebView</code>的自动管理，<code>WKWebView</code>坑爹的<code>Cookie</code>管理，相信阻止了很多的尝试者。许多小伙伴也许曾经都想从<code>UIWebView</code>转到<code>WKWebView</code>，但估计因为<code>Cookie</code>的问题，最终都放弃了，笔者折腾<code>WKWebView</code>的<code>Cookie</code>长达多半年之久，也曾想放弃，但最终还是坚持下来了，虽说现在不敢说完全掌握，至少也不影响正常使用了。</p>
<p>下面来说几点注意事项：</p>
<ol>
<li><code>WKWebView</code>加载网页得到的<code>Cookie</code>会同步到<code>NSHTTPCookieStorage</code>中（也许你看过一些文章说不能同步，但笔者这里说下，它真的会，大家可以尝试下，实践出真知）。</li>
<li><code>WKWebView</code>加载请求时，不会同步<code>NSHTTPCookieStorage</code>中已有的<code>Cookie</code>（是的，<strong>最坑的地方</strong>）。</li>
<li>通过共用一个<code>WKProcessPool</code>并不能解决2中<code>Cookie</code>同步问题，且可能会造成<code>Cookie</code>丢失。</li>
</ol>
<p>结合自己的实践和参考一些资料，笔者得到上面的结论。</p>
<p>关于如何操作<code>NSHTTPCookieStorage</code>，前面的文章中提到过了，本文不再赘述。对于问题2，<a href="http://stackoverflow.com/questions/26573137/can-i-set-the-cookies-to-be-used-by-a-wkwebview" target="_blank" rel="external">StackOverFlow上有些解答</a>，但经过实际尝试，发现还是或多或少有一些问题。</p>
<p>为了解决这个最为致命的Cookie问题，需要的做的有以下几点：</p>
<h3 id="解决首次加载Cookie带不上问题"><a href="#解决首次加载Cookie带不上问题" class="headerlink" title="解决首次加载Cookie带不上问题"></a>解决首次加载Cookie带不上问题</h3><p>在request的requestHeader中添加Cookie：</p>
<pre><code class="objective-c">NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@&quot;http://www.baidu.com&quot;]];
NSArray *cookies = [NSHTTPCookieStorage sharedHTTPCookieStorage].cookies;
//Cookies数组转换为requestHeaderFields
NSDictionary *requestHeaderFields = [NSHTTPCookie requestHeaderFieldsWithCookies:cookies];
//设置请求头
request.allHTTPHeaderFields = requestHeaderFields;
[self.webView loadRequest:request];
</code></pre>
<p>这样，只要你<strong>保证<code>sharedHTTPCookieStorage</code>中你的Cookie存在</strong>，首次访问一个页面，就不会有问题。</p>
<h3 id="解决后续Ajax请求Cookie丢失问题"><a href="#解决后续Ajax请求Cookie丢失问题" class="headerlink" title="解决后续Ajax请求Cookie丢失问题"></a>解决后续Ajax请求Cookie丢失问题</h3><p>解决此问题，也比较简单，添加<code>WKUserScript</code>。</p>
<pre><code class="objective-c">/*!
 *  更新webView的cookie
 */
- (void)updateWebViewCookie
{
    WKUserScript * cookieScript = [[WKUserScript alloc] initWithSource:[self cookieString] injectionTime:WKUserScriptInjectionTimeAtDocumentStart forMainFrameOnly:NO];
    //添加Cookie
    [self.configuration.userContentController addUserScript:cookieScript];
}

- (NSString *)cookieString
{
    NSMutableString *script = [NSMutableString string];
    [script appendString:@&quot;var cookieNames = document.cookie.split(&#39;; &#39;).map(function(cookie) { return cookie.split(&#39;=&#39;)[0] } );\n&quot;];
    for (NSHTTPCookie *cookie in [[NSHTTPCookieStorage sharedHTTPCookieStorage] cookies]) {
        // Skip cookies that will break our script
        if ([cookie.value rangeOfString:@&quot;&#39;&quot;].location != NSNotFound) {
            continue;
        }
        // Create a line that appends this cookie to the web view&#39;s document&#39;s cookies
        [script appendFormat:@&quot;if (cookieNames.indexOf(&#39;%@&#39;) == -1) { document.cookie=&#39;%@&#39;; };\n&quot;, cookie.name, cookie.da_javascriptString];
    }
    return script;
}

@interface NSHTTPCookie (Utils)

- (NSString *)da_javascriptString;

@end

@implementation NSHTTPCookie (Utils)

- (NSString *)da_javascriptString
{
    NSString *string = [NSString stringWithFormat:@&quot;%@=%@;domain=%@;path=%@&quot;,
                        self.name,
                        self.value,
                        self.domain,
                        self.path ?: @&quot;/&quot;];
    if (self.secure) {
        string = [string stringByAppendingString:@&quot;;secure=true&quot;];
    }
    return string;
}

@end
</code></pre>
<p>同样只要你<strong>保证<code>sharedHTTPCookieStorage</code>中你的Cookie存在</strong>，后续Ajax请求就不会有问题。</p>
<h3 id="解决跳转新页面时Cookie带不过去问题"><a href="#解决跳转新页面时Cookie带不过去问题" class="headerlink" title="解决跳转新页面时Cookie带不过去问题"></a>解决跳转新页面时Cookie带不过去问题</h3><p>即便你做到了上面两点，你会发现，当你点击页面上的某个链接，跳转到新的页面，<code>Cookie</code>又丢了😳，此时你是想狗带的~怎么解决呢？</p>
<pre><code class="objective-c">//核心方法：
/**
 修复打开链接Cookie丢失问题

 @param request 请求
 @return 一个fixedRequest
 */
- (NSURLRequest *)fixRequest:(NSURLRequest *)request
{
    NSMutableURLRequest *fixedRequest;
    if ([request isKindOfClass:[NSMutableURLRequest class]]) {
        fixedRequest = (NSMutableURLRequest *)request;
    } else {
        fixedRequest = request.mutableCopy;
    }
    //防止Cookie丢失
    NSDictionary *dict = [NSHTTPCookie requestHeaderFieldsWithCookies:[NSHTTPCookieStorage sharedHTTPCookieStorage].cookies];
    if (dict.count) {
        NSMutableDictionary *mDict = request.allHTTPHeaderFields.mutableCopy;
        [mDict setValuesForKeysWithDictionary:dict];
        fixedRequest.allHTTPHeaderFields = mDict;
    }
    return fixedRequest;
}

#pragma mark - WKNavigationDelegate 

- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler {

#warning important 这里很重要
    //解决Cookie丢失问题
    NSURLRequest *originalRequest = navigationAction.request;
    [self fixRequest:originalRequest];
    //如果originalRequest就是NSMutableURLRequest, originalRequest中已添加必要的Cookie，可以跳转
    //允许跳转
    decisionHandler(WKNavigationActionPolicyAllow);
    //可能有小伙伴，会说如果originalRequest是NSURLRequest，不可变，那不就添加不了Cookie了，是的，我们不能因为这个问题，不允许跳转，也不能在不允许跳转之后用loadRequest加载fixedRequest，否则会出现死循环，具体的，小伙伴们可以用本地的html测试下。

    NSLog(@&quot;%@&quot;, NSStringFromSelector(_cmd));
}

#pragma mark - WKUIDelegate

- (WKWebView *)webView:(WKWebView *)webView createWebViewWithConfiguration:(WKWebViewConfiguration *)configuration forNavigationAction:(WKNavigationAction *)navigationAction windowFeatures:(WKWindowFeatures *)windowFeatures {

#warning important 这里也很重要
    //这里不打开新窗口
    [self.webView loadRequest:[self fixRequest:navigationAction.request]];
    return nil;
}
</code></pre>
<p>最终的方法，已经附上。小伙伴们自行参考。同样需要你<strong>保证<code>sharedHTTPCookieStorage</code>中你的Cookie存在</strong>。</p>
<h3 id="解决上面3步都做了Cookie依然丢失"><a href="#解决上面3步都做了Cookie依然丢失" class="headerlink" title="解决上面3步都做了Cookie依然丢失"></a>解决上面3步都做了Cookie依然丢失</h3><p>看过上面的方法过后，小伙伴们应该记得最清楚的是<strong>保证<code>sharedHTTPCookieStorage</code>中你的Cookie存在</strong>。怎么保证呢？由于<strong><code>WKWebView</code>加载网页得到的<code>Cookie</code>会同步到<code>NSHTTPCookieStorage</code>中</strong>的特点，有时候你强行添加的<code>Cookie</code>会在同步过程中丢失。抓包（<a href="https://www.charlesproxy.com" target="_blank" rel="external">Mac推荐Charles</a>）你就会发现，点击一个链接时，<code>Request</code>的<code>header</code>中多了<code>Set-Cookie</code>字段，其实Cookie已经丢了。下面推荐笔者的解决方案，那就是把自己需要的<code>Cookie</code>主动保存起来，每次调用<code>[NSHTTPCookieStorage sharedHTTPCookieStorage].cookies</code>方法时，保证返回的数组中有自己需要的<code>Cookie</code>。下面上代码，用了<code>runtime</code>的<code>Method Swizzling</code>，详细代码，请参考<a href="https://github.com/DarkAngel7/Demos-WebViewDemo" target="_blank" rel="external">Demo</a>。</p>
<p>首先是在适当的时候，保存</p>
<pre><code class="objective-c">//比如登录成功，保存Cookie
NSArray *allCookies = [[NSHTTPCookieStorage sharedHTTPCookieStorage] cookies];
for (NSHTTPCookie *cookie in allCookies) {
    if ([cookie.name isEqualToString:DAServerSessionCookieName]) {
        NSDictionary *dict = [[NSUserDefaults standardUserDefaults] dictionaryForKey:DAUserDefaultsCookieStorageKey];
        if (dict) {
            NSHTTPCookie *localCookie = [NSHTTPCookie cookieWithProperties:dict];
            if (![cookie.value isEqual:localCookie.value]) {
                NSLog(@&quot;本地Cookie有更新&quot;);
            }
        }
        [[NSUserDefaults standardUserDefaults] setObject:cookie.properties forKey:DAUserDefaultsCookieStorageKey];
        [[NSUserDefaults standardUserDefaults] synchronize];
        break;
    }
}
</code></pre>
<p>在读取时，如果没有则添加</p>
<pre><code class="objective-c">@implementation NSHTTPCookieStorage (Utils)

+ (void)load
{
    class_methodSwizzling(self, @selector(cookies), @selector(da_cookies));
}

- (NSArray&lt;NSHTTPCookie *&gt; *)da_cookies
{
    NSArray *cookies = [self da_cookies];
    BOOL isExist = NO;
    for (NSHTTPCookie *cookie in cookies) {
        if ([cookie.name isEqualToString:DAServerSessionCookieName]) {
            isExist = YES;
            break;
        }
    }
    if (!isExist) {
        //CookieStroage中添加
        NSDictionary *dict = [[NSUserDefaults standardUserDefaults] dictionaryForKey:DAUserDefaultsCookieStorageKey];
        if (dict) {
            NSHTTPCookie *cookie = [NSHTTPCookie cookieWithProperties:dict];
            [[NSHTTPCookieStorage sharedHTTPCookieStorage] setCookie:cookie];
            NSMutableArray *mCookies = cookies.mutableCopy;
            [mCookies addObject:cookie];
            cookies = mCookies.copy;
        }
    }
    return cookies;
}

@end
</code></pre>
<p>当打开手机百度首页后，我们查看页面中的Cookie<img src="http://ww4.sinaimg.cn/large/006tNc79ly1ffgge4xfiqj31jk104tj9.jpg" alt="DB6E63BA-868D-4CD2-9B1B-AC4BD1368437"></p>
<p>其中第一个，是之前测试添加的，用来动态注入js。</p>
<pre><code class="objective-c">WKUserScript *newCookieScript = [[WKUserScript alloc] initWithSource:@&quot;document.cookie = &#39;DarkAngelCookie=DarkAngel;&#39;&quot; injectionTime:WKUserScriptInjectionTimeAtDocumentStart forMainFrameOnly:NO];
[controller addUserScript:newCookieScript];
</code></pre>
<p>第二个，就是真正有用的Cookie啦，这幅图用到了<code>Safari</code>调试，后面会讲到。通过上面的折腾，一般，就能够有效减少Cookie的丢失了。</p>
<h2 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h2><p>加载一般的页面，对比不出什么，这里我就测试下内存占用吧，同样一个html，分布看下内存占用。</p>
<p>UIWebView<img src="http://ww4.sinaimg.cn/large/006tNc79ly1ffggxn9b71j318q0gowhc.jpg" alt="C9A288B5-77EE-4FAF-8BAE-1F3E3AD7C86C"></p>
<p>WKWebView<img src="http://ww4.sinaimg.cn/large/006tNc79ly1ffggyx4o9wj31880gqgon.jpg" alt="A8AC12E1-DCDB-453A-AC24-30434485B287"></p>
<p>从页面UI元素上看，<code>WKWebView</code>还多个<code>barButtonItem</code>呢，这么简单个页，内存占用也小了3M，复杂的页面可想而知。</p>
<h2 id="各种坑"><a href="#各种坑" class="headerlink" title="各种坑"></a>各种坑</h2><p>虽然<code>WKWebView</code>真的很不错，但是它的坑，还是有很多的，下面简单说下。</p>
<h3 id="js-alert方法不弹窗"><a href="#js-alert方法不弹窗" class="headerlink" title="js alert方法不弹窗"></a>js alert方法不弹窗</h3><p>之前提过<code>WKUIDelegate</code>所有的方法都是<code>Optional</code>，但如果你不实现，它就会</p>
<blockquote>
<p> If you do not implement this method, the web view will behave as if the user selected the OK button.</p>
<pre><code class="objective-c"> - (void)webView:(WKWebView *)webView runJavaScriptAlertPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(void))completionHandler;
</code></pre>
</blockquote>
<p>OK，意思就是说，如果不实现，就什么都不发生，好吧，乖乖实现吧，实现了就能弹窗了。</p>
<h3 id="白屏问题"><a href="#白屏问题" class="headerlink" title="白屏问题"></a>白屏问题</h3><p>当WKWebView加载的网页占用内存过大时，会出现白屏现象。解决方案是</p>
<pre><code class="objective-c">/*! @abstract Invoked when the web view&#39;s web content process is terminated.
 @param webView The web view whose underlying web content process was terminated.
 */
- (void)webViewWebContentProcessDidTerminate:(WKWebView *)webView {
    [webView reload];    //刷新就好了
}
</code></pre>
<p>有时白屏，不会调用该方法，具体的解决方案是</p>
<blockquote>
<p>比如，最近遇到在一个高内存消耗的H5页面上 present 系统相机，拍照完毕后返回原来页面的时候出现白屏现象（拍照过程消耗了大量内存，导致内存紧张，WebContent Process 被系统挂起），但上面的回调函数并没有被调用。在WKWebView白屏的时候，另一种现象是 webView.titile 会被置空, 因此，可以在 viewWillAppear 的时候检测 webView.title 是否为空来 reload 页面。（出自<a href="http://mp.weixin.qq.com/s/rhYKLIbXOsUJC_n6dt9UfA" target="_blank" rel="external">WKWebView 那些坑</a>）</p>
</blockquote>
<h3 id="Cookie丢失"><a href="#Cookie丢失" class="headerlink" title="Cookie丢失"></a>Cookie丢失</h3><p>从一个登录状态的页面跳转到另一个页面，WTF，登录状态丢失了？什么鬼？其实上文中的<strong>Cookie管理</strong>一节，已经介绍过解决方案了，原因也就是<strong><code>WKWebView</code>加载请求时，不会同步<code>NSHTTPCookieStorage</code>中已有的<code>Cookie</code></strong>。如果偶尔还是会出现丢失登录状态的情况，那笔者只能说，再检查下自己的代码，找找原因，有好的解决方案，欢迎告知笔者。</p>
<h3 id="evaluateJavaScript-completionHandler-异步"><a href="#evaluateJavaScript-completionHandler-异步" class="headerlink" title="evaluateJavaScript:completionHandler:异步"></a>evaluateJavaScript:completionHandler:异步</h3><p>该方法是异步回调，这个一看方法的声明便知。可能有小伙伴就是需要同步获取返回值，有没有办法呢？答案是<strong>没有</strong>。</p>
<p>可能你会说用信号量<code>dispatch_semaphore_t</code>。好吧，可能你会这么写~</p>
<pre><code class="objective-c">__block id cookies;
dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);
[self.webView evaluateJavaScript:@&quot;document.cookie&quot; completionHandler:^(id _Nullable result, NSError * _Nullable error) {
    cookies = result;
    dispatch_semaphore_signal(semaphore);
}];
//等待三秒，接收参数
dispatch_semaphore_wait(semaphore, dispatch_time(DISPATCH_TIME_NOW, 3 * NSEC_PER_SEC));
//打印cookie，肯定为空，因为足足等了3s，dispatch_semaphore_signal都没有起作用
NSLog(@&quot;cookie的值为：%@&quot;, cookies);
</code></pre>
<p>笔者故意只等待了3s，如果你等待<code>DISPATCH_TIME_FOREVER</code>，恭喜你，程序不会Crash，但界面卡死了。笔者测试的结果是，<code>NSLog</code>的触发时间要早于<code>completionHandler</code>回调，不论你等多久，它都会打印null。所以当你永久等待时，就卡死了。这里的缘由，笔者不太清楚，有搞清楚的小伙伴可以帮忙指点一下，谢谢~</p>
<p>所以还是老实的接受异步回调吧，不要用信号来搞成同步，会卡死的。</p>
<h3 id="自定义contentInset刷新时页面跳动的bug"><a href="#自定义contentInset刷新时页面跳动的bug" class="headerlink" title="自定义contentInset刷新时页面跳动的bug"></a>自定义contentInset刷新时页面跳动的bug</h3><p>PM说毛玻璃好看，👌，so easy，于是我们在代码如敲下</p>
<pre><code class="objective-c">self.webView.scrollView.contentInset = UIEdgeInsetsMake(64, 0, 49, 0);
</code></pre>
<p>然后默默的微笑着点击了cmd + R，太简单了。然后看到了这样的画面</p>
<p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1ffgi7f2g9qg30ck0n9anq.gif" alt="new"></p>
<p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1ffghw4zwopj3068061wed.jpg" alt="timg"></p>
<p>是的，上面的方法在<code>UIWebView</code>中没毛病，可是在<code>WKWebView</code>中，就产生了刷新时页面跳动的bug。</p>
<p>这个坑，坑了我大半年之久，Apple的<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/WebKit/ObjC_classic/index.html" target="_blank" rel="external">Document</a>中没有记录，最终笔者在Apple开源的<a href="https://opensource.apple.com/source/WebKit2/" target="_blank" rel="external">WebKit2</a>的<a href="[https://opensource.apple.com/source/WebKit2/WebKit2-7603.1.30.0.34/ChangeLog-2014-10-07.auto.html](https://opensource.apple.com/source/WebKit2/WebKit2-7603.1.30.0.34/ChangeLog-2014-10-07.auto.html">ChangeLog</a>)中找到了答案。下面是官方人员的回答：</p>
<p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1ffghllqjz6j310w0ewagc.jpg" alt="A9018C2C-BB21-41A1-9A67-E6CCE2D75A0E"></p>
<p>厉害了，word哥，我选择狗带，居然还是私有Api。怎么整呢？</p>
<pre><code class="objective-c">self.webView.scrollView.contentInset = UIEdgeInsetsMake(64, 0, 49, 0);
//史诗级神坑，为何如此写呢？参考https://opensource.apple.com/source/WebKit2/WebKit2-7600.1.4.11.10/ChangeLog  
[self.webView setValue:[NSValue valueWithUIEdgeInsets:self.webView.scrollView.contentInset] forKey:@&quot;_obscuredInsets&quot;];    //kvc给WKWebView的私有变量_obscuredInsets设置值
</code></pre>
<p>这么写就OK了，通过KVC设置私有变量的值，笔者用了半年了，过Apple审核没问题，不用担心。如果这个能帮助到大家，不用感谢我~</p>
<h3 id="加载POST请求丢失RequestBody"><a href="#加载POST请求丢失RequestBody" class="headerlink" title="加载POST请求丢失RequestBody"></a>加载POST请求丢失RequestBody</h3><p>这个问题，没有直接的解决办法。问题的根源在于：</p>
<blockquote>
<p>在 webkit2 的设计里使用 MessageQueue 进行进程之间的通信，Network Process 会将请求 encode 成一个 Message,然后通过 IPC 发送给 App Process。出于性能的原因，encode 的时候 HTTPBody 和 HTTPBodyStream 这两个字段被丢弃掉了。</p>
<p>因此，<strong>如果通过 registerSchemeForCustomProtocol 注册了 http(s) scheme, 那么由 WKWebView 发起的所有 http(s)请求都会通过 IPC 传给主进程 NSURLProtocol 处理，导致 post 请求 body 被清空</strong>。</p>
<p>（出自<a href="http://mp.weixin.qq.com/s/rhYKLIbXOsUJC_n6dt9UfA" target="_blank" rel="external">WKWebView 那些坑</a>）</p>
</blockquote>
<p>参考 <a href="https://github.com/WebKit/webkit/blob/fe39539b83d28751e86077b173abd5b7872ce3f9/Source/WebKit2/Shared/mac/WebCoreArgumentCodersMac.mm#L61-L88" target="_blank" rel="external">Apple源码</a> 及 <a href="https://bugs.webkit.org/show_bug.cgi?id=138169" target="_blank" rel="external">bug report</a> 。</p>
<p>具体的解决办法，就是另辟蹊径，<a href="http://mp.weixin.qq.com/s/rhYKLIbXOsUJC_n6dt9UfA" target="_blank" rel="external">WKWebView 那些坑</a>中有介绍，这里笔者不再展开。</p>
<p>因为<code>WKWebView</code>被设计的使用场景，是用来当做浏览器，解决Native可以直接在App内浏览网页的问题。而浏览器浏览一个网站，怎么可能是POST请求呢？所以这个问题，笔者目前感受较小，有需要的小伙伴可以自行解决。</p>
<h3 id="NSURLProtocol问题"><a href="#NSURLProtocol问题" class="headerlink" title="NSURLProtocol问题"></a>NSURLProtocol问题</h3><p><code>WKWebView</code>不同于<code>UIWebView</code>，其实并不支持<code>NSURLProtocol</code>。如果想拦截，可以通过调用私有Api。</p>
<pre><code class="objective-c">+ [WKBrowsingContextController registerSchemeForCustomProtocol:]
</code></pre>
<p>此方法缺点也很多，笔者这里不推荐小伙伴使用，毕竟调用私有Api是Apple禁止的。况且，真的必须使用<code>NSURLProtocol</code>的话，还是用<code>UIWebView</code>吧。</p>
<h1 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h1><p>本文主要讲述了<code>WKWebView</code>的一些基础用法、OC与JS的交互，Cookie的管理，以及一些使用过程中的坑，旨在为没用过的小伙伴们详细介绍下。虽然它的坑很多，但是它的优点也有很多，我们应该敢于拥抱新事物，拥抱新知识。还在等什么？<code>WKWebView</code>赶快用起来吧~</p>
<p>下篇文章，将主要为小伙伴们介绍下如何用Safari调试，实际应用中一些需求如何实现，如何更好的与前端h5开发同学配合以及如何找出问题所在等。再见~</p>
<p>下篇文章：<a href="http://blog.darkangel7.com/2017/05/11/iOS中UIWebView与WKWebView、JavaScript与OC交互、Cookie管理看我就够（下）/">iOS中UIWebView与WKWebView、JavaScript与OC交互、Cookie管理看我就够（下）</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/006tNc79ly1fff1sa06wrj30sg0iwwi9.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; titl
    
    </summary>
    
    
      <category term="iOS技术分享" scheme="http://blog.darkangel7.com/tags/iOS%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>iOS中NSUserDefaults的黑科技</title>
    <link href="http://blog.darkangel7.com/2017/05/05/iOS%E4%B8%ADNSUserDefaults%E7%9A%84%E9%BB%91%E7%A7%91%E6%8A%80/"/>
    <id>http://blog.darkangel7.com/2017/05/05/iOS中NSUserDefaults的黑科技/</id>
    <published>2017-05-05T04:18:12.000Z</published>
    <updated>2017-05-05T09:24:15.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在iOS开发中，我们时常需要保存一些数据，或者希望在用户下次打开App时，依然可以保留一些设置等，比如<strong>主题设置</strong>、<strong>语言设置</strong>，那么我们一般会选择使用<code>NSUserDefaults</code>作为轻量级数据持久化方案。这里不对其他的数据持久化方案（如Plist、归档、Sqlite3、CoreData等）进行探讨，主要来介绍一下<code>NSUserDefaults</code>中的一些黑科技。</p>
<h1 id="NSUserDefaults简介"><a href="#NSUserDefaults简介" class="headerlink" title="NSUserDefaults简介"></a>NSUserDefaults简介</h1><p><code>NSUserDefaults</code>在Foundation框架中被定义，用来存储和读取一些轻量级数据。其本质是操作plist文件。</p>
<p>它比其他数据持久化方案的优点在于：</p>
<ul>
<li>轻量级。</li>
<li>方便快捷直接使用。</li>
<li>支持<code>NSData</code>, <code>NSString</code>, <code>NSNumber</code>, <code>NSDate</code>, <code>NSArray</code> and  <code>NSDictionary</code>。</li>
</ul>
<p>缺点在于：</p>
<ul>
<li>不适合大量数据。</li>
<li>无法存储自定义<code>model</code>。</li>
</ul>
<h1 id="黑科技"><a href="#黑科技" class="headerlink" title="黑科技"></a>黑科技</h1><p>一些<code>NSUserDefaults</code>最基础的用法，这里就不赘述了。说到黑科技，一般指的是鲜为人知而又十分厉害的技术。这里主要介绍两个黑科技。</p>
<h2 id="还原默认值"><a href="#还原默认值" class="headerlink" title="还原默认值"></a>还原默认值</h2><p>一般<code>NSUserDefaults</code>使用，都会保存一些自定义的Key和Value，其实这个不涉及还原默认值的问题。其实有些时候，是需要修改其中的系统默认值的。比如应用内切换中英文，就需要修改<code>AppleLanguages</code>的value。既然修改了系统默认值，怎么还原默认值呢？</p>
<p>我们先来看一下修改前的：</p>
<pre><code>po [NSUserDefaults standardUserDefaults].dictionaryRepresentation

{
    ...
    AppleLanguages =     (
        en,
        &quot;zh-Hans-US&quot;
    );
    AppleLocale = &quot;en_US&quot;;
    ...
}
</code></pre><p>可以看到<code>AppleLanguages</code>对应的是一个数组，如果我们在App内想切换成中文，执行</p>
<pre><code class="objective-c">[[NSUserDefaults standardUserDefaults] setObject:@[@&quot;zh-Hans&quot;] forKey:@&quot;AppleLanguages&quot;];
</code></pre>
<p>再次看下修改后</p>
<pre><code>po [NSUserDefaults standardUserDefaults].dictionaryRepresentation

{
    ...
    AppleLanguages =     (
        zh-Hans
    );
    AppleLocale = &quot;en_US&quot;;
    ...
}
</code></pre><p>好吧，这个<code>AppleLanguages</code>字段的值已经被记录了。这时候，kill客户端，重新打开客户端，发现，这个值肯定不会变。那么如果这个时候用户在系统设置中切换到了日语，那么我想在客户端中通过<strong>跟随手机系统</strong>的设置，还原到日语，该怎么办呢？</p>
<p>或许你会想到记录初始值，只要提前记录，在还原时再set回去就可以了。嗯~没毛病，可是在什么地方什么时候记录初始值呢？这个<code>AppleLanguages</code>字段其实就是系统的语言默认值，你已经把它改过了，如果在你改过之后用户又修改了系统语言，那你是拿不到新默认值的，所以这条路是走不通的。</p>
<p>那怎么实现还原默认值呢？看下这个方法：</p>
<pre><code>/*!
 -setObject:forKey: immediately stores a value (or removes the value if nil is passed as the value) for the provided key in the search list entry for the receiver&#39;s suite name in the current user and any host, then asynchronously stores the value persistently, where it is made available to other processes.
 */
- (void)setObject:(nullable id)value forKey:(NSString *)defaultName;
</code></pre><p>这个方法Document中并没有描述过多，基本都是在强调<code>value</code>必须是<code>NSData</code>, <code>NSString</code>, <code>NSNumber</code>, <code>NSDate</code>, <code>NSArray</code> and  <code>NSDictionary</code>中的一种，且<code>NSArray</code> and  <code>NSDictionary</code>中的值也必须是Plist支持的类型。在注释中有强调，<code>removes the value if nil is passed as the value</code>，传nil等同于删除这个键值对。</p>
<pre><code>/// -removeObjectForKey: is equivalent to -[... setObject:nil forKey:defaultName]
- (void)removeObjectForKey:(NSString *)defaultName;
</code></pre><p>其实这里才是关键</p>
<pre><code>[[NSUserDefaults standardUserDefaults] setObject:nil forKey:@&quot;AppleLanguages&quot;];
//or
[[NSUserDefaults standardUserDefaults] removeObjectForKey:@&quot;AppleLanguages&quot;];
</code></pre><p>然后再次</p>
<pre><code>po [NSUserDefaults standardUserDefaults].dictionaryRepresentation

{
    ...
    AppleLanguages =     (
        en,
        &quot;zh-Hans-US&quot;
    );
    AppleLocale = &quot;en_US&quot;;
    ...
}
</code></pre><p>你会发现，WTF，居然这个字段还存在，且还原成了默认值，厉害了word哥。本方法是本人历经各种坑之后发现的，且官方文档中没有任何提及，只能说Apple爸爸任性。</p>
<h2 id="巧用SuiteName"><a href="#巧用SuiteName" class="headerlink" title="巧用SuiteName"></a>巧用SuiteName</h2><pre><code>- (nullable instancetype)initWithSuiteName:(nullable NSString *)suitename NS_AVAILABLE(10_9, 7_0) NS_DESIGNATED_INITIALIZER;
</code></pre><p>这个方法，想必各位不会陌生，在跨App间通信或者主App与Extension共享数据，都会用到，一般配合使用的是<strong>App Groups</strong>。</p>
<h3 id="App-Groups数据共享"><a href="#App-Groups数据共享" class="headerlink" title="App Groups数据共享"></a>App Groups数据共享</h3><p>在App Groups中使用，一般两个App都需要加入同一个Group。<img src="http://ww1.sinaimg.cn/large/006tNbRwly1ffajfof2qdj30x00cqjsl.jpg" alt="">然后在两个App分别使用</p>
<pre><code class="objective-c">- (NSUserDefaults *)userDefaults
{
    return [[NSUserDefaults alloc] initWithSuiteName:@&quot;group.urwork.autosignin&quot;];    //name需要是Group的id
}
</code></pre>
<p>来存储和读取数据，即可实现数据共享。</p>
<h3 id="超微型简单方便易用数据库"><a href="#超微型简单方便易用数据库" class="headerlink" title="超微型简单方便易用数据库"></a>超微型简单方便易用数据库</h3><p>这里，其实主要介绍一下<code>initWithSuiteName:</code>的另一个用途，我称之为<strong>超微型简单方便易用数据库</strong>。</p>
<p><strong>需求</strong>：后台同学最近太忙（😳这不是理由），需要客户端同学临时开发一个本地的浏览历史功能。简单的说就是在客户端本地保存每个用户浏览的文章记录。</p>
<p><strong>吐糟</strong>：好吧，时间紧，任务重，功能先上线，后续再优化已经是一个习惯了😳。</p>
<p><strong>实现方案</strong>：简单，本地存个字典（或者Plist文件），每个key是一个用户id，value是一个数组，数组里的每个元素是一个字典，这个字典里有<code>articleId</code>、<code>title</code>、<code>imgUrl</code>、<code>...</code>。结构大概是这样：</p>
<pre><code>{
  &quot;10086&quot; : [
    {
      &quot;articleId&quot; : 1,
      &quot;imgUrl&quot; : &quot;https://img.xxx.com/abcdefg.png&quot;,
      &quot;title&quot; : &quot;中国历史&quot;,
      ...
    },
    {
      &quot;articleId&quot; : 2,
      &quot;imgUrl&quot; : &quot;https://img.xxx.com/abcdefg.png&quot;,
      &quot;title&quot; : &quot;中国教育&quot;,
      ...
    },
    ...
  ],
  &quot;10087&quot; : [
    {
      &quot;articleId&quot; : 2,
      &quot;imgUrl&quot; : &quot;https://img.xxx.com/abcdefg.png&quot;,
      &quot;title&quot; : &quot;中国教育&quot;,
      ...
    },
    ...
  ]
}
</code></pre><p>看起来OK，但是小伙伴们，性能问题还是要考虑的。我想获取某个用户的浏览历史，需要把文件整体读到内存中，然后用<code>dict[@&quot;10086&quot;]</code>的方法，得到这个用户的浏览历史<code>Array</code>，用户少还好，多了，每次读取的IO操作会很耗时，对性能有影响。</p>
<p>可能你会说用数据库啊什么的，当然可以，但是又是需要依赖一堆第三方，还要写好多代码，创建好多类。我就是想简单实现一下，有没有更好的方法呢？当然有，<strong>超微型简单方便易用数据库</strong>。</p>
<p>每个用户都可以用一个<code>NSUserDefaults</code>来代替，每个用户的浏览历史，可以直接用<code>setObject:forKey:</code>的方式来存储，如：</p>
<pre><code class="objective-c">//这个跟App Groups没有关系
//已有则读取，没有则创建
NSUserDefaults *userDefaults = [[NSUserDefaults alloc] initWithSuiteName:@&quot;10086&quot;];
//存储
[userDefaults setObject:history forKey:@&quot;ArticleBrowsingHistory&quot;];
//读取
NSArray *history = [userDefaults objectForKey:@&quot;ArticleBrowsingHistory&quot;];
</code></pre>
<p>所有用户相对独立，每个用户是一个plist文件，在沙盒目录<code>/Library/Preferences/</code>中，<img src="http://ww2.sinaimg.cn/large/006tNbRwly1ffalfnmhudj30z007kab7.jpg" alt="">想删除也很容易，直接删除这个文件即可。</p>
<p>其实这个<strong>超微型简单方便易用数据库</strong>还可以实现好多功能，看你怎么操作了。如果你的App没有后台，不同用户的主题设置、语言设置可能不同，都可以通过这个来存储。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实很多我们很常用的东西都有很多我们未发掘出的用途，生活也是同样，学会发现，一切会更美好。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在iOS开发中，我们时常需要保存一些数据，或者希望在用户下次打开App时，依然可以保留一些设置等，比如&lt;strong&gt;主题设置&lt;/stron
    
    </summary>
    
    
      <category term="iOS技术分享" scheme="http://blog.darkangel7.com/tags/iOS%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>在iOS App内优雅的动态切换语言</title>
    <link href="http://blog.darkangel7.com/2017/05/04/%E5%9C%A8iOSApp%E5%86%85%E4%BC%98%E9%9B%85%E7%9A%84%E5%8A%A8%E6%80%81%E5%88%87%E6%8D%A2%E8%AF%AD%E8%A8%80/"/>
    <id>http://blog.darkangel7.com/2017/05/04/在iOSApp内优雅的动态切换语言/</id>
    <published>2017-05-04T03:46:56.000Z</published>
    <updated>2017-05-05T09:28:31.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>随着公司业务的发展，App版本的迭代，相信不少App都需要英文化（国际化）。App英文化，不外乎这三点：</p>
<ol>
<li>纯代码中引用的strings国际化；</li>
<li>Storyboard/Xib国际化；</li>
<li>Info.plist国际化。</li>
</ol>
<p>具体这三种分别如何操作，怎么国际化，这里不再赘述。一般App做了国际化，那么在用户切换手机系统Settings里的Language时，App就会切换成对应的语言（前提是做过该语言国际化）。那么如果想实现<strong>微博</strong>和<strong>微信</strong>等App，在App内部实现切换语言，应该怎么做呢？如何做，才能更加优雅的动态切换语言呢？</p>
<p>下面，讲一讲如何在iOS App内优雅的动态切换语言。</p>
<h1 id="调研"><a href="#调研" class="headerlink" title="调研"></a>调研</h1><p>如果有相关需求，一般成熟的App都会怎么做呢？这里我们来看一下<strong>微博</strong>和<strong>微信</strong>。</p>
<p><strong>微博</strong>：</p>
<p><img src="http://ww3.sinaimg.cn/large/006tKfTcly1ff9jfo5a8ig306y0cctz0.gif" alt=""></p>
<p><strong>微信</strong>：</p>
<p><img src="http://ww1.sinaimg.cn/large/006tKfTcly1ff9d5ezj9jg30680b3kif.gif" alt=""></p>
<p>对比一下可以看出，微博整体的效果比微信好很多，丝滑流畅。</p>
<p><strong><em>这里注意一下细节</em></strong>：我在微博的个人中心是故意上滑了一下，然后点击进入设置，进行语言切换，可以看到切换时很自然，然后返回个人中心时，页面<code>scrollView</code>的<code>contentOffset</code>并没有发生变化，由此可以推测：</p>
<p><strong><u>微博的思路是，在切换语言时，发送通知<code>NSNotification</code>，所有的UI控件监听通知，然后在适当的时候刷新UI</u></strong>。那么其实这么写，需要做的东西很多，或是通过Base类来实现，或是通过<code>runtime</code>实现，总之<code>Button</code>、<code>Label</code>、<code>TextField</code>等等都需要有一套统一的更新机制，可能不是一个最简单的办法。</p>
<p><strong><u>而微信切换的方案是，刷新<code>keyWindow</code>的<code>rootViewController</code>，然后跳转到设置页，所以你会看到切换语言的一瞬间界面出现匪夷所思的bug，如下图</u></strong></p>
<p><img src="http://ww1.sinaimg.cn/large/006tKfTcly1ff9iduf60aj306y0cbjrm.jpg" alt=""></p>
<p>其实微信的方案是个最简单的方案，只不过没有处理好这个小系统bug。</p>
<h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><h2 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h2><h3 id="NSBundle"><a href="#NSBundle" class="headerlink" title="NSBundle"></a>NSBundle</h3><p>其实大家应该知道，无论是代码还是Storyboard/Xib，显示的国际化字符串都会走这个方法，传入一个<code>key</code>，获取<code>localizedString</code>。</p>
<p><code>NSBundle</code>的方法：</p>
<pre><code class="objective-c">- (NSString *)localizedStringForKey:(NSString *)key value:(nullable NSString *)value table:(nullable NSString *)tableName;
</code></pre>
<p>比如我们常用的宏<code>NSLocalizedString(@&quot;done&quot;, nil)</code></p>
<pre><code class="objective-c">#define NSLocalizedString(key, comment) \
        [NSBundle.mainBundle localizedStringForKey:(key) value:@&quot;&quot; table:nil]
</code></pre>
<p>那么为何，系统切换语言的时候，此方法返回的就是对应语言（前提做了该语言的国际化）的字符串呢？原因在是哪个<code>bundle</code>调用了这个方法，一般默认的都是<code>NSBundle.mainBundle</code>这个对象。</p>
<pre><code> po [NSBundle allBundles]

&lt;__NSArrayI 0x608000052f60&gt;(
NSBundle &lt;/Users/DarkAngel/Library/Developer/CoreSimulator/Devices/CF831783-E4A6-4EC2-AB99-E04304331C3A/data/Containers/Bundle/Application/B391ED77-F57B-4B5E-9E53-CFD1245583D8/LanguageSettingsDemo.app/en.lproj&gt; (not yet loaded),
NSBundle &lt;/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/Frameworks/UIKit.framework/Artwork.bundle&gt; (not yet loaded),
DABundle &lt;/Users/DarkAngel/Library/Developer/CoreSimulator/Devices/CF831783-E4A6-4EC2-AB99-E04304331C3A/data/Containers/Bundle/Application/B391ED77-F57B-4B5E-9E53-CFD1245583D8/LanguageSettingsDemo.app&gt; (loaded)
)
</code></pre><p>可以看到有默认加载的bundle，还有个没加载的en bundle。所以，切换语言，其实只要切换了<code>bundle</code>对象，就可以让这个<code>bundle</code>根据<code>key</code>返回不同的<code>localizedString</code>。</p>
<h3 id="NSUserDefaults"><a href="#NSUserDefaults" class="headerlink" title="NSUserDefaults"></a>NSUserDefaults</h3><p>其实语言设置，只要修改<code>AppleLanguages</code>对应的值就好了。这样才能加载正确语言的<code>Storyboard/Xib</code>，以及一些<code>resources</code>(图片之类的)。</p>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>方案其实很简单，每次切换语言，把用户选择的语言保存在本地，同时更改<code>bundle</code>对象，然后刷新页面就可以了。</p>
<p><img src="http://ww2.sinaimg.cn/large/006tKfTcly1ff9ji4gz3kg306y0cce09.gif" alt=""></p>
<h2 id="技术细节"><a href="#技术细节" class="headerlink" title="技术细节"></a>技术细节</h2><h3 id="保存用户设置"><a href="#保存用户设置" class="headerlink" title="保存用户设置"></a>保存用户设置</h3><p>很简单，保存在<code>NSUserDefaults</code>里。</p>
<p>这里需要说明的是<strong>跟随手机系统</strong>，即清除用户自定义设置，只需要将<code>AppleLanguages</code>字段设为<code>nil</code>即可。</p>
<p>但是当<code>AppleLanguages</code>字段设为nil，你再去获取它的值时，会发现他已经变成了系统语言的默认值。这里可以参考<a href="http://blog.darkangel7.com/2017/05/05/iOS中NSUserDefaults的黑科技/">这篇文章</a>。</p>
<p>.h</p>
<pre><code class="objective-c">/**
 设置类
 */
@interface UWConfig : NSObject
/**
 用户自定义使用的语言，当传nil时，等同于resetSystemLanguage
 */
@property (class, nonatomic, strong, nullable) NSString *userLanguage;
/**
 重置系统语言
 */
+ (void)resetSystemLanguage;
@end
</code></pre>
<p>.m</p>
<pre><code class="objective-c">#import &quot;UWConfig.h&quot;

static NSString *const UWUserLanguageKey = @&quot;UWUserLanguageKey&quot;;
#define STANDARD_USER_DEFAULT  [NSUserDefaults standardUserDefaults]

@implementation UWConfig
+ (void)setUserLanguage:(NSString *)userLanguage
{
    //跟随手机系统
    if (!userLanguage.length) {
        [self resetSystemLanguage];
        return;
    }
    //用户自定义
    [STANDARD_USER_DEFAULT setValue:userLanguage forKey:UWUserLanguageKey];
    [STANDARD_USER_DEFAULT setValue:@[userLanguage] forKey:@&quot;AppleLanguages&quot;];
    [STANDARD_USER_DEFAULT synchronize];
}

+ (NSString *)userLanguage
{
    return [STANDARD_USER_DEFAULT valueForKey:UWUserLanguageKey];
}

/**
 重置系统语言
 */
+ (void)resetSystemLanguage
{
    [STANDARD_USER_DEFAULT removeObjectForKey:UWUserLanguageKey];
    [STANDARD_USER_DEFAULT setValue:nil forKey:@&quot;AppleLanguages&quot;];
    [STANDARD_USER_DEFAULT synchronize];
}

@end
</code></pre>
<p>在需要的地方调用即可，如</p>
<pre><code class="objective-c">   if (indexPath.row == 0) {
        [UWConfig setUserLanguage:nil];
    } else if (indexPath.row == 1) {
        [UWConfig setUserLanguage:@&quot;zh-Hans&quot;];
    } else {
        [UWConfig setUserLanguage:@&quot;en&quot;];
    }
</code></pre>
<h3 id="切换Bundle"><a href="#切换Bundle" class="headerlink" title="切换Bundle"></a>切换Bundle</h3><p>当需要展示内容时，才需要用到<code>bundle</code>，我们要手动切换<code>bundle</code>对象，就用到了这几个方法：</p>
<pre><code class="objective-c">+ (nullable instancetype)bundleWithPath:(NSString *)path;
- (nullable instancetype)initWithPath:(NSString *)path NS_DESIGNATED_INITIALIZER;

+ (nullable instancetype)bundleWithURL:(NSURL *)url NS_AVAILABLE(10_6, 4_0);
- (nullable instancetype)initWithURL:(NSURL *)url NS_AVAILABLE(10_6, 4_0);
</code></pre>
<p>这里直接上代码</p>
<p>.h</p>
<pre><code class="objective-c">@interface NSBundle (UWUtils)

+ (BOOL)isChineseLanguage;

+ (NSString *)currentLanguage;

@end
</code></pre>
<p>.m</p>
<pre><code class="objective-c">#import &quot;NSBundle+UWUtils.h&quot;

@interface UWBundle : NSBundle

@end

@implementation NSBundle (UWUtils)

+ (BOOL)isChineseLanguage
{
    NSString *currentLanguage = [self currentLanguage];
    if ([currentLanguage hasPrefix:@&quot;zh-Hans&quot;]) {
        return YES;
    } else {
        return NO;
    }
}

+ (NSString *)currentLanguage
{
    return [UWConfig userLanguage] ? : [NSLocale preferredLanguages].firstObject;
}

+ (void)load
{
    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{
        //动态继承、交换，方法类似KVO，通过修改[NSBundle mainBundle]对象的isa指针，使其指向它的子类UWBundle，这样便可以调用子类的方法；其实这里也可以使用method_swizzling来交换mainBundle的实现，来动态判断，可以同样实现。
        object_setClass([NSBundle mainBundle], [UWBundle class]);
    });
}

@end

@implementation UWBundle

- (NSString *)localizedStringForKey:(NSString *)key value:(NSString *)value table:(NSString *)tableName
{
    if ([UWBundle uw_mainBundle]) {
        return [[UWBundle uw_mainBundle] localizedStringForKey:key value:value table:tableName];
    } else {
        return [super localizedStringForKey:key value:value table:tableName];
    }
}

+ (NSBundle *)uw_mainBundle
{
    if ([NSBundle currentLanguage].length) {
        NSString *path = [[NSBundle mainBundle] pathForResource:[NSBundle currentLanguage] ofType:@&quot;lproj&quot;];
        if (path.length) {
            return [NSBundle bundleWithPath:path];
        }
    }
    return nil;
}

@end
</code></pre>
<p>这里涉及到了<code>runtime</code>的使用，代码中有注释，这里就不展开了。</p>
<h3 id="刷新页面"><a href="#刷新页面" class="headerlink" title="刷新页面"></a>刷新页面</h3><p>用微信的思路，简单化，不必要处理很多，我们只要替换<code>keyWindow</code>的<code>rootViewController</code>就好，同时解决微信的bug。</p>
<pre><code class="objective-c">    UITabBarController *tbc = [[UIStoryboard storyboardWithName:@&quot;Main&quot; bundle:[NSBundle mainBundle]] instantiateInitialViewController];
    //我这里的storyboard为了便于多人合作，这里只包含根tabBarController和多个nvc，每个nvc只有自己的rootViewController
    //跳转到个人中心
    tbc.selectedIndex = 4;
    //创建设置页面
    UWSettingViewController *vc1 = [[UIStoryboard storyboardWithName:@&quot;Main&quot; bundle:[NSBundle mainBundle]] instantiateViewControllerWithIdentifier:NSStringFromClass([UWSettingViewController class])];
    vc1.hidesBottomBarWhenPushed = YES;
    //创建语言切换页
    UWLanguageSettingsViewController *vc2 = [[UIStoryboard storyboardWithName:@&quot;Main&quot; bundle:[NSBundle mainBundle]] instantiateViewControllerWithIdentifier:NSStringFromClass([UWLanguageSettingsViewController class])];
    vc2.hidesBottomBarWhenPushed = YES;
    UINavigationController *nvc = tbc.selectedViewController;
    //备用
    NSMutableArray *vcs = nvc.viewControllers.mutableCopy;
    [vcs addObjectsFromArray:@[vc1, vc2]];
    //解决奇怪的动画bug。异步执行
    dispatch_async(dispatch_get_main_queue(), ^{
        //注意刷新rootViewController的时机，在主线程异步执行
        //先刷新rootViewController
        [UIApplication sharedApplication].keyWindow.rootViewController = tbc;
        //然后再给个人中心的nvc设置viewControllers
        nvc.viewControllers = vcs;
        //一些UI提示，可以提供更友好的用户交互（也可以删掉）
        [UWProgressHUD showLoadingWithMessage:NSLocalizedString(UWSettingMessage, nil)];
        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(.5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
            [UWProgressHUD dismiss];
        });
    });
</code></pre>
<p>整体下来，就可以实现在App内优雅的切换语言。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实在实践过程中，坑还是很多的，欢迎提问。</p>
<p>下面附上个简单的<a href="https://github.com/DarkAngel7/Demos-LanguageSettingsDemo/" target="_blank" rel="external">Demo</a>，是上面说的简化版本，大家有需要可以下载看下。里面有小福利哦，慢慢找吧~</p>
<p>最后，<a href="https://itunes.apple.com/cn/app/you-ke-gong-chang/id1034170822?mt=8" target="_blank" rel="external">优客工场</a>欢迎您。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;随着公司业务的发展，App版本的迭代，相信不少App都需要英文化（国际化）。App英文化，不外乎这三点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;纯代码中
    
    </summary>
    
    
      <category term="iOS技术分享" scheme="http://blog.darkangel7.com/tags/iOS%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>Jenkins部署MacOS Slave实现持续集成(iOS)</title>
    <link href="http://blog.darkangel7.com/2017/04/28/Jenkins%E9%83%A8%E7%BD%B2MacOS%20Slave%E5%AE%9E%E7%8E%B0%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90(iOS)/"/>
    <id>http://blog.darkangel7.com/2017/04/28/Jenkins部署MacOS Slave实现持续集成(iOS)/</id>
    <published>2017-04-28T10:49:16.000Z</published>
    <updated>2017-05-04T04:30:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>解决Linux服务器上的Jenkins无法构建Xcode工程</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于Linux服务器无法安装Xcode，所以Jenkins无法通过shell来调用xcodebuild、xcrun等命令来构建Xcode工程，因此无法持续集成，敏捷开发。下面介绍一种配置Jenkins节点的方式，来实现Linux上的Jenkins构建Xcode工程，并上传ipa到蒲公英pgyer来进行测试。</p>
<h2 id="一、配置MacOS-Slave"><a href="#一、配置MacOS-Slave" class="headerlink" title="一、配置MacOS Slave"></a>一、配置MacOS Slave</h2><p>Jenkins有个强大的功能，配置Slave(奴隶)服务器，来实现分布式部署构建。具体步骤如下：</p>
<h3 id="1-配置Mac电脑。"><a href="#1-配置Mac电脑。" class="headerlink" title="1. 配置Mac电脑。"></a>1. 配置Mac电脑。</h3><p>在<strong>系统偏好设置</strong> &gt; <strong>共享</strong> 中开启 <strong>远程登录</strong>，如下图：<br><img src="https://ww3.sinaimg.cn/large/006tNc79ly1ff2hls2iauj31140tidjg.jpg" alt=""> </p>
<h3 id="2-创建节点。"><a href="#2-创建节点。" class="headerlink" title="2. 创建节点。"></a>2. 创建节点。</h3><p>Jenkins &gt; 系统管理 &gt;  管理节点 &gt; 新建节点，输入节点名称，记得勾选 <code>Permanent Agent</code>，点击OK。</p>
<h3 id="3-配置节点。"><a href="#3-配置节点。" class="headerlink" title="3. 配置节点。"></a>3. 配置节点。</h3><p><img src="https://ww2.sinaimg.cn/large/006tNc79ly1ff2hfwxx8ej31eg0ts0wt.jpg" alt="">其中要保证<code>/User/Shared/Jenkins/</code>目录的权限为ssh链接的用户可读写。</p>
<p>Host是Mac的ip地址，Credentials是ssh登录Mac时需要的账户和密码。可以添加一个</p>
<p><img src="https://ww4.sinaimg.cn/large/006tNc79ly1ff2hhcg0f1j31gq0r842o.jpg" alt=""></p>
<p><strong>下面的部分很重要</strong>：<img src="https://ww2.sinaimg.cn/large/006tNc79ly1ff2hiwj7mpj31gs0p4dj8.jpg" alt=""></p>
<p>PATH环境变量，需要在Mac上通过</p>
<pre><code>echo $PATH
/opt/iOSOpenDev/bin:/opt/local/bin:/opt/local/sbin:/opt/local/bin:/opt/local/sbin:/opt/local/bin:/opt/local/sbin:/opt/local/bin:/opt/local/sbin:/opt/local/bin:/opt/local/sbin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/opt/local/bin:/opt/local/sbin/
</code></pre><p>获取，然后copy过去。</p>
<p>Keychains and Provisioning Profiles路径要填写正确。没有这个选项的安装<a href="http://wiki.jenkins-ci.org/display/JENKINS/Keychains+and+Provisioning+Profiles+Plugin" target="_blank" rel="external">Keychains and Provisioning Profiles Management</a>插件。</p>
<h3 id="4-最后保存。"><a href="#4-最后保存。" class="headerlink" title="4. 最后保存。"></a>4. 最后保存。</h3><p>如果看到</p>
<p><img src="https://ww2.sinaimg.cn/large/006tNc79ly1ff2hwlrqw8j30e203uglm.jpg" alt=""></p>
<p>即添加Mac Slave成功，且Mac Slave在线。若连不上，请反复确认<strong>远程工作目录</strong>的权限。</p>
<h2 id="二、配置Jenkins系统设置。"><a href="#二、配置Jenkins系统设置。" class="headerlink" title="二、配置Jenkins系统设置。"></a>二、配置Jenkins系统设置。</h2><h3 id="1-上传证书和描述文件。"><a href="#1-上传证书和描述文件。" class="headerlink" title="1. 上传证书和描述文件。"></a>1. 上传证书和描述文件。</h3><p>在 <strong>Jenkins</strong> &gt; <strong>系统管理</strong> &gt; <strong>Keychains and Provisioning Profiles Management</strong>中上传打包用的证书和描述文件。如下图：</p>
<p><img src="https://ww4.sinaimg.cn/large/006tNc79ly1ff2jcabj18j31kw0tijyh.jpg" alt=""></p>
<p><img src="https://ww2.sinaimg.cn/large/006tNc79ly1ff2jclndwnj31jy0siwic.jpg" alt=""></p>
<p>保存。</p>
<h3 id="2-在-Jenkins-gt-系统管理-gt-系统设置（全局设置）中设置："><a href="#2-在-Jenkins-gt-系统管理-gt-系统设置（全局设置）中设置：" class="headerlink" title="2. 在 Jenkins &gt; 系统管理 &gt; 系统设置（全局设置）中设置："></a>2. 在 <strong>Jenkins</strong> &gt; <strong>系统管理</strong> &gt; <strong>系统设置</strong>（全局设置）中设置：</h3><p><img src="https://ww1.sinaimg.cn/large/006tNc79ly1ff2j6764qgj31ei0t6adx.jpg" alt=""></p>
<p>很关键。<strong>Keychain</strong>的路径和密码需要填写Mac中登录用户的密码。</p>
<h3 id="3-在-Jenkins-gt-系统管理-gt-Configure-Global-Security-中配置："><a href="#3-在-Jenkins-gt-系统管理-gt-Configure-Global-Security-中配置：" class="headerlink" title="3. 在 Jenkins &gt; 系统管理 &gt; Configure Global Security 中配置："></a>3. 在 <strong>Jenkins</strong> &gt; <strong>系统管理</strong> &gt; <strong>Configure Global Security</strong> 中配置：</h3><p><img src="https://ww2.sinaimg.cn/large/006tNc79ly1ff2j8ffcsrj31jw0ckjt4.jpg" alt=""></p>
<p>开启Safe HTML。</p>
<h2 id="三、配置iOS项目。"><a href="#三、配置iOS项目。" class="headerlink" title="三、配置iOS项目。"></a>三、配置iOS项目。</h2><h3 id="1-安装插件。"><a href="#1-安装插件。" class="headerlink" title="1. 安装插件。"></a>1. 安装插件。</h3><p>安装 <code>build-name-setter</code>、<code>description setter plugin</code>插件。</p>
<h3 id="2-Jenkins-gt-新建。"><a href="#2-Jenkins-gt-新建。" class="headerlink" title="2. Jenkins &gt; 新建。"></a>2. <strong>Jenkins</strong> &gt; <strong>新建</strong>。</h3><p><img src="https://ww2.sinaimg.cn/large/006tNc79ly1ff2iw797sjj318q0vidm6.jpg" alt=""></p>
<h3 id="3-General"><a href="#3-General" class="headerlink" title="3. General."></a>3. <strong>General</strong>.</h3><p><img src="https://ww3.sinaimg.cn/large/006tNc79ly1ff2jedt21qj31kw0u2afo.jpg" alt=""></p>
<p>这里添加了参数化构建过程，为了在每次Build时，可以填写更新说明，所以这里天添加了名为<code>News</code>的参数，当用户构建时填写了内容，可以在之后的脚本中通过<code>${News}</code>来获取<code>News</code>的值。</p>
<p><img src="https://ww1.sinaimg.cn/large/006tNc79ly1ff2jf005ogj31kw0o1q5k.jpg" alt=""></p>
<p>这里指定Mac Slave服务器作为构建Xcode工程的Slave服务器，Xcode打包构建全部交给这个节点（Slave服务器）来完成。</p>
<p><img src="https://ww1.sinaimg.cn/large/006tNc79ly1ff2jfc0bfij31kw0d2jsv.jpg" alt=""></p>
<h3 id="4-源码管理。"><a href="#4-源码管理。" class="headerlink" title="4. 源码管理。"></a>4. 源码管理。</h3><p><img src="https://ww4.sinaimg.cn/large/006tNc79ly1ff2jh0iaijj31jk0uk41x.jpg" alt=""></p>
<p>这里填写本地或者远程的代码仓库（如gitlab或者git）。下面的Branch填写指定分支。</p>
<h3 id="5-构建触发器。"><a href="#5-构建触发器。" class="headerlink" title="5. 构建触发器。"></a>5. 构建触发器。</h3><p>这里暂时不设置，设置了可以自动化测试，和其他脚本配合使用。</p>
<h3 id="6-构建环境。"><a href="#6-构建环境。" class="headerlink" title="6. 构建环境。"></a>6. 构建环境。</h3><p><img src="https://ww1.sinaimg.cn/large/006tNc79ly1ff2jqxdzccj31kw0txq9d.jpg" alt=""></p>
<p><img src="https://ww3.sinaimg.cn/large/006tNc79ly1ff2jssknawj31kw0pnn2s.jpg" alt=""></p>
<p>把之前上传的证书和描述文件添加上。</p>
<p>设置Build名称，这里添加了自定义名称。注意，高级里面只勾选第一个，不要勾选 <code>Set build name after build ends</code>，否则会报错。</p>
<h3 id="7-构建"><a href="#7-构建" class="headerlink" title="7. 构建"></a>7. 构建</h3><p><img src="https://ww2.sinaimg.cn/large/006tNc79ly1ff2jwre537j31kw0pygr0.jpg" alt=""></p>
<p>这里使用的脚本。</p>
<pre><code>export LANG=&quot;en_US.UTF-8&quot;

security -v unlock-keychain -p &quot;yourpassword&quot;

ipa_name=&quot;URWork_iOS_beta&quot;
build_path=&quot;${WORKSPACE}/build/&quot;
fastlane gym --workspace URWorkClient.xcworkspace --scheme URWorkClient --clean --configuration Beta --export_method ad-hoc --output_name ${ipa_name} --output_directory ${build_path}

curl -F &quot;file=@${build_path}${ipa_name}.ipa&quot; \
-F &quot;uKey=yourUKey&quot; \
-F &quot;_api_key=yourApiKey&quot; \
-F &quot;updateDescription=${News}&quot; \
https://www.pgyer.com/apiv1/app/upload
</code></pre><h4 id="最重要、最重要、最重要："><a href="#最重要、最重要、最重要：" class="headerlink" title="最重要、最重要、最重要："></a><strong>最重要、最重要、最重要：</strong></h4><p>Linux服务器上的Jenkins调用Mac Slave时，是通过之前设置的<strong>SSH</strong>登录的方式，而Apple为了安全，在ssh登录时，是不允许读取<strong>Keychains</strong>（钥匙串）的，所以 <code>security -v unlock-keychain -p &quot;yourpassword&quot;</code>这行命令就很重要了。在构建打包前，先解锁Keychains。</p>
<p>当然这里 <strong>fastlane</strong> 已经提前通过<strong>Homebrew</strong>安装好了，这里不再赘述。</p>
<blockquote>
<p><em>整体脚本的流程是，先解锁Keychain，然后用fastlane快速打包，最后上传到蒲公英平台，等待测试。</em></p>
</blockquote>
<h3 id="8-构建后操作。"><a href="#8-构建后操作。" class="headerlink" title="8. 构建后操作。"></a>8. 构建后操作。</h3><p><img src="https://ww2.sinaimg.cn/large/006tNc79ly1ff2k7cb7ptj31kw0ktjue.jpg" alt=""></p>
<p>附代码：</p>
<pre><code>&lt;h3&gt;更新说明:&lt;/h3&gt;&lt;p&gt;${News}&lt;/p&gt;&lt;a href=&quot;http://www.pgyer.com/urwork_ios&quot; style=&quot;display:block;margin:10px 0px;&quot; target=&quot;_blank&quot;&gt;点击跳转到下载页&lt;/a&gt;&lt;/br&gt;&lt;img src=&quot;http://www.pgyer.com/app/qrcode/urwork_ios&quot;&gt;
</code></pre><p>构建完成后，把之前用户输入的<strong>更新说明</strong>以及<strong>蒲公英下载地址</strong>和<strong>二维码</strong>通通显示在Build Description中。</p>
<h2 id="四、整体测试"><a href="#四、整体测试" class="headerlink" title="四、整体测试"></a>四、整体测试</h2><h3 id="1-打开Jenkins。"><a href="#1-打开Jenkins。" class="headerlink" title="1. 打开Jenkins。"></a>1. 打开Jenkins。</h3><p><img src="https://ww1.sinaimg.cn/large/006tNc79ly1ff2kbajk7cj31kw0u6jxm.jpg" alt=""></p>
<h3 id="2-点击develop-iOS。"><a href="#2-点击develop-iOS。" class="headerlink" title="2. 点击develop_iOS。"></a>2. 点击develop_iOS。</h3><p><img src="https://ww1.sinaimg.cn/large/006tNc79ly1ff2kang8dkj31kw0tf7c5.jpg" alt=""></p>
<h3 id="3-点击Build-with-Parameters"><a href="#3-点击Build-with-Parameters" class="headerlink" title="3. 点击Build with Parameters."></a>3. 点击Build with Parameters.</h3><p><img src="https://ww2.sinaimg.cn/large/006tNc79ly1ff2kdk1zdfj31kw0tktds.jpg" alt=""></p>
<h3 id="4-开始构建。"><a href="#4-开始构建。" class="headerlink" title="4. 开始构建。"></a>4. 开始构建。</h3><p><img src="https://ww4.sinaimg.cn/large/006tNc79ly1ff2keezip1j31kw0tf10n.jpg" alt=""></p>
<h3 id="5-等待构建完成即可。"><a href="#5-等待构建完成即可。" class="headerlink" title="5. 等待构建完成即可。"></a>5. 等待构建完成即可。</h3><p>这里也可以查看构建进度：点击最新的一次构建</p>
<p><img src="https://ww3.sinaimg.cn/large/006tNc79ly1ff2kg18untj31kw0s1tdq.jpg" alt=""></p>
<p>点击Console Output<br><img src="https://ww4.sinaimg.cn/large/006tNc79ly1ff2kgpirr9j31kw0sj13w.jpg" alt=""></p>
<p>在这里可以查看一些日志，如果出错了，也可以在这里查询。</p>
<h2 id="五、总结。"><a href="#五、总结。" class="headerlink" title="五、总结。"></a>五、总结。</h2><p>使用Jenkins打包Xcode工程整体过程很曲折，坑很多，按照这些来，可能还会遇到一些问题，附上一些链接，以供参考。</p>
<h2 id="附"><a href="#附" class="headerlink" title="附"></a>附</h2><ul>
<li><a href="http://www.jianshu.com/p/371595ef08fe" target="_blank" rel="external">Jenkins+ Xcode+ 蒲公英 实现IOS自动化打包和分发</a></li>
<li><a href="http://www.jianshu.com/p/41ecb06ae95f" target="_blank" rel="external">手把手教你利用Jenkins持续集成iOS项目</a></li>
<li><a href="http://www.jianshu.com/p/62fa8083b45c" target="_blank" rel="external">Jenkins签名问题</a></li>
<li><a href="https://www.pgyer.com/doc/view/jenkins_ios" target="_blank" rel="external">使用 Jenkins 实现持续集成 (iOS)</a></li>
<li><a href="https://www.pgyer.com/doc/view/jenkins" target="_blank" rel="external">使用 Jenkins 实现持续集成 (Android)</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;解决Linux服务器上的Jenkins无法构建Xcode工程&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;由于Linux服务器无法安装Xcode，所以Jenkins无法通
    
    </summary>
    
    
      <category term="iOS技术分享" scheme="http://blog.darkangel7.com/tags/iOS%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>iOS中UIWebView与WKWebView、JavaScript与OC交互、Cookie管理看我就够（上）</title>
    <link href="http://blog.darkangel7.com/2016/09/01/iOS%E4%B8%ADUIWebView%E4%B8%8EWKWebView%E3%80%81JavaScript%E4%B8%8EOC%E4%BA%A4%E4%BA%92%E3%80%81Cookie%E7%AE%A1%E7%90%86%E7%9C%8B%E6%88%91%E5%B0%B1%E5%A4%9F%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>http://blog.darkangel7.com/2016/09/01/iOS中UIWebView与WKWebView、JavaScript与OC交互、Cookie管理看我就够（上）/</id>
    <published>2016-09-01T07:37:29.000Z</published>
    <updated>2017-05-11T12:22:40.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1fff1sa06wrj30sg0iwwi9.jpg" alt=""></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>iOS开发中，用来显示一个html页、H5页，经常会用的一个控件是WebView。说到WebView，你知道多少呢？是简单的展示，还是要和OC交互实现比较复杂的功能呢？本文将为您介绍iOS中的WebView，并且由浅到深，一步步带你了解并掌握WebView的用法，JavaScript与Objective的交互，以及Cookie的管理、js的调试等。</p>
<p>文章因涉及到的内容较多，因此拆分成以下几部分：</p>
<ul>
<li>iOS中UIWebView与WKWebView、JavaScript与OC交互、Cookie管理看我就够（上）</li>
<li><a href="http://blog.darkangel7.com/2017/05/10/iOS中UIWebView与WKWebView、JavaScript与OC交互、Cookie管理看我就够（中）/">iOS中UIWebView与WKWebView、JavaScript与OC交互、Cookie管理看我就够（中）</a></li>
<li><a href="">iOS中UIWebView与WKWebView、JavaScript与OC交互、Cookie管理看我就够（下）</a>（待填坑…）</li>
</ul>
<p>关于文中提到的一些内容，这里我准备了个<a href="https://github.com/DarkAngel7/Demos-WebViewDemo" target="_blank" rel="external">Demo</a>，有需要的小伙伴可以下载。</p>
<h1 id="UIWebView"><a href="#UIWebView" class="headerlink" title="UIWebView"></a>UIWebView</h1><h2 id="UIWebView基本用法"><a href="#UIWebView基本用法" class="headerlink" title="UIWebView基本用法"></a>UIWebView基本用法</h2><p>首先要介绍的就是我们的老朋友<code>UIWebView</code>。相信对大多数小伙伴儿而言，<code>UIWebView</code>和<code>UILabel</code>一样，都是最早接触的控件了，其实<code>UIWebView</code>用法比较简单（功能基本能满足需求），简单的创建，并且调用</p>
<pre><code class="objective-c">- (void)loadRequest:(NSURLRequest *)request;
- (void)loadHTMLString:(NSString *)string baseURL:(nullable NSURL *)baseURL;
- (void)loadData:(NSData *)data MIMEType:(NSString *)MIMEType textEncodingName:(NSString *)textEncodingName baseURL:(NSURL *)baseURL;
</code></pre>
<p>这些方法，加载就可以了。<br>当然，如果需要监听页面加载的结果，或者需要判断是否允许打开某个URL，那需要设置<code>UIWebView</code>的<code>delegate</code>，代理只需要遵循<code>&lt;UIWebViewDelegate&gt;</code>协议，并且在代理中实现下面的这些可选方法就可以：</p>
<pre><code class="objective-c">__TVOS_PROHIBITED @protocol UIWebViewDelegate &lt;NSObject&gt;

@optional
- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType;
- (void)webViewDidStartLoad:(UIWebView *)webView;
- (void)webViewDidFinishLoad:(UIWebView *)webView;
- (void)webView:(UIWebView *)webView didFailLoadWithError:(nullable NSError *)error;

@end
</code></pre>
<h2 id="UIWebView中JavaScript与Objective的交互"><a href="#UIWebView中JavaScript与Objective的交互" class="headerlink" title="UIWebView中JavaScript与Objective的交互"></a>UIWebView中JavaScript与Objective的交互</h2><p>这里不详细讨论一些很好的第三方实现，比如<a href="https://github.com/marcuswestin/WebViewJavascriptBridge" target="_blank" rel="external">WebViewJavascriptBridge</a>，单纯的讲讲native端JS与OC的交互实现方式，读完了下面的部分，相信你也会实现一个简单的<code>bridge</code>了。</p>
<h3 id="UIWebView-OC调用JS"><a href="#UIWebView-OC调用JS" class="headerlink" title="UIWebView OC调用JS"></a>UIWebView OC调用JS</h3><h4 id="1-stringByEvaluatingJavaScriptFromString"><a href="#1-stringByEvaluatingJavaScriptFromString" class="headerlink" title="1. stringByEvaluatingJavaScriptFromString:"></a>1. stringByEvaluatingJavaScriptFromString:</h4><p>最常用的方法，很简单，只要调用<code>- (nullable NSString *)stringByEvaluatingJavaScriptFromString:(NSString *)script;</code>就可以了，如：</p>
<pre><code class="objective-c">    self.navigationItem.title = [webView stringByEvaluatingJavaScriptFromString:@&quot;document.title&quot;];
</code></pre>
<p>虽然比较方便，但是缺点也有：</p>
<ol>
<li>该方法不能判断调用了一个js方法之后，是否发生了错误。当错误发生时，返回值为nil，而当调用一个方法本身没有返回值时，返回值也为nil，所以无法判断是否调用成功了。</li>
<li>返回值类型为<code>nullable NSString *</code>，就意味着当调用的js方法有返回值时，都以字符串返回，不够灵活。当返回值是一个js的Array时，还需要解析字符串，比较麻烦。</li>
</ol>
<p>对于上述缺点，可以通过使用JavaScriptCore（iOS 7.0 +）来解决。</p>
<h4 id="2-JavaScriptCore（iOS-7-0-）"><a href="#2-JavaScriptCore（iOS-7-0-）" class="headerlink" title="2. JavaScriptCore（iOS 7.0 +）"></a>2. JavaScriptCore（iOS 7.0 +）</h4><p>想必大家不会陌生吧，前些日子弄的沸沸扬扬的<code>JSPatch</code>被禁事件中，最核心的就是它了。因为<code>JavaScriptCore</code>的JS到OC的映射，可以替换各种js方法成oc方法，所以其<strong>动态性（配合runtime的不安全性）</strong>也就成为了<code>JSPatch</code>被<strong>Apple</strong>禁掉的最主要原因。这里讲下<code>UIWebView</code>通过<code>JavaScriptCore</code>来实现OC-&gt;JS。</p>
<p>其实WebKit都有一个内嵌的js环境，一般我们在页面加载完成之后，获取js上下文，然后通过<code>JSContext</code>的<code>evaluateScript:</code>方法来获取返回值。因为该方法得到的是一个<code>JSValue</code>对象，所以支持JavaScript的Array、Number、String、对象等数据类型。</p>
<pre><code class="objective-c">- (void)webViewDidFinishLoad:(UIWebView *)webView
{
    //更新标题，这是上面的讲过的方法
    //self.navigationItem.title = [webView stringByEvaluatingJavaScriptFromString:@&quot;document.title&quot;];

    //获取该UIWebView的javascript上下文
    JSContext *jsContext = [self.webView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;];

    //这也是一种获取标题的方法。
    JSValue *value = [self.jsContext evaluateScript:@&quot;document.title&quot;];
    //更新标题
    self.navigationItem.title = value.toString;
}
</code></pre>
<p>该方法解决了<code>stringByEvaluatingJavaScriptFromString:</code>返回值只是<code>NSString</code>的问题。</p>
<p>那么如果我执行了一个不存在的方法，比如</p>
<pre><code class="objective-c">[self.jsContext evaluateScript:@&quot;document.titlexxxx&quot;];
</code></pre>
<p>那么必然会报错，报错了，可以通过<code>@property (copy) void(^exceptionHandler)(JSContext *context, JSValue *exception);</code>，设置该block来获取异常。</p>
<pre><code class="objective-c">//在调用前，设置异常回调
[self.jsContext setExceptionHandler:^(JSContext *context, JSValue *exception){
        NSLog(@&quot;%@&quot;, exception);
}];
//执行方法
JSValue *value = [self.jsContext evaluateScript:@&quot;document.titlexxxx&quot;];
</code></pre>
<p>该方法，也很好的解决了<code>stringByEvaluatingJavaScriptFromString:</code>调用js方法后，出现错误却捕获不到的缺点。</p>
<h3 id="UIWebView-JS调用OC"><a href="#UIWebView-JS调用OC" class="headerlink" title="UIWebView JS调用OC"></a>UIWebView JS调用OC</h3><h4 id="1-Custom-URL-Scheme（拦截URL）"><a href="#1-Custom-URL-Scheme（拦截URL）" class="headerlink" title="1. Custom URL Scheme（拦截URL）"></a>1. Custom URL Scheme（拦截URL）</h4><p>比如<code>darkangel://</code>。方法是在html或者js中，点击某个按钮触发事件时，跳转到自定义URL Scheme构成的链接，而Objective-C中捕获该链接，从中解析必要的参数，实现JS到OC的一次交互。比如页面中一个a标签，链接如下：</p>
<pre><code class="html">&lt;a href=&quot;darkangel://smsLogin?username=12323123&amp;code=892845&quot;&gt;短信验证登录&lt;/a&gt;
</code></pre>
<p>而在Objective-C中，只要遵循了<code>UIWebViewDelegate</code>协议，那么每次打开一个链接之前，都会触发方法</p>
<pre><code class="objective-c">- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType；
</code></pre>
<p>在该方法中，捕获该链接，并且返回NO（<strong>阻止本次跳转</strong>），从而执行对应的OC方法。</p>
<pre><code class="objective-c">- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType
{
    //标准的URL包含scheme、host、port、path、query、fragment等
    NSURL *URL = request.URL;    
    if ([URL.scheme isEqualToString:@&quot;darkangel&quot;]) {
        if ([URL.host isEqualToString:@&quot;smsLogin&quot;]) {
            NSLog(@&quot;短信验证码登录，参数为 %@&quot;, URL.query);
            return NO;
        }
    }
    return YES;
}
</code></pre>
<p>当用户点击<strong>短信验证登录</strong>时，控制台会输出<code>短信验证码登录，参数为 username=12323123&amp;code=892845</code>。参数可以是一个json格式并且URLEncode过的字符串，这样就可以实现复杂参数的传递（比如<a href="https://github.com/marcuswestin/WebViewJavascriptBridge" target="_blank" rel="external">WebViewJavascriptBridge</a>）。</p>
<p><strong>优点</strong>：泛用性强，可以配合h5实现页面动态化。比如页面中一个活动链接到活动详情页，当native尚未开发完毕时，链接可以是一个h5链接，等到native开发完毕时，可以通过该方法跳转到native页面，实现页面动态化。且该方案适用于Android和iOS，泛用性很强。</p>
<p><strong>缺点</strong>：无法直接获取本次交互的返回值，比较适合单向传参，且不关心回调的情景，比如h5页面跳转到native页面等。</p>
<p>其实，<a href="https://github.com/marcuswestin/WebViewJavascriptBridge" target="_blank" rel="external">WebViewJavascriptBridge</a>使用的方案就是<strong>拦截URL</strong>，为了解决无法直接获取返回值的缺点，它采用了将一个名为<code>callback</code>的<code>function</code>作为参数，通过一些封装，传递到OC（<strong>js-&gt;oc</strong> 传递参数和callbackId），然后在OC端执行完毕，再通过<code>block</code>来回调callback（<strong>oc-&gt;js</strong>，传递返回值参数），实现异步获取返回值，比如在js端调用</p>
<pre><code class="javascript">//JS调用OC的分享方法（当然需要OC提前注册）share为方法名，shareData为参数，后面的为回调function
WebViewJavascriptBridge.callHandler(&#39;share&#39;, shareData, function(response) {
   //OC端通过block回调分享成功或者失败的结果
   alert(response);   
});
</code></pre>
<p>具体的可以看下它的源码，还是很值得学习的。</p>
<h4 id="2-JavaScriptCore（iOS-7-0-）-1"><a href="#2-JavaScriptCore（iOS-7-0-）-1" class="headerlink" title="2. JavaScriptCore（iOS 7.0 +）"></a>2. JavaScriptCore（iOS 7.0 +）</h4><p>除了<strong>拦截URL</strong>的方法，还可以利用上面提到的<code>JavaScriptCore</code>。它十分强大，强大在哪里呢？下面我们来一探究竟。</p>
<p>当然，还是需要在页面加载完成时，先获取js上下文。获取到之后，我们就可以进行强大的方法映射了。</p>
<p>比如js中我定义了一个分享的方法</p>
<pre><code class="javascript">function share(title, imgUrl, link) {
     //这里需要OC实现
}
</code></pre>
<p>在OC中实现如下</p>
<pre><code class="objective-c">- (void)webViewDidFinishLoad:(UIWebView *)webView
{
    //将js的function映射到OC的方法
    [self convertJSFunctionsToOCMethods];
}

- (void)convertJSFunctionsToOCMethods
{
    //获取该UIWebview的javascript上下文
    //self持有jsContext
    //@property (nonatomic, strong) JSContext *jsContext;
    self.jsContext = [self.webView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;];

    //js调用oc
    //其中share就是js的方法名称，赋给是一个block 里面是oc代码
    //此方法最终将打印出所有接收到的参数，js参数是不固定的
    self.jsContext[@&quot;share&quot;] = ^() {
        NSArray *args = [JSContext currentArguments];//获取到share里的所有参数
        //args中的元素是JSValue，需要转成OC的对象
        NSMutableArray *messages = [NSMutableArray array];
        for (JSValue *obj in args) {
            [messages addObject:[obj toObject]];
        }
        NSLog(@&quot;点击分享js传回的参数：\n%@&quot;, messages);
    };
}
</code></pre>
<p>在html或者js的某处，点击a标签调用这个share方法，并传参，如</p>
<pre><code class="html">&lt;a href=&quot;javascript:void(0);&quot; class=&quot;sharebtn&quot; onclick=&quot;share(&#39;分享标题&#39;, &#39;http://cc.cocimg.com/api/uploads/170425/b2d6e7ea5b3172e6c39120b7bfd662fb.jpg&#39;, location.href)&quot;&gt;分享活动，领30元红包&lt;/a&gt;
</code></pre>
<p>此时，如果用户点击了<strong><u>分享活动，领30元红包</u></strong>这个标签，那么在控制台会打印出所有参数<img src="http://ww2.sinaimg.cn/large/006tNc79ly1fff18hle74j31ak0hiah2.jpg" alt=""></p>
<p>上面的代码实现了OC方法替换JS实现。它十分灵活，主要依赖这些Api。</p>
<pre><code class="objective-c">@interface JSContext (SubscriptSupport)
/*!
@method
@abstract Get a particular property on the global object.
@result The JSValue for the global object&#39;s property.
*/
- (JSValue *)objectForKeyedSubscript:(id)key;
/*!
@method
@abstract Set a particular property on the global object.
*/
- (void)setObject:(id)object forKeyedSubscript:(NSObject &lt;NSCopying&gt; *)key;
</code></pre>
<p><code>self.jsContext[@&quot;yourMethodName&quot;] = your block;</code>这样写不仅可以在有<code>yourMethodName</code>方法时替换该JS方法为OC实现，还会在g该方法没有时，添加方法。简而言之，<strong>有则替换，无则添加</strong>。</p>
<p>那如果我想写一个有两个参数，一个返回值的js方法，oc应该怎么替换呢？</p>
<p>js中</p>
<pre><code class="javascript">//该方法传入两个整数，求和，并返回结果
function testAddMethod(a, b) {
     //需要OC实现a+b，并返回
      return a + b;
}
//js调用
console.log(testAddMethod(1, 5));    //output  6
</code></pre>
<p>oc直接替换该方法</p>
<pre><code class="objective-c">self.jsContext[@&quot;testAddMethod&quot;] = ^NSInteger(NSInteger a, NSInteger b) {
      return a + b;
};
</code></pre>
<p>那么当在js调用</p>
<pre><code class="javascript">//js调用
console.log(testAddMethod(1, 5));    //output  6， 方法为 a + b
</code></pre>
<p>如果oc替换该方法为两数相乘</p>
<pre><code class="objective-c">self.jsContext[@&quot;testAddMethod&quot;] = ^NSInteger(NSInteger a, NSInteger b) {
      return a * b;
};
</code></pre>
<p>再次调用js</p>
<pre><code class="javascript">console.log(testAddMethod(1, 5));    //output  5，该方法变为了 a * b。
</code></pre>
<p>举一反三，调用方法原实现，并且在原结果上乘以10。</p>
<pre><code class="objective-c">//调用方法的本来实现，给原结果乘以10
JSValue *value = self.jsContext[@&quot;testAddMethod&quot;];
self.jsContext[@&quot;testAddMethod&quot;] = ^NSInteger(NSInteger a, NSInteger b) {
    JSValue *resultValue = [value callWithArguments:[JSContext currentArguments]];
    return resultValue.toInt32 * 10;
};
</code></pre>
<p>再次调用js</p>
<pre><code class="javascript">console.log(testAddMethod(1, 5));    //output  60，该方法变为了(a + b) * 10
</code></pre>
<p>上面的方法，都是同步函数，如果我想实现JS调用OC的方法，并且异步接收回调，那么该怎么做呢？比如h5中有一个分享按钮，用户点击之后，调用native分享（微信分享、微博分享等），在native分享成功或者失败时，回调h5页面，告诉其分享结果，h5页面刷新对应的UI，显示分享成功或者失败。</p>
<p>这个问题，需要对js有一定了解。下面上js代码。</p>
<pre><code class="javascript">//声明
function share(shareData) {
    var title = shareData.title;
    var imgUrl = shareData.imgUrl;
    var link = shareData.link;
    var result = shareData.result;
      //do something
    //这里模拟异步操作
    setTimeout(function(){
          //2s之后，回调true分享成功
       result(true);
    }, 2000);
}

//调用的时候需要这么写
share({
      title: &quot;title&quot;, 
     imgUrl: &quot;http://img.dd.com/xxx.png&quot;, 
     link: location.href, 
     result: function(res) {    //函数作为参数
         console.log(res ? &quot;success&quot; : &quot;failure&quot;);
    }
});
</code></pre>
<p>从封装的角度上讲，js的<code>share</code>方法的参数是一个<code>对象</code>，该对象包含了几个必要的字段，以及一个回调函数，这个回调函数有点像oc的<code>block</code>，<strong>调用者</strong>把一个<code>function</code>传入一个<code>function</code>当作参数，在适当时候，方法内<strong>实现者</strong>调用该<code>function</code>，实现对<strong>调用者</strong>的异步回调。那么如果此时OC来实现<code>share</code>方法，该怎么做呢？其实大概是这样的：</p>
<pre><code class="objective-c">//异步回调
self.jsContext[@&quot;share&quot;] = ^(JSValue *shareData) {    //首先这里要注意，回调的参数不能直接写NSDictionary类型，为何呢？
    //仔细看，打印出的确实是一个NSDictionary，但是result字段对应的不是block而是一个NSDictionary  
      NSLog(@&quot;%@&quot;, [shareData toObject]);     
    //获取shareData对象的result属性，这个JSValue对应的其实是一个javascript的function。
    JSValue *resultFunction = [shareData valueForProperty:@&quot;result&quot;];
    //回调block，将js的function转换为OC的block
    void (^result)(BOOL) = ^(BOOL isSuccess) {
        [resultFunction callWithArguments:@[@(isSuccess)]];
    };
    //模拟异步回调
    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
        NSLog(@&quot;回调分享成功&quot;);
        result(YES);
    });
};
</code></pre>
<p>其中一些坑，已经在代码的注释写的比较清楚了，这里要注意<code>JavaScript</code>的<code>function</code>和<code>Objective-C</code>的<code>block</code>的转换。</p>
<p>从上面的一些探讨和尝试来看，足以证明<code>JavaScriptCore</code>的强大，这里不再展开，小伙伴们可以自行探索。</p>
<h2 id="UIWebView的Cookie管理"><a href="#UIWebView的Cookie管理" class="headerlink" title="UIWebView的Cookie管理"></a>UIWebView的Cookie管理</h2><h3 id="Cookie简介"><a href="#Cookie简介" class="headerlink" title="Cookie简介"></a>Cookie简介</h3><p>说到<code>Cookie</code>，或许有些小伙伴会比较陌生，有些小伙伴会比较熟悉。如果项目中，所有页面都是纯原生来实现的话，一般<code>Cookie</code>这个东西或许我们永远也不会接触到。但是，这里还是要说一下<code>Cookie</code>，因为它真的很重要，由它产生的一些坑也很多。</p>
<p><code>Cookie</code>在Web利用的最多的地方，是用来记录各种状态。比如你在<code>Safari</code>中打开百度，然后登陆自己的账号，之后打开所有百度相关的页面，都会是登陆状态，而且当你关了电脑，下次开机再次打开<code>Safari</code>打开百度，会发现还是登陆状态，其实这个就利用了<code>Cookie</code>。<code>Cookie</code>中记录了你百度账号的一些信息、有效期等，也维持了跨域请求时登录状态的统计性。<img src="http://ww3.sinaimg.cn/large/006tNc79ly1fff5jbzd4cj31kw0jk11w.jpg" alt="">可以看到<code>Cookie</code>的域各不相同，有效期也各不相同，一般<code>.baidu.com</code>这样的域的<code>Cookie</code>就是为了跨域时，可以维持一些状态。</p>
<p>那么在App中，Cookie最常用的就是维持登录状态了。一般Native端都有自己的一套完整登录注册逻辑，一般大部分页面都是原生实现的。当然，也会有一些页面是h5来实现的，虽然h5页面在App中通过<code>WebView</code>加载或多或少都会有点性能问题，感觉不流畅或者体验不好，但是它的灵活性是Native App无法比拟的。那么由此，便产生了一种需求，当Native端用户是登录状态的，打开一个h5页面，h5也要维持用户的登录状态。</p>
<p>这个需求看似简单，如何实现呢？一般的解决方案是Native保存登录状态的Cookie，在打开h5页面中，把Cookie添加上，以此来维持登录状态。其实坑还是有很多的，比如用户登录或者退出了，h5页面的登录状态也变了，需要刷新，什么时候刷新？<code>WKWebView</code>中<code>Cookie</code>丢失问题？这里简单说下<code>UIWebView</code>的<code>Cookie</code>管理，后面的章节再介绍<code>WKWebView</code>。</p>
<h3 id="Cookie管理"><a href="#Cookie管理" class="headerlink" title="Cookie管理"></a>Cookie管理</h3><p><code>UIWebView</code>的<code>Cookie</code>管理很简单，一般不需要我们手动操作<code>Cookie</code>，因为所有<code>Cookie</code>都会被<code>[NSHTTPCookieStorage sharedHTTPCookieStorage]</code>这个单例管理，而且<code>UIWebView</code>会自动同步<code>CookieStorage</code>中的Cookie，所以只要我们在Native端，正常登陆退出，h5在适当时候刷新，就可以正确的维持登录状态，不需要做多余的操作。</p>
<p>可能有一些情况下，我们需要在访问某个链接时，添加一个固定<code>Cookie</code>用来做区分，那么就可以通过<code>header</code>来实现</p>
<pre><code class="objective-c">NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@&quot;http://www.baidu.com&quot;]];
[request addValue:@&quot;customCookieName=1314521;&quot; forHTTPHeaderField:@&quot;Set-Cookie&quot;];
[self.webView loadRequest:request];
</code></pre>
<p>也可以主动操作<code>NSHTTPCookieStorage</code>，添加一个自定义<code>Cookie</code></p>
<pre><code class="objective-c">NSHTTPCookie *cookie = [NSHTTPCookie cookieWithProperties:@{
    NSHTTPCookieName: @&quot;customCookieName&quot;, 
    NSHTTPCookieValue: @&quot;1314521&quot;, 
    NSHTTPCookieDomain: @&quot;.baidu.com&quot;,
    NSHTTPCookiePath: @&quot;/&quot;
}];
[[NSHTTPCookieStorage sharedHTTPCookieStorage] setCookie:cookie];    //Cookie存在则覆盖，不存在添加
</code></pre>
<p>还有一些常用的方法，如读取所有<code>Cookie</code></p>
<pre><code class="objective-c">NSArray *cookies = [NSHTTPCookieStorage sharedHTTPCookieStorage].cookies;
</code></pre>
<p><code>Cookie</code>转换成<code>HTTPHeaderFields</code>，并添加到<code>request</code>的<code>header</code>中</p>
<pre><code class="objective-c">//Cookies数组转换为requestHeaderFields
NSDictionary *requestHeaderFields = [NSHTTPCookie requestHeaderFieldsWithCookies:cookies];
//设置请求头
request.allHTTPHeaderFields = requestHeaderFields;
</code></pre>
<p>整体来说<code>UIWebView</code>的<code>Cookie</code>管理比较简单，小伙伴们可以自己写个demo测试一下，发挥你们的想象。</p>
<h1 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h1><p>关于<code>UIWebView</code>的介绍，以及使用<code>UIWebView</code>进行JS与OC的交互，<code>Cookie</code>的管理，就先简单介绍到这里。如果有小伙伴对于<a href="https://github.com/marcuswestin/WebViewJavascriptBridge" target="_blank" rel="external">WebViewJavascriptBridge</a>比较感兴趣，可以留言，根据留言我考虑一下写一篇文章，分析它的详细实现。</p>
<p>另外，后续将为您介绍<code>WKWebView</code>的用法，一些OC与JS交互，Cookie管理、如何在<code>Safari</code>中调试以及一些不为人知的坑等，敬请期待~</p>
<p>下篇文章已发布：<a href="http://blog.darkangel7.com/2017/05/10/iOS中UIWebView与WKWebView、JavaScript与OC交互、Cookie管理看我就够（中）/">iOS中UIWebView与WKWebView、JavaScript与OC交互、Cookie管理看我就够（中）</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/006tNc79ly1fff1sa06wrj30sg0iwwi9.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; titl
    
    </summary>
    
    
      <category term="iOS技术分享" scheme="http://blog.darkangel7.com/tags/iOS%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+Github的Blog搭建</title>
    <link href="http://blog.darkangel7.com/2016/08/19/Hexo+Github%E7%9A%84Blog%E6%90%AD%E5%BB%BA/"/>
    <id>http://blog.darkangel7.com/2016/08/19/Hexo+Github的Blog搭建/</id>
    <published>2016-08-19T04:40:16.000Z</published>
    <updated>2017-05-08T02:38:09.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装："><a href="#安装：" class="headerlink" title="安装："></a>安装：</h1><h2 id="一、安装Homebrew"><a href="#一、安装Homebrew" class="headerlink" title="一、安装Homebrew"></a>一、安装Homebrew</h2><p>Mac上已经安装了ruby环境，只需要输入</p>
<pre><code>ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;
</code></pre><h2 id="二、安装node-js"><a href="#二、安装node-js" class="headerlink" title="二、安装node.js"></a>二、安装node.js</h2><pre><code>sudo brew install node
</code></pre><h2 id="三、安装Hexo"><a href="#三、安装Hexo" class="headerlink" title="三、安装Hexo"></a>三、安装Hexo</h2><p>Hexo是基于node.js的博客系统，这里安装就可以了。</p>
<pre><code>sudo npm install -g hexo 
npm install hexo-renderer-ejs --save
npm install hexo-renderer-stylus --save
npm install hexo-renderer-marked --save
</code></pre><p>安装完成后，找一个放blog的目录</p>
<pre><code>cd ~/Blog
</code></pre><p>然后执行初始化</p>
<pre><code>hexo init
</code></pre><p>然后可以直接预览hello word.md</p>
<pre><code>hexo g
hexo s
=&gt; [info] Hexo is running at localhost:4000/. Press Ctrl+C to stop.
</code></pre><p>g是generate, s是server，还有d是deploy（部署）推荐用首字母，方便快捷。</p>
<h2 id="四、创建Blog-Repository"><a href="#四、创建Blog-Repository" class="headerlink" title="四、创建Blog Repository"></a>四、创建Blog Repository</h2><p>在自己的Github创建Blog的仓库，如Blog-Hexo，命名无所谓。记住勾选README。</p>
<p><img src="http://ww4.sinaimg.cn/large/65e4f1e6jw1f72qarsjd9j20va0aydh0.jpg" alt="repository1"></p>
<p><img src="http://ww2.sinaimg.cn/large/65e4f1e6jw1f72qbhppqfj214a0sqq6q.jpg" alt="repository2"><br>创建完毕，直接进行到下一步。</p>
<h2 id="五、购买域名"><a href="#五、购买域名" class="headerlink" title="五、购买域名"></a>五、购买域名</h2><p>推荐在万网购买，国外的Godaddy也可以。以万网为例：<br>买好域名实名认证了之后，到<code>控制台</code> - <code>云解析DNS</code>中添加一个解析，如：</p>
<p><img src="http://ww4.sinaimg.cn/large/65e4f1e6jw1f72qblgcswj21kw01qglt.jpg" alt=""></p>
<p>CNAME映射到自己的xxx.github.io。这里的xxx是你的在github的名称，我的是<code>DarkAngel7</code>。<br>在终端中输入</p>
<pre><code>dig blog.darkangel7.com +nostats +nocomments +nocmd
</code></pre><p>如果出现下面的结果，证明解析成功。</p>
<pre><code>DarkAngel-MacBook-Pro-2:Blog DarkAngel$ dig blog.darkangel7.com +nostats +nocomments +nocmd

; &lt;&lt;&gt;&gt; DiG 9.8.3-P1 &lt;&lt;&gt;&gt; blog.darkangel7.com +nostats +nocomments +nocmd
;; global options: +cmd
;blog.darkangel7.com.        IN    A
blog.darkangel7.com.    30    IN    CNAME    darkangel7.github.io.
darkangel7.github.io.    2516    IN    CNAME    github.map.fastly.net.
github.map.fastly.net.    30    IN    CNAME    prod.github.map.fastlylb.net.
prod.github.map.fastlylb.net. 30 IN    A    151.101.100.133
</code></pre><h2 id="六、Deploy"><a href="#六、Deploy" class="headerlink" title="六、Deploy"></a>六、Deploy</h2><p>上一步完成域名到github pages的单向映射。本步完成github到域名的映射，完成输入域名解析到对应的内容。</p>
<p>首先在Blog/source里创建CNAME</p>
<pre><code>cd source
touch CNAME
vi CNAME
</code></pre><p>输入你在上一步CNAME的域名，建立映射关系。</p>
<pre><code>blog.darkangel7.com
</code></pre><p>修改<code>_config.yml</code>文件，配置一些东西。</p>
<pre><code># Deployment
## Docs: https://hexo.io/docs/deployment.html
deploy:
      type: git
      repository: git@github.com:DarkAngel7/Blog-Hexo.git
</code></pre><p>安装git插件</p>
<pre><code>npm install hexo-deployer-git --save
</code></pre><p>这里repository的地址可以是https的，也可以是git的，只不过git需要SSH证书，一般用https就可以了，如果出现443错误，替换成git。</p>
<p>然后在Blog目录下</p>
<pre><code>hexo g -d
</code></pre><p>生成静态文件并且部署出去，不出意外，已经可以外网访问了。</p>
<h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><h2 id="一、访问速度"><a href="#一、访问速度" class="headerlink" title="一、访问速度"></a>一、访问速度</h2><p>由于Google被墙，大部分主题中引用的jquery都会因为超时（可以Blog目录下搜索google），而造成页面访问很慢，这里需要将jquery改为百度的<br>​    </p>
<pre><code>&lt;script src=&quot;//apps.bdimg.com/libs/jquery/2.0.3/jquery.min.js&quot;&gt;&lt;/script&gt;
</code></pre><h2 id="二、RSS订阅"><a href="#二、RSS订阅" class="headerlink" title="二、RSS订阅"></a>二、RSS订阅</h2><p>输入命令</p>
<pre><code>$ npm install hexo-generator-feed --save
</code></pre><p>然后在_config.yml中，添加<br>​    </p>
<pre><code>rss: /atom.xml
feed:
     type: atom
    path: atom.xml
     limit: 20
</code></pre><h2 id="三、搜索支持"><a href="#三、搜索支持" class="headerlink" title="三、搜索支持"></a>三、搜索支持</h2><p>现在在百度和Google是搜不到你的网站的，为了让搜索引擎搜索到，需要做一些工作。</p>
<p>搜索引擎入口</p>
<ul>
<li><a href="https://www.google.com/webmasters/tools/home?hl=zh-CN" target="_blank" rel="external">Google搜索引擎提交入口</a></li>
<li><a href="http://www.baidu.com/search/url_submit.htm" target="_blank" rel="external">百度搜索引擎入口</a></li>
</ul>
<p>添加sitemap.xml：</p>
<p>首先输入：</p>
<pre><code>npm install hexo-generator-sitemap --save
npm install hexo-generator-baidu-sitemap --save    
npm install hexo-baidu-url-submit --save
</code></pre><p>前两个插件用于生成sitemap，后一个插件用于主动推送链接到百度（<strong>防止百度爬虫抓取失败，导致百度搜不到您的博客</strong>，这里有一篇<a href="http://guochenglai.com/2016/09/26/baidu-crow-github-page/" target="_blank" rel="external">关于百度无法爬取Github Pages静态网站解决方案</a>）。</p>
<p>然后在<code>_config.yml</code>文件中添加</p>
<pre><code>sitemap:
         path: sitemap.xml
baidusitemap:
         path: baidusitemap.xml

## BaiduUrlSubmit: http://hui-wang.info/2016/10/23/Hexo插件之百度主动提交链接/    
baidu_url_submit:        ##主动推送新文章到百度
  count: 3 ## 比如3，代表提交最新的三个链接
  host: blog.darkangel7.com ## 在百度站长平台中注册的域名
  token: your_token ## 请注意这是您的秘钥， 请不要发布在公众仓库里!
  path: baidu_urls.txt ## 文本文档的地址， 新链接会保存在此文本文档里

##同时要检查这里有没有URL值，必须包含是百度站长平台注册的域名，比如 
# URL
url: http://blog.darkangel7.com
root: /
permalink: :year/:month/:day/:title/

##最后，加入新的deployer，如
deploy:
- type: git
  repository: git@github.com:DarkAngel7/Blog-Hexo.git
- type: baidu_url_submitter  ## 百度链接主动推送
</code></pre><p>先验证网站所有权，下载html，mv到Blog/themes/yourtheme/source目录下，执行</p>
<pre><code>hexo g -d
</code></pre><p>验证成功后，添加百度自动推送脚本，最好在<code>head.ejs</code>中添加百度自动推送的代码，至于<code>head.ejs</code>文件位置，在你使用的theme文件夹下搜索吧。<br>谷歌的话，在<code>抓取</code>-<code>站点地图</code>里面添加就好。</p>
<p>这样主动推送与自动推送结合，能很好的提高您文章的曝光率。    </p>
<h2 id="四、评论功能"><a href="#四、评论功能" class="headerlink" title="四、评论功能"></a>四、评论功能</h2><p>可以使用<a href="http://duoshuo.com" target="_blank" rel="external">多说</a>来提供评论功能。首先，在<code>_config.yml</code>文件中添加</p>
<pre><code># Duoshuo
duoshuo_shortname: yoursite.doushuo.com
</code></pre><p>  然后，搜索themes文件夹下，你使用的theme文件目录下的<code>commemt.ejs</code>（不同的theme可能位置不同，请自行寻找）。修改如下：</p>
<pre><code> &lt;div id=&quot;comment&quot; class=&quot;comments-area&quot;&gt;
     &lt;% if(config.duoshuo_shortname) { %&gt;
     &lt;! -- 多说的代码 --&gt; 
     &lt;% } %&gt; 
&lt;/div&gt;    

 如果报关于data-thread-key的错误，则改成下面这样：
 &lt;div class=&quot;ds-thread&quot; data-thread-key=&quot;&lt;%= page.path %&gt;&quot; data-title=&quot;&lt;%= page.title %&gt;&quot; data-url=&quot;&lt;%= page.permalink %&gt;&quot;&gt;&lt;/div    &gt;
</code></pre><h2 id="五、分享功能"><a href="#五、分享功能" class="headerlink" title="五、分享功能"></a>五、分享功能</h2><p>可以在Blog目录下搜索<code>post/share</code>，一般在<code>article.ejs</code>文件中，或者<code>post.ejs</code>文件中，然后替换</p>
<pre><code>&lt;%- partial(&#39;post/author&#39;) %&gt;
</code></pre><p>为<a href="http://share.baidu.com/code" target="_blank" rel="external">百度分享</a>提供的代码。</p>
<h2 id="六、个人信息完善"><a href="#六、个人信息完善" class="headerlink" title="六、个人信息完善"></a>六、个人信息完善</h2><p>网站的信息一般都在<code>Blog/_config.yml</code>中修改。</p>
<p>关于Theme，去官方提供的<a href="https://github.com/tommy351/hexo/wiki/Themes" target="_blank" rel="external">主题列表</a>中选个现成的，按照里面的方法pull下来，如light主题</p>
<pre><code>$ git clone git://github.com/tommy351/hexo-theme-light.git themes/light
</code></pre><p>然后在<code>_config.yml</code>配置文件中设置：</p>
<pre><code>theme: light
</code></pre><p>关于主题的优化，一般在<code>themes/yourtheme/_config.yml</code>中配置。</p>
<h1 id="写文章"><a href="#写文章" class="headerlink" title="写文章"></a>写文章</h1><p>在Blog目录下，创建</p>
<pre><code>hexo new 文章题目
</code></pre><p>然后用Markdown编写，写好后save。</p>
<pre><code>hexo g
hexo s
</code></pre><p>生成，然后在本地localhost:4000预览一下，如果没有问题，就可以发布了。</p>
<pre><code>hexo d
</code></pre><p>所有的文章都是放在<code>Blog/source/_posts/</code>目录下的，可以随时编辑修改。</p>
<h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>还有一些其他的修改，这里就不一一提了，等待你慢慢发现。现在快开始写作吧~~</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;安装：&quot;&gt;&lt;a href=&quot;#安装：&quot; class=&quot;headerlink&quot; title=&quot;安装：&quot;&gt;&lt;/a&gt;安装：&lt;/h1&gt;&lt;h2 id=&quot;一、安装Homebrew&quot;&gt;&lt;a href=&quot;#一、安装Homebrew&quot; class=&quot;headerlink&quot; titl
    
    </summary>
    
    
  </entry>
  
</feed>
