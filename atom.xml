<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dark Angel</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.darkangel7.com/"/>
  <updated>2017-05-05T09:24:15.000Z</updated>
  <id>http://blog.darkangel7.com/</id>
  
  <author>
    <name>Dark Angel</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS中NSUserDefaults的黑科技</title>
    <link href="http://blog.darkangel7.com/2017/05/05/iOS%E4%B8%ADNSUserDefaults%E7%9A%84%E9%BB%91%E7%A7%91%E6%8A%80/"/>
    <id>http://blog.darkangel7.com/2017/05/05/iOS中NSUserDefaults的黑科技/</id>
    <published>2017-05-05T04:18:12.000Z</published>
    <updated>2017-05-05T09:24:15.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在iOS开发中，我们时常需要保存一些数据，或者希望在用户下次打开App时，依然可以保留一些设置等，比如<strong>主题设置</strong>、<strong>语言设置</strong>，那么我们一般会选择使用<code>NSUserDefaults</code>作为轻量级数据持久化方案。这里不对其他的数据持久化方案（如Plist、归档、Sqlite3、CoreData等）进行探讨，主要来介绍一下<code>NSUserDefaults</code>中的一些黑科技。</p>
<h1 id="NSUserDefaults简介"><a href="#NSUserDefaults简介" class="headerlink" title="NSUserDefaults简介"></a>NSUserDefaults简介</h1><p><code>NSUserDefaults</code>在Foundation框架中被定义，用来存储和读取一些轻量级数据。其本质是操作plist文件。</p>
<p>它比其他数据持久化方案的优点在于：</p>
<ul>
<li>轻量级。</li>
<li>方便快捷直接使用。</li>
<li>支持<code>NSData</code>, <code>NSString</code>, <code>NSNumber</code>, <code>NSDate</code>, <code>NSArray</code> and  <code>NSDictionary</code>。</li>
</ul>
<p>缺点在于：</p>
<ul>
<li>不适合大量数据。</li>
<li>无法存储自定义<code>model</code>。</li>
</ul>
<h1 id="黑科技"><a href="#黑科技" class="headerlink" title="黑科技"></a>黑科技</h1><p>一些<code>NSUserDefaults</code>最基础的用法，这里就不赘述了。说到黑科技，一般指的是鲜为人知而又十分厉害的技术。这里主要介绍两个黑科技。</p>
<h2 id="还原默认值"><a href="#还原默认值" class="headerlink" title="还原默认值"></a>还原默认值</h2><p>一般<code>NSUserDefaults</code>使用，都会保存一些自定义的Key和Value，其实这个不涉及还原默认值的问题。其实有些时候，是需要修改其中的系统默认值的。比如应用内切换中英文，就需要修改<code>AppleLanguages</code>的value。既然修改了系统默认值，怎么还原默认值呢？</p>
<p>我们先来看一下修改前的：</p>
<pre><code>po [NSUserDefaults standardUserDefaults].dictionaryRepresentation

{
    ...
    AppleLanguages =     (
        en,
        &quot;zh-Hans-US&quot;
    );
    AppleLocale = &quot;en_US&quot;;
    ...
}
</code></pre><p>可以看到<code>AppleLanguages</code>对应的是一个数组，如果我们在App内想切换成中文，执行</p>
<pre><code class="objective-c">[[NSUserDefaults standardUserDefaults] setObject:@[@&quot;zh-Hans&quot;] forKey:@&quot;AppleLanguages&quot;];
</code></pre>
<p>再次看下修改后</p>
<pre><code>po [NSUserDefaults standardUserDefaults].dictionaryRepresentation

{
    ...
    AppleLanguages =     (
        zh-Hans
    );
    AppleLocale = &quot;en_US&quot;;
    ...
}
</code></pre><p>好吧，这个<code>AppleLanguages</code>字段的值已经被记录了。这时候，kill客户端，重新打开客户端，发现，这个值肯定不会变。那么如果这个时候用户在系统设置中切换到了日语，那么我想在客户端中通过<strong>跟随手机系统</strong>的设置，还原到日语，该怎么办呢？</p>
<p>或许你会想到记录初始值，只要提前记录，在还原时再set回去就可以了。嗯~没毛病，可是在什么地方什么时候记录初始值呢？这个<code>AppleLanguages</code>字段其实就是系统的语言默认值，你已经把它改过了，如果在你改过之后用户又修改了系统语言，那你是拿不到新默认值的，所以这条路是走不通的。</p>
<p>那怎么实现还原默认值呢？看下这个方法：</p>
<pre><code>/*!
 -setObject:forKey: immediately stores a value (or removes the value if nil is passed as the value) for the provided key in the search list entry for the receiver&#39;s suite name in the current user and any host, then asynchronously stores the value persistently, where it is made available to other processes.
 */
- (void)setObject:(nullable id)value forKey:(NSString *)defaultName;
</code></pre><p>这个方法Document中并没有描述过多，基本都是在强调<code>value</code>必须是<code>NSData</code>, <code>NSString</code>, <code>NSNumber</code>, <code>NSDate</code>, <code>NSArray</code> and  <code>NSDictionary</code>中的一种，且<code>NSArray</code> and  <code>NSDictionary</code>中的值也必须是Plist支持的类型。在注释中有强调，<code>removes the value if nil is passed as the value</code>，传nil等同于删除这个键值对。</p>
<pre><code>/// -removeObjectForKey: is equivalent to -[... setObject:nil forKey:defaultName]
- (void)removeObjectForKey:(NSString *)defaultName;
</code></pre><p>其实这里才是关键</p>
<pre><code>[[NSUserDefaults standardUserDefaults] setObject:nil forKey:@&quot;AppleLanguages&quot;];
//or
[[NSUserDefaults standardUserDefaults] removeObjectForKey:@&quot;AppleLanguages&quot;];
</code></pre><p>然后再次</p>
<pre><code>po [NSUserDefaults standardUserDefaults].dictionaryRepresentation

{
    ...
    AppleLanguages =     (
        en,
        &quot;zh-Hans-US&quot;
    );
    AppleLocale = &quot;en_US&quot;;
    ...
}
</code></pre><p>你会发现，WTF，居然这个字段还存在，且还原成了默认值，厉害了word哥。本方法是本人历经各种坑之后发现的，且官方文档中没有任何提及，只能说Apple爸爸任性。</p>
<h2 id="巧用SuiteName"><a href="#巧用SuiteName" class="headerlink" title="巧用SuiteName"></a>巧用SuiteName</h2><pre><code>- (nullable instancetype)initWithSuiteName:(nullable NSString *)suitename NS_AVAILABLE(10_9, 7_0) NS_DESIGNATED_INITIALIZER;
</code></pre><p>这个方法，想必各位不会陌生，在跨App间通信或者主App与Extension共享数据，都会用到，一般配合使用的是<strong>App Groups</strong>。</p>
<h3 id="App-Groups数据共享"><a href="#App-Groups数据共享" class="headerlink" title="App Groups数据共享"></a>App Groups数据共享</h3><p>在App Groups中使用，一般两个App都需要加入同一个Group。<img src="http://ww1.sinaimg.cn/large/006tNbRwly1ffajfof2qdj30x00cqjsl.jpg" alt="">然后在两个App分别使用</p>
<pre><code class="objective-c">- (NSUserDefaults *)userDefaults
{
    return [[NSUserDefaults alloc] initWithSuiteName:@&quot;group.urwork.autosignin&quot;];    //name需要是Group的id
}
</code></pre>
<p>来存储和读取数据，即可实现数据共享。</p>
<h3 id="超微型简单方便易用数据库"><a href="#超微型简单方便易用数据库" class="headerlink" title="超微型简单方便易用数据库"></a>超微型简单方便易用数据库</h3><p>这里，其实主要介绍一下<code>initWithSuiteName:</code>的另一个用途，我称之为<strong>超微型简单方便易用数据库</strong>。</p>
<p><strong>需求</strong>：后台同学最近太忙（😳这不是理由），需要客户端同学临时开发一个本地的浏览历史功能。简单的说就是在客户端本地保存每个用户浏览的文章记录。</p>
<p><strong>吐糟</strong>：好吧，时间紧，任务重，功能先上线，后续再优化已经是一个习惯了😳。</p>
<p><strong>实现方案</strong>：简单，本地存个字典（或者Plist文件），每个key是一个用户id，value是一个数组，数组里的每个元素是一个字典，这个字典里有<code>articleId</code>、<code>title</code>、<code>imgUrl</code>、<code>...</code>。结构大概是这样：</p>
<pre><code>{
  &quot;10086&quot; : [
    {
      &quot;articleId&quot; : 1,
      &quot;imgUrl&quot; : &quot;https://img.xxx.com/abcdefg.png&quot;,
      &quot;title&quot; : &quot;中国历史&quot;,
      ...
    },
    {
      &quot;articleId&quot; : 2,
      &quot;imgUrl&quot; : &quot;https://img.xxx.com/abcdefg.png&quot;,
      &quot;title&quot; : &quot;中国教育&quot;,
      ...
    },
    ...
  ],
  &quot;10087&quot; : [
    {
      &quot;articleId&quot; : 2,
      &quot;imgUrl&quot; : &quot;https://img.xxx.com/abcdefg.png&quot;,
      &quot;title&quot; : &quot;中国教育&quot;,
      ...
    },
    ...
  ]
}
</code></pre><p>看起来OK，但是小伙伴们，性能问题还是要考虑的。我想获取某个用户的浏览历史，需要把文件整体读到内存中，然后用<code>dict[@&quot;10086&quot;]</code>的方法，得到这个用户的浏览历史<code>Array</code>，用户少还好，多了，每次读取的IO操作会很耗时，对性能有影响。</p>
<p>可能你会说用数据库啊什么的，当然可以，但是又是需要依赖一堆第三方，还要写好多代码，创建好多类。我就是想简单实现一下，有没有更好的方法呢？当然有，<strong>超微型简单方便易用数据库</strong>。</p>
<p>每个用户都可以用一个<code>NSUserDefaults</code>来代替，每个用户的浏览历史，可以直接用<code>setObject:forKey:</code>的方式来存储，如：</p>
<pre><code class="objective-c">//这个跟App Groups没有关系
//已有则读取，没有则创建
NSUserDefaults *userDefaults = [[NSUserDefaults alloc] initWithSuiteName:@&quot;10086&quot;];
//存储
[userDefaults setObject:history forKey:@&quot;ArticleBrowsingHistory&quot;];
//读取
NSArray *history = [userDefaults objectForKey:@&quot;ArticleBrowsingHistory&quot;];
</code></pre>
<p>所有用户相对独立，每个用户是一个plist文件，在沙盒目录<code>/Library/Preferences/</code>中，<img src="http://ww2.sinaimg.cn/large/006tNbRwly1ffalfnmhudj30z007kab7.jpg" alt="">想删除也很容易，直接删除这个文件即可。</p>
<p>其实这个<strong>超微型简单方便易用数据库</strong>还可以实现好多功能，看你怎么操作了。如果你的App没有后台，不同用户的主题设置、语言设置可能不同，都可以通过这个来存储。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实很多我们很常用的东西都有很多我们未发掘出的用途，生活也是同样，学会发现，一切会更美好。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在iOS开发中，我们时常需要保存一些数据，或者希望在用户下次打开App时，依然可以保留一些设置等，比如&lt;strong&gt;主题设置&lt;/stron
    
    </summary>
    
    
      <category term="iOS技术分享" scheme="http://blog.darkangel7.com/tags/iOS%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>在iOS App内优雅的动态切换语言</title>
    <link href="http://blog.darkangel7.com/2017/05/04/%E5%9C%A8iOSApp%E5%86%85%E4%BC%98%E9%9B%85%E7%9A%84%E5%8A%A8%E6%80%81%E5%88%87%E6%8D%A2%E8%AF%AD%E8%A8%80/"/>
    <id>http://blog.darkangel7.com/2017/05/04/在iOSApp内优雅的动态切换语言/</id>
    <published>2017-05-04T03:46:56.000Z</published>
    <updated>2017-05-05T09:28:31.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>随着公司业务的发展，App版本的迭代，相信不少App都需要英文化（国际化）。App英文化，不外乎这三点：</p>
<ol>
<li>纯代码中引用的strings国际化；</li>
<li>Storyboard/Xib国际化；</li>
<li>Info.plist国际化。</li>
</ol>
<p>具体这三种分别如何操作，怎么国际化，这里不再赘述。一般App做了国际化，那么在用户切换手机系统Settings里的Language时，App就会切换成对应的语言（前提是做过该语言国际化）。那么如果想实现<strong>微博</strong>和<strong>微信</strong>等App，在App内部实现切换语言，应该怎么做呢？如何做，才能更加优雅的动态切换语言呢？</p>
<p>下面，讲一讲如何在iOS App内优雅的动态切换语言。</p>
<h1 id="调研"><a href="#调研" class="headerlink" title="调研"></a>调研</h1><p>如果有相关需求，一般成熟的App都会怎么做呢？这里我们来看一下<strong>微博</strong>和<strong>微信</strong>。</p>
<p><strong>微博</strong>：</p>
<p><img src="http://ww3.sinaimg.cn/large/006tKfTcly1ff9jfo5a8ig306y0cctz0.gif" alt=""></p>
<p><strong>微信</strong>：</p>
<p><img src="http://ww1.sinaimg.cn/large/006tKfTcly1ff9d5ezj9jg30680b3kif.gif" alt=""></p>
<p>对比一下可以看出，微博整体的效果比微信好很多，丝滑流畅。</p>
<p><strong><em>这里注意一下细节</em></strong>：我在微博的个人中心是故意上滑了一下，然后点击进入设置，进行语言切换，可以看到切换时很自然，然后返回个人中心时，页面<code>scrollView</code>的<code>contentOffset</code>并没有发生变化，由此可以推测：</p>
<p><strong><u>微博的思路是，在切换语言时，发送通知<code>NSNotification</code>，所有的UI控件监听通知，然后在适当的时候刷新UI</u></strong>。那么其实这么写，需要做的东西很多，或是通过Base类来实现，或是通过<code>runtime</code>实现，总之<code>Button</code>、<code>Label</code>、<code>TextField</code>等等都需要有一套统一的更新机制，可能不是一个最简单的办法。</p>
<p><strong><u>而微信切换的方案是，刷新<code>keyWindow</code>的<code>rootViewController</code>，然后跳转到设置页，所以你会看到切换语言的一瞬间界面出现匪夷所思的bug，如下图</u></strong></p>
<p><img src="http://ww1.sinaimg.cn/large/006tKfTcly1ff9iduf60aj306y0cbjrm.jpg" alt=""></p>
<p>其实微信的方案是个最简单的方案，只不过没有处理好这个小系统bug。</p>
<h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><h2 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h2><h3 id="NSBundle"><a href="#NSBundle" class="headerlink" title="NSBundle"></a>NSBundle</h3><p>其实大家应该知道，无论是代码还是Storyboard/Xib，显示的国际化字符串都会走这个方法，传入一个<code>key</code>，获取<code>localizedString</code>。</p>
<p><code>NSBundle</code>的方法：</p>
<pre><code class="objective-c">- (NSString *)localizedStringForKey:(NSString *)key value:(nullable NSString *)value table:(nullable NSString *)tableName;
</code></pre>
<p>比如我们常用的宏<code>NSLocalizedString(@&quot;done&quot;, nil)</code></p>
<pre><code class="objective-c">#define NSLocalizedString(key, comment) \
        [NSBundle.mainBundle localizedStringForKey:(key) value:@&quot;&quot; table:nil]
</code></pre>
<p>那么为何，系统切换语言的时候，此方法返回的就是对应语言（前提做了该语言的国际化）的字符串呢？原因在是哪个<code>bundle</code>调用了这个方法，一般默认的都是<code>NSBundle.mainBundle</code>这个对象。</p>
<pre><code> po [NSBundle allBundles]

&lt;__NSArrayI 0x608000052f60&gt;(
NSBundle &lt;/Users/DarkAngel/Library/Developer/CoreSimulator/Devices/CF831783-E4A6-4EC2-AB99-E04304331C3A/data/Containers/Bundle/Application/B391ED77-F57B-4B5E-9E53-CFD1245583D8/LanguageSettingsDemo.app/en.lproj&gt; (not yet loaded),
NSBundle &lt;/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/Frameworks/UIKit.framework/Artwork.bundle&gt; (not yet loaded),
DABundle &lt;/Users/DarkAngel/Library/Developer/CoreSimulator/Devices/CF831783-E4A6-4EC2-AB99-E04304331C3A/data/Containers/Bundle/Application/B391ED77-F57B-4B5E-9E53-CFD1245583D8/LanguageSettingsDemo.app&gt; (loaded)
)
</code></pre><p>可以看到有默认加载的bundle，还有个没加载的en bundle。所以，切换语言，其实只要切换了<code>bundle</code>对象，就可以让这个<code>bundle</code>根据<code>key</code>返回不同的<code>localizedString</code>。</p>
<h3 id="NSUserDefaults"><a href="#NSUserDefaults" class="headerlink" title="NSUserDefaults"></a>NSUserDefaults</h3><p>其实语言设置，只要修改<code>AppleLanguages</code>对应的值就好了。这样才能加载正确语言的<code>Storyboard/Xib</code>，以及一些<code>resources</code>(图片之类的)。</p>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>方案其实很简单，每次切换语言，把用户选择的语言保存在本地，同时更改<code>bundle</code>对象，然后刷新页面就可以了。</p>
<p><img src="http://ww2.sinaimg.cn/large/006tKfTcly1ff9ji4gz3kg306y0cce09.gif" alt=""></p>
<h2 id="技术细节"><a href="#技术细节" class="headerlink" title="技术细节"></a>技术细节</h2><h3 id="保存用户设置"><a href="#保存用户设置" class="headerlink" title="保存用户设置"></a>保存用户设置</h3><p>很简单，保存在<code>NSUserDefaults</code>里。</p>
<p>这里需要说明的是<strong>跟随手机系统</strong>，即清除用户自定义设置，只需要将<code>AppleLanguages</code>字段设为<code>nil</code>即可。</p>
<p>但是当<code>AppleLanguages</code>字段设为nil，你再去获取它的值时，会发现他已经变成了系统语言的默认值。这里可以参考<a href="http://blog.darkangel7.com/2017/05/05/iOS中NSUserDefaults的黑科技/">这篇文章</a>。</p>
<p>.h</p>
<pre><code class="objective-c">/**
 设置类
 */
@interface UWConfig : NSObject
/**
 用户自定义使用的语言，当传nil时，等同于resetSystemLanguage
 */
@property (class, nonatomic, strong, nullable) NSString *userLanguage;
/**
 重置系统语言
 */
+ (void)resetSystemLanguage;
@end
</code></pre>
<p>.m</p>
<pre><code class="objective-c">#import &quot;UWConfig.h&quot;

static NSString *const UWUserLanguageKey = @&quot;UWUserLanguageKey&quot;;
#define STANDARD_USER_DEFAULT  [NSUserDefaults standardUserDefaults]

@implementation UWConfig
+ (void)setUserLanguage:(NSString *)userLanguage
{
    //跟随手机系统
    if (!userLanguage.length) {
        [self resetSystemLanguage];
        return;
    }
    //用户自定义
    [STANDARD_USER_DEFAULT setValue:userLanguage forKey:UWUserLanguageKey];
    [STANDARD_USER_DEFAULT setValue:@[userLanguage] forKey:@&quot;AppleLanguages&quot;];
    [STANDARD_USER_DEFAULT synchronize];
}

+ (NSString *)userLanguage
{
    return [STANDARD_USER_DEFAULT valueForKey:UWUserLanguageKey];
}

/**
 重置系统语言
 */
+ (void)resetSystemLanguage
{
    [STANDARD_USER_DEFAULT removeObjectForKey:UWUserLanguageKey];
    [STANDARD_USER_DEFAULT setValue:nil forKey:@&quot;AppleLanguages&quot;];
    [STANDARD_USER_DEFAULT synchronize];
}

@end
</code></pre>
<p>在需要的地方调用即可，如</p>
<pre><code class="objective-c">   if (indexPath.row == 0) {
        [UWConfig setUserLanguage:nil];
    } else if (indexPath.row == 1) {
        [UWConfig setUserLanguage:@&quot;zh-Hans&quot;];
    } else {
        [UWConfig setUserLanguage:@&quot;en&quot;];
    }
</code></pre>
<h3 id="切换Bundle"><a href="#切换Bundle" class="headerlink" title="切换Bundle"></a>切换Bundle</h3><p>当需要展示内容时，才需要用到<code>bundle</code>，我们要手动切换<code>bundle</code>对象，就用到了这几个方法：</p>
<pre><code class="objective-c">+ (nullable instancetype)bundleWithPath:(NSString *)path;
- (nullable instancetype)initWithPath:(NSString *)path NS_DESIGNATED_INITIALIZER;

+ (nullable instancetype)bundleWithURL:(NSURL *)url NS_AVAILABLE(10_6, 4_0);
- (nullable instancetype)initWithURL:(NSURL *)url NS_AVAILABLE(10_6, 4_0);
</code></pre>
<p>这里直接上代码</p>
<p>.h</p>
<pre><code class="objective-c">@interface NSBundle (UWUtils)

+ (BOOL)isChineseLanguage;

+ (NSString *)currentLanguage;

@end
</code></pre>
<p>.m</p>
<pre><code class="objective-c">#import &quot;NSBundle+UWUtils.h&quot;

@interface UWBundle : NSBundle

@end

@implementation NSBundle (UWUtils)

+ (BOOL)isChineseLanguage
{
    NSString *currentLanguage = [self currentLanguage];
    if ([currentLanguage hasPrefix:@&quot;zh-Hans&quot;]) {
        return YES;
    } else {
        return NO;
    }
}

+ (NSString *)currentLanguage
{
    return [UWConfig userLanguage] ? : [NSLocale preferredLanguages].firstObject;
}

+ (void)load
{
    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{
        //动态继承、交换，方法类似KVO，通过修改[NSBundle mainBundle]对象的isa指针，使其指向它的子类UWBundle，这样便可以调用子类的方法；其实这里也可以使用method_swizzling来交换mainBundle的实现，来动态判断，可以同样实现。
        object_setClass([NSBundle mainBundle], [UWBundle class]);
    });
}

@end

@implementation UWBundle

- (NSString *)localizedStringForKey:(NSString *)key value:(NSString *)value table:(NSString *)tableName
{
    if ([UWBundle uw_mainBundle]) {
        return [[UWBundle uw_mainBundle] localizedStringForKey:key value:value table:tableName];
    } else {
        return [super localizedStringForKey:key value:value table:tableName];
    }
}

+ (NSBundle *)uw_mainBundle
{
    if ([NSBundle currentLanguage].length) {
        NSString *path = [[NSBundle mainBundle] pathForResource:[NSBundle currentLanguage] ofType:@&quot;lproj&quot;];
        if (path.length) {
            return [NSBundle bundleWithPath:path];
        }
    }
    return nil;
}

@end
</code></pre>
<p>这里涉及到了<code>runtime</code>的使用，代码中有注释，这里就不展开了。</p>
<h3 id="刷新页面"><a href="#刷新页面" class="headerlink" title="刷新页面"></a>刷新页面</h3><p>用微信的思路，简单化，不必要处理很多，我们只要替换<code>keyWindow</code>的<code>rootViewController</code>就好，同时解决微信的bug。</p>
<pre><code class="objective-c">    UITabBarController *tbc = [[UIStoryboard storyboardWithName:@&quot;Main&quot; bundle:[NSBundle mainBundle]] instantiateInitialViewController];
    //我这里的storyboard为了便于多人合作，这里只包含根tabBarController和多个nvc，每个nvc只有自己的rootViewController
    //跳转到个人中心
    tbc.selectedIndex = 4;
    //创建设置页面
    UWSettingViewController *vc1 = [[UIStoryboard storyboardWithName:@&quot;Main&quot; bundle:[NSBundle mainBundle]] instantiateViewControllerWithIdentifier:NSStringFromClass([UWSettingViewController class])];
    vc1.hidesBottomBarWhenPushed = YES;
    //创建语言切换页
    UWLanguageSettingsViewController *vc2 = [[UIStoryboard storyboardWithName:@&quot;Main&quot; bundle:[NSBundle mainBundle]] instantiateViewControllerWithIdentifier:NSStringFromClass([UWLanguageSettingsViewController class])];
    vc2.hidesBottomBarWhenPushed = YES;
    UINavigationController *nvc = tbc.selectedViewController;
    //备用
    NSMutableArray *vcs = nvc.viewControllers.mutableCopy;
    [vcs addObjectsFromArray:@[vc1, vc2]];
    //解决奇怪的动画bug。异步执行
    dispatch_async(dispatch_get_main_queue(), ^{
        //注意刷新rootViewController的时机，在主线程异步执行
        //先刷新rootViewController
        [UIApplication sharedApplication].keyWindow.rootViewController = tbc;
        //然后再给个人中心的nvc设置viewControllers
        nvc.viewControllers = vcs;
        //一些UI提示，可以提供更友好的用户交互（也可以删掉）
        [UWProgressHUD showLoadingWithMessage:NSLocalizedString(UWSettingMessage, nil)];
        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(.5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
            [UWProgressHUD dismiss];
        });
    });
</code></pre>
<p>整体下来，就可以实现在App内优雅的切换语言。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实在实践过程中，坑还是很多的，欢迎提问。</p>
<p>下面附上个简单的<a href="https://github.com/DarkAngel7/Demos-LanguageSettingsDemo/" target="_blank" rel="external">Demo</a>，是上面说的简化版本，大家有需要可以下载看下。里面有小福利哦，慢慢找吧~</p>
<p>最后，<a href="https://itunes.apple.com/cn/app/you-ke-gong-chang/id1034170822?mt=8" target="_blank" rel="external">优客工场</a>欢迎您。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;随着公司业务的发展，App版本的迭代，相信不少App都需要英文化（国际化）。App英文化，不外乎这三点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;纯代码中
    
    </summary>
    
    
      <category term="iOS技术分享" scheme="http://blog.darkangel7.com/tags/iOS%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>Jenkins部署MacOS Slave实现持续集成(iOS)</title>
    <link href="http://blog.darkangel7.com/2017/04/28/Jenkins%E9%83%A8%E7%BD%B2MacOS%20Slave%E5%AE%9E%E7%8E%B0%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90(iOS)/"/>
    <id>http://blog.darkangel7.com/2017/04/28/Jenkins部署MacOS Slave实现持续集成(iOS)/</id>
    <published>2017-04-28T10:49:16.000Z</published>
    <updated>2017-05-04T04:30:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>解决Linux服务器上的Jenkins无法构建Xcode工程</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于Linux服务器无法安装Xcode，所以Jenkins无法通过shell来调用xcodebuild、xcrun等命令来构建Xcode工程，因此无法持续集成，敏捷开发。下面介绍一种配置Jenkins节点的方式，来实现Linux上的Jenkins构建Xcode工程，并上传ipa到蒲公英pgyer来进行测试。</p>
<h2 id="一、配置MacOS-Slave"><a href="#一、配置MacOS-Slave" class="headerlink" title="一、配置MacOS Slave"></a>一、配置MacOS Slave</h2><p>Jenkins有个强大的功能，配置Slave(奴隶)服务器，来实现分布式部署构建。具体步骤如下：</p>
<h3 id="1-配置Mac电脑。"><a href="#1-配置Mac电脑。" class="headerlink" title="1. 配置Mac电脑。"></a>1. 配置Mac电脑。</h3><p>在<strong>系统偏好设置</strong> &gt; <strong>共享</strong> 中开启 <strong>远程登录</strong>，如下图：<br><img src="https://ww3.sinaimg.cn/large/006tNc79ly1ff2hls2iauj31140tidjg.jpg" alt=""> </p>
<h3 id="2-创建节点。"><a href="#2-创建节点。" class="headerlink" title="2. 创建节点。"></a>2. 创建节点。</h3><p>Jenkins &gt; 系统管理 &gt;  管理节点 &gt; 新建节点，输入节点名称，记得勾选 <code>Permanent Agent</code>，点击OK。</p>
<h3 id="3-配置节点。"><a href="#3-配置节点。" class="headerlink" title="3. 配置节点。"></a>3. 配置节点。</h3><p><img src="https://ww2.sinaimg.cn/large/006tNc79ly1ff2hfwxx8ej31eg0ts0wt.jpg" alt="">其中要保证<code>/User/Shared/Jenkins/</code>目录的权限为ssh链接的用户可读写。</p>
<p>Host是Mac的ip地址，Credentials是ssh登录Mac时需要的账户和密码。可以添加一个</p>
<p><img src="https://ww4.sinaimg.cn/large/006tNc79ly1ff2hhcg0f1j31gq0r842o.jpg" alt=""></p>
<p><strong>下面的部分很重要</strong>：<img src="https://ww2.sinaimg.cn/large/006tNc79ly1ff2hiwj7mpj31gs0p4dj8.jpg" alt=""></p>
<p>PATH环境变量，需要在Mac上通过</p>
<pre><code>echo $PATH
/opt/iOSOpenDev/bin:/opt/local/bin:/opt/local/sbin:/opt/local/bin:/opt/local/sbin:/opt/local/bin:/opt/local/sbin:/opt/local/bin:/opt/local/sbin:/opt/local/bin:/opt/local/sbin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/opt/local/bin:/opt/local/sbin/
</code></pre><p>获取，然后copy过去。</p>
<p>Keychains and Provisioning Profiles路径要填写正确。没有这个选项的安装<a href="http://wiki.jenkins-ci.org/display/JENKINS/Keychains+and+Provisioning+Profiles+Plugin" target="_blank" rel="external">Keychains and Provisioning Profiles Management</a>插件。</p>
<h3 id="4-最后保存。"><a href="#4-最后保存。" class="headerlink" title="4. 最后保存。"></a>4. 最后保存。</h3><p>如果看到</p>
<p><img src="https://ww2.sinaimg.cn/large/006tNc79ly1ff2hwlrqw8j30e203uglm.jpg" alt=""></p>
<p>即添加Mac Slave成功，且Mac Slave在线。若连不上，请反复确认<strong>远程工作目录</strong>的权限。</p>
<h2 id="二、配置Jenkins系统设置。"><a href="#二、配置Jenkins系统设置。" class="headerlink" title="二、配置Jenkins系统设置。"></a>二、配置Jenkins系统设置。</h2><h3 id="1-上传证书和描述文件。"><a href="#1-上传证书和描述文件。" class="headerlink" title="1. 上传证书和描述文件。"></a>1. 上传证书和描述文件。</h3><p>在 <strong>Jenkins</strong> &gt; <strong>系统管理</strong> &gt; <strong>Keychains and Provisioning Profiles Management</strong>中上传打包用的证书和描述文件。如下图：</p>
<p><img src="https://ww4.sinaimg.cn/large/006tNc79ly1ff2jcabj18j31kw0tijyh.jpg" alt=""></p>
<p><img src="https://ww2.sinaimg.cn/large/006tNc79ly1ff2jclndwnj31jy0siwic.jpg" alt=""></p>
<p>保存。</p>
<h3 id="2-在-Jenkins-gt-系统管理-gt-系统设置（全局设置）中设置："><a href="#2-在-Jenkins-gt-系统管理-gt-系统设置（全局设置）中设置：" class="headerlink" title="2. 在 Jenkins &gt; 系统管理 &gt; 系统设置（全局设置）中设置："></a>2. 在 <strong>Jenkins</strong> &gt; <strong>系统管理</strong> &gt; <strong>系统设置</strong>（全局设置）中设置：</h3><p><img src="https://ww1.sinaimg.cn/large/006tNc79ly1ff2j6764qgj31ei0t6adx.jpg" alt=""></p>
<p>很关键。<strong>Keychain</strong>的路径和密码需要填写Mac中登录用户的密码。</p>
<h3 id="3-在-Jenkins-gt-系统管理-gt-Configure-Global-Security-中配置："><a href="#3-在-Jenkins-gt-系统管理-gt-Configure-Global-Security-中配置：" class="headerlink" title="3. 在 Jenkins &gt; 系统管理 &gt; Configure Global Security 中配置："></a>3. 在 <strong>Jenkins</strong> &gt; <strong>系统管理</strong> &gt; <strong>Configure Global Security</strong> 中配置：</h3><p><img src="https://ww2.sinaimg.cn/large/006tNc79ly1ff2j8ffcsrj31jw0ckjt4.jpg" alt=""></p>
<p>开启Safe HTML。</p>
<h2 id="三、配置iOS项目。"><a href="#三、配置iOS项目。" class="headerlink" title="三、配置iOS项目。"></a>三、配置iOS项目。</h2><h3 id="1-安装插件。"><a href="#1-安装插件。" class="headerlink" title="1. 安装插件。"></a>1. 安装插件。</h3><p>安装 <code>build-name-setter</code>、<code>description setter plugin</code>插件。</p>
<h3 id="2-Jenkins-gt-新建。"><a href="#2-Jenkins-gt-新建。" class="headerlink" title="2. Jenkins &gt; 新建。"></a>2. <strong>Jenkins</strong> &gt; <strong>新建</strong>。</h3><p><img src="https://ww2.sinaimg.cn/large/006tNc79ly1ff2iw797sjj318q0vidm6.jpg" alt=""></p>
<h3 id="3-General"><a href="#3-General" class="headerlink" title="3. General."></a>3. <strong>General</strong>.</h3><p><img src="https://ww3.sinaimg.cn/large/006tNc79ly1ff2jedt21qj31kw0u2afo.jpg" alt=""></p>
<p>这里添加了参数化构建过程，为了在每次Build时，可以填写更新说明，所以这里天添加了名为<code>News</code>的参数，当用户构建时填写了内容，可以在之后的脚本中通过<code>${News}</code>来获取<code>News</code>的值。</p>
<p><img src="https://ww1.sinaimg.cn/large/006tNc79ly1ff2jf005ogj31kw0o1q5k.jpg" alt=""></p>
<p>这里指定Mac Slave服务器作为构建Xcode工程的Slave服务器，Xcode打包构建全部交给这个节点（Slave服务器）来完成。</p>
<p><img src="https://ww1.sinaimg.cn/large/006tNc79ly1ff2jfc0bfij31kw0d2jsv.jpg" alt=""></p>
<h3 id="4-源码管理。"><a href="#4-源码管理。" class="headerlink" title="4. 源码管理。"></a>4. 源码管理。</h3><p><img src="https://ww4.sinaimg.cn/large/006tNc79ly1ff2jh0iaijj31jk0uk41x.jpg" alt=""></p>
<p>这里填写本地或者远程的代码仓库（如gitlab或者git）。下面的Branch填写指定分支。</p>
<h3 id="5-构建触发器。"><a href="#5-构建触发器。" class="headerlink" title="5. 构建触发器。"></a>5. 构建触发器。</h3><p>这里暂时不设置，设置了可以自动化测试，和其他脚本配合使用。</p>
<h3 id="6-构建环境。"><a href="#6-构建环境。" class="headerlink" title="6. 构建环境。"></a>6. 构建环境。</h3><p><img src="https://ww1.sinaimg.cn/large/006tNc79ly1ff2jqxdzccj31kw0txq9d.jpg" alt=""></p>
<p><img src="https://ww3.sinaimg.cn/large/006tNc79ly1ff2jssknawj31kw0pnn2s.jpg" alt=""></p>
<p>把之前上传的证书和描述文件添加上。</p>
<p>设置Build名称，这里添加了自定义名称。注意，高级里面只勾选第一个，不要勾选 <code>Set build name after build ends</code>，否则会报错。</p>
<h3 id="7-构建"><a href="#7-构建" class="headerlink" title="7. 构建"></a>7. 构建</h3><p><img src="https://ww2.sinaimg.cn/large/006tNc79ly1ff2jwre537j31kw0pygr0.jpg" alt=""></p>
<p>这里使用的脚本。</p>
<pre><code>export LANG=&quot;en_US.UTF-8&quot;

security -v unlock-keychain -p &quot;yourpassword&quot;

ipa_name=&quot;URWork_iOS_beta&quot;
build_path=&quot;${WORKSPACE}/build/&quot;
fastlane gym --workspace URWorkClient.xcworkspace --scheme URWorkClient --clean --configuration Beta --export_method ad-hoc --output_name ${ipa_name} --output_directory ${build_path}

curl -F &quot;file=@${build_path}${ipa_name}.ipa&quot; \
-F &quot;uKey=yourUKey&quot; \
-F &quot;_api_key=yourApiKey&quot; \
-F &quot;updateDescription=${News}&quot; \
https://www.pgyer.com/apiv1/app/upload
</code></pre><h4 id="最重要、最重要、最重要："><a href="#最重要、最重要、最重要：" class="headerlink" title="最重要、最重要、最重要："></a><strong>最重要、最重要、最重要：</strong></h4><p>Linux服务器上的Jenkins调用Mac Slave时，是通过之前设置的<strong>SSH</strong>登录的方式，而Apple为了安全，在ssh登录时，是不允许读取<strong>Keychains</strong>（钥匙串）的，所以 <code>security -v unlock-keychain -p &quot;yourpassword&quot;</code>这行命令就很重要了。在构建打包前，先解锁Keychains。</p>
<p>当然这里 <strong>fastlane</strong> 已经提前通过<strong>Homebrew</strong>安装好了，这里不再赘述。</p>
<blockquote>
<p><em>整体脚本的流程是，先解锁Keychain，然后用fastlane快速打包，最后上传到蒲公英平台，等待测试。</em></p>
</blockquote>
<h3 id="8-构建后操作。"><a href="#8-构建后操作。" class="headerlink" title="8. 构建后操作。"></a>8. 构建后操作。</h3><p><img src="https://ww2.sinaimg.cn/large/006tNc79ly1ff2k7cb7ptj31kw0ktjue.jpg" alt=""></p>
<p>附代码：</p>
<pre><code>&lt;h3&gt;更新说明:&lt;/h3&gt;&lt;p&gt;${News}&lt;/p&gt;&lt;a href=&quot;http://www.pgyer.com/urwork_ios&quot; style=&quot;display:block;margin:10px 0px;&quot; target=&quot;_blank&quot;&gt;点击跳转到下载页&lt;/a&gt;&lt;/br&gt;&lt;img src=&quot;http://www.pgyer.com/app/qrcode/urwork_ios&quot;&gt;
</code></pre><p>构建完成后，把之前用户输入的<strong>更新说明</strong>以及<strong>蒲公英下载地址</strong>和<strong>二维码</strong>通通显示在Build Description中。</p>
<h2 id="四、整体测试"><a href="#四、整体测试" class="headerlink" title="四、整体测试"></a>四、整体测试</h2><h3 id="1-打开Jenkins。"><a href="#1-打开Jenkins。" class="headerlink" title="1. 打开Jenkins。"></a>1. 打开Jenkins。</h3><p><img src="https://ww1.sinaimg.cn/large/006tNc79ly1ff2kbajk7cj31kw0u6jxm.jpg" alt=""></p>
<h3 id="2-点击develop-iOS。"><a href="#2-点击develop-iOS。" class="headerlink" title="2. 点击develop_iOS。"></a>2. 点击develop_iOS。</h3><p><img src="https://ww1.sinaimg.cn/large/006tNc79ly1ff2kang8dkj31kw0tf7c5.jpg" alt=""></p>
<h3 id="3-点击Build-with-Parameters"><a href="#3-点击Build-with-Parameters" class="headerlink" title="3. 点击Build with Parameters."></a>3. 点击Build with Parameters.</h3><p><img src="https://ww2.sinaimg.cn/large/006tNc79ly1ff2kdk1zdfj31kw0tktds.jpg" alt=""></p>
<h3 id="4-开始构建。"><a href="#4-开始构建。" class="headerlink" title="4. 开始构建。"></a>4. 开始构建。</h3><p><img src="https://ww4.sinaimg.cn/large/006tNc79ly1ff2keezip1j31kw0tf10n.jpg" alt=""></p>
<h3 id="5-等待构建完成即可。"><a href="#5-等待构建完成即可。" class="headerlink" title="5. 等待构建完成即可。"></a>5. 等待构建完成即可。</h3><p>这里也可以查看构建进度：点击最新的一次构建</p>
<p><img src="https://ww3.sinaimg.cn/large/006tNc79ly1ff2kg18untj31kw0s1tdq.jpg" alt=""></p>
<p>点击Console Output<br><img src="https://ww4.sinaimg.cn/large/006tNc79ly1ff2kgpirr9j31kw0sj13w.jpg" alt=""></p>
<p>在这里可以查看一些日志，如果出错了，也可以在这里查询。</p>
<h2 id="五、总结。"><a href="#五、总结。" class="headerlink" title="五、总结。"></a>五、总结。</h2><p>使用Jenkins打包Xcode工程整体过程很曲折，坑很多，按照这些来，可能还会遇到一些问题，附上一些链接，以供参考。</p>
<h2 id="附"><a href="#附" class="headerlink" title="附"></a>附</h2><ul>
<li><a href="http://www.jianshu.com/p/371595ef08fe" target="_blank" rel="external">Jenkins+ Xcode+ 蒲公英 实现IOS自动化打包和分发</a></li>
<li><a href="http://www.jianshu.com/p/41ecb06ae95f" target="_blank" rel="external">手把手教你利用Jenkins持续集成iOS项目</a></li>
<li><a href="http://www.jianshu.com/p/62fa8083b45c" target="_blank" rel="external">Jenkins签名问题</a></li>
<li><a href="https://www.pgyer.com/doc/view/jenkins_ios" target="_blank" rel="external">使用 Jenkins 实现持续集成 (iOS)</a></li>
<li><a href="https://www.pgyer.com/doc/view/jenkins" target="_blank" rel="external">使用 Jenkins 实现持续集成 (Android)</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;解决Linux服务器上的Jenkins无法构建Xcode工程&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;由于Linux服务器无法安装Xcode，所以Jenkins无法通
    
    </summary>
    
    
      <category term="iOS技术分享" scheme="http://blog.darkangel7.com/tags/iOS%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>iOS中UIWebView与WKWebView、JavaScript与OC交互、Cookie管理看我就够（上）</title>
    <link href="http://blog.darkangel7.com/2016/09/01/iOS%E4%B8%ADUIWebView%E4%B8%8EWKWebView%E3%80%81JavaScript%E4%B8%8EOC%E4%BA%A4%E4%BA%92%E3%80%81Cookie%E7%AE%A1%E7%90%86%E7%9C%8B%E6%88%91%E5%B0%B1%E5%A4%9F%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>http://blog.darkangel7.com/2016/09/01/iOS中UIWebView与WKWebView、JavaScript与OC交互、Cookie管理看我就够（上）/</id>
    <published>2016-09-01T07:37:29.000Z</published>
    <updated>2017-05-09T10:41:20.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1fff1sa06wrj30sg0iwwi9.jpg" alt=""></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>iOS开发中，用来显示一个html页、H5页，经常会用的一个控件是WebView。说到WebView，你知道多少呢？是简单的展示，还是要和OC交互实现比较复杂的功能呢？本文将为您介绍iOS中的WebView，并且由浅到深，一步步带你了解并掌握WebView的用法，JavaScript与Objective的交互，以及Cookie的管理、js的调试等。</p>
<p>文章因涉及到的内容较多，因此拆分成以下几部分：</p>
<ul>
<li>iOS中UIWebView与WKWebView、JavaScript与OC交互、Cookie管理看我就够（上）</li>
<li><a href="">iOS中UIWebView与WKWebView、JavaScript与OC交互、Cookie管理看我就够（中）</a>（待填坑…）</li>
<li><a href="">iOS中UIWebView与WKWebView、JavaScript与OC交互、Cookie管理看我就够（下）</a>（待填坑…）</li>
</ul>
<p>关于文中提到的一些内容，这里我准备了个<a href="">Demo</a>，有需要的小伙伴可以下载。</p>
<h1 id="UIWebView"><a href="#UIWebView" class="headerlink" title="UIWebView"></a>UIWebView</h1><h2 id="UIWebView基本用法"><a href="#UIWebView基本用法" class="headerlink" title="UIWebView基本用法"></a>UIWebView基本用法</h2><p>首先要介绍的就是我们的老朋友<code>UIWebView</code>。相信对大多数小伙伴儿而言，<code>UIWebView</code>和<code>UILabel</code>一样，都是最早接触的控件了，其实<code>UIWebView</code>用法比较简单（功能基本能满足需求），简单的创建，并且调用</p>
<pre><code class="objective-c">- (void)loadRequest:(NSURLRequest *)request;
- (void)loadHTMLString:(NSString *)string baseURL:(nullable NSURL *)baseURL;
- (void)loadData:(NSData *)data MIMEType:(NSString *)MIMEType textEncodingName:(NSString *)textEncodingName baseURL:(NSURL *)baseURL;
</code></pre>
<p>这些方法，加载就可以了。<br>当然，如果需要监听页面加载的结果，或者需要判断是否允许打开某个URL，那需要设置<code>UIWebView</code>的<code>delegate</code>，代理只需要遵循<code>&lt;UIWebViewDelegate&gt;</code>协议，并且在代理中实现下面的这些可选方法就可以：</p>
<pre><code class="objective-c">__TVOS_PROHIBITED @protocol UIWebViewDelegate &lt;NSObject&gt;

@optional
- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType;
- (void)webViewDidStartLoad:(UIWebView *)webView;
- (void)webViewDidFinishLoad:(UIWebView *)webView;
- (void)webView:(UIWebView *)webView didFailLoadWithError:(nullable NSError *)error;

@end
</code></pre>
<h2 id="UIWebView中JavaScript与Objective的交互"><a href="#UIWebView中JavaScript与Objective的交互" class="headerlink" title="UIWebView中JavaScript与Objective的交互"></a>UIWebView中JavaScript与Objective的交互</h2><p>这里不详细讨论一些很好的第三方实现，比如<a href="https://github.com/marcuswestin/WebViewJavascriptBridge" target="_blank" rel="external">WebViewJavascriptBridge</a>，单纯的讲讲native端JS与OC的交互实现方式，读完了下面的部分，相信你也会实现一个简单的<code>bridge</code>了。</p>
<h3 id="UIWebView-OC调用JS"><a href="#UIWebView-OC调用JS" class="headerlink" title="UIWebView OC调用JS"></a>UIWebView OC调用JS</h3><h4 id="1-stringByEvaluatingJavaScriptFromString"><a href="#1-stringByEvaluatingJavaScriptFromString" class="headerlink" title="1. stringByEvaluatingJavaScriptFromString:"></a>1. stringByEvaluatingJavaScriptFromString:</h4><p>最常用的方法，很简单，只要调用<code>- (nullable NSString *)stringByEvaluatingJavaScriptFromString:(NSString *)script;</code>就可以了，如：</p>
<pre><code class="objective-c">    self.navigationItem.title = [webView stringByEvaluatingJavaScriptFromString:@&quot;document.title&quot;];
</code></pre>
<p>虽然比较方便，但是缺点也有：</p>
<ol>
<li>该方法不能判断调用了一个js方法之后，是否发生了错误。当错误发生时，返回值为nil，而当调用一个方法本身没有返回值时，返回值也为nil，所以无法判断是否调用成功了。</li>
<li>返回值类型为<code>nullable NSString *</code>，就意味着当调用的js方法有返回值时，都以字符串返回，不够灵活。当返回值是一个js的Array时，还需要解析字符串，比较麻烦。</li>
</ol>
<p>对于上述缺点，可以通过使用JavaScriptCore（iOS 7.0 +）来解决。</p>
<h4 id="2-JavaScriptCore（iOS-7-0-）"><a href="#2-JavaScriptCore（iOS-7-0-）" class="headerlink" title="2. JavaScriptCore（iOS 7.0 +）"></a>2. JavaScriptCore（iOS 7.0 +）</h4><p>想必大家不会陌生吧，前些日子弄的沸沸扬扬的<code>JSPatch</code>被禁事件中，最核心的就是它了。因为<code>JavaScriptCore</code>的JS到OC的映射，可以替换各种js方法成oc方法，所以其<strong>动态性（配合runtime的不安全性）</strong>也就成为了<code>JSPatch</code>被<strong>Apple</strong>禁掉的最主要原因。这里讲下<code>UIWebView</code>通过<code>JavaScriptCore</code>来实现OC-&gt;JS。</p>
<p>其实WebKit都有一个内嵌的js环境，一般我们在页面加载完成之后，获取js上下文，然后通过<code>JSContext</code>的<code>evaluateScript:</code>方法来获取返回值。因为该方法得到的是一个<code>JSValue</code>对象，所以支持JavaScript的Array、Number、String、对象等数据类型。</p>
<pre><code class="objective-c">- (void)webViewDidFinishLoad:(UIWebView *)webView
{
    //更新标题，这是上面的讲过的方法
    //self.navigationItem.title = [webView stringByEvaluatingJavaScriptFromString:@&quot;document.title&quot;];

    //获取该UIWebView的javascript上下文
    JSContext *jsContext = [self.webView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;];

    //这也是一种获取标题的方法。
    JSValue *value = [self.jsContext evaluateScript:@&quot;document.title&quot;];
    //更新标题
    self.navigationItem.title = value.toString;
}
</code></pre>
<p>该方法解决了<code>stringByEvaluatingJavaScriptFromString:</code>返回值只是<code>NSString</code>的问题。</p>
<p>那么如果我执行了一个不存在的方法，比如</p>
<pre><code class="objective-c">[self.jsContext evaluateScript:@&quot;document.titlexxxx&quot;];
</code></pre>
<p>那么必然会报错，报错了，可以通过<code>@property (copy) void(^exceptionHandler)(JSContext *context, JSValue *exception);</code>，设置该block来获取异常。</p>
<pre><code class="objective-c">//在调用前，设置异常回调
[self.jsContext setExceptionHandler:^(JSContext *context, JSValue *exception){
        NSLog(@&quot;%@&quot;, exception);
}];
//执行方法
JSValue *value = [self.jsContext evaluateScript:@&quot;document.titlexxxx&quot;];
</code></pre>
<p>该方法，也很好的解决了<code>stringByEvaluatingJavaScriptFromString:</code>调用js方法后，出现错误却捕获不到的缺点。</p>
<h3 id="UIWebView-JS调用OC"><a href="#UIWebView-JS调用OC" class="headerlink" title="UIWebView JS调用OC"></a>UIWebView JS调用OC</h3><h4 id="1-Custom-URL-Scheme（拦截URL）"><a href="#1-Custom-URL-Scheme（拦截URL）" class="headerlink" title="1. Custom URL Scheme（拦截URL）"></a>1. Custom URL Scheme（拦截URL）</h4><p>比如<code>darkangel://</code>。方法是在html或者js中，点击某个按钮触发事件时，跳转到自定义URL Scheme构成的链接，而Objective-C中捕获该链接，从中解析必要的参数，实现JS到OC的一次交互。比如页面中一个a标签，链接如下：</p>
<pre><code>&lt;a href=&quot;darkangel://smsLogin?username=12323123&amp;code=892845&quot;&gt;短信验证登录&lt;/a&gt;
</code></pre><p>而在Objective-C中，只要遵循了<code>UIWebViewDelegate</code>协议，那么每次打开一个链接之前，都会触发方法</p>
<pre><code>- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType；
</code></pre><p>在该方法中，捕获该链接，并且返回NO（<strong>阻止本次跳转</strong>），从而执行对应的OC方法。</p>
<pre><code>- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType
{
    //标准的URL包含scheme、host、port、path、query、fragment等
    NSURL *URL = request.URL;    
    if ([URL.scheme isEqualToString:@&quot;darkangel&quot;]) {
        if ([URL.host isEqualToString:@&quot;smsLogin&quot;]) {
            NSLog(@&quot;短信验证码登录，参数为 %@&quot;, URL.query);
            return NO;
        }
    }
    return YES;
}
</code></pre><p>当用户点击<strong>短信验证登录</strong>时，控制台会输出<code>短信验证码登录，参数为 username=12323123&amp;code=892845</code>。参数可以是一个json格式并且URLEncode过的字符串，这样就可以实现复杂参数的传递（比如<a href="https://github.com/marcuswestin/WebViewJavascriptBridge" target="_blank" rel="external">WebViewJavascriptBridge</a>）。</p>
<p><strong>优点</strong>：泛用性强，可以配合h5实现页面动态化。比如页面中一个活动链接到活动详情页，当native尚未开发完毕时，链接可以是一个h5链接，等到native开发完毕时，可以通过该方法跳转到native页面，实现页面动态化。且该方案适用于Android和iOS，泛用性很强。</p>
<p><strong>缺点</strong>：无法直接获取本次交互的返回值，比较适合单向传参，且不关心回调的情景，比如h5页面跳转到native页面等。</p>
<p>其实，<a href="https://github.com/marcuswestin/WebViewJavascriptBridge" target="_blank" rel="external">WebViewJavascriptBridge</a>使用的方案就是<strong>拦截URL</strong>，为了解决无法直接获取返回值的缺点，它采用了将一个名为<code>callback</code>的<code>function</code>作为参数，通过一些封装，传递到OC（<strong>js-&gt;oc</strong> 传递参数和callbackId），然后在OC端执行完毕，再通过<code>block</code>来回调callback（<strong>oc-&gt;js</strong>，传递返回值参数），实现异步获取返回值，比如在js端调用</p>
<pre><code class="javascript">//JS调用OC的分享方法（当然需要OC提前注册）share为方法名，shareData为参数，后面的为回调function
WebViewJavascriptBridge.callHandler(&#39;share&#39;, shareData, function(response) {
   //OC端通过block回调分享成功或者失败的结果
   alert(response);   
});
</code></pre>
<p>具体的可以看下它的源码，还是很值得学习的。</p>
<h4 id="2-JavaScriptCore（iOS-7-0-）-1"><a href="#2-JavaScriptCore（iOS-7-0-）-1" class="headerlink" title="2. JavaScriptCore（iOS 7.0 +）"></a>2. JavaScriptCore（iOS 7.0 +）</h4><p>除了<strong>拦截URL</strong>的方法，还可以利用上面提到的<code>JavaScriptCore</code>。它十分强大，强大在哪里呢？下面我们来一探究竟。</p>
<p>当然，还是需要在页面加载完成时，先获取js上下文。获取到之后，我们就可以进行强大的方法映射了。</p>
<p>比如js中我定义了一个分享的方法</p>
<pre><code class="javascript">function share(title, imgUrl, link) {
     //这里需要OC实现
}
</code></pre>
<p>在OC中实现如下</p>
<pre><code class="objective-c">- (void)webViewDidFinishLoad:(UIWebView *)webView
{
    //将js的function映射到OC的方法
    [self convertJSFunctionsToOCMethods];
}

- (void)convertJSFunctionsToOCMethods
{
    //获取该UIWebview的javascript上下文
    //self持有jsContext
    //@property (nonatomic, strong) JSContext *jsContext;
    self.jsContext = [self.webView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;];

    //js调用oc
    //其中share就是js的方法名称，赋给是一个block 里面是oc代码
    //此方法最终将打印出所有接收到的参数，js参数是不固定的
    self.jsContext[@&quot;share&quot;] = ^() {
        NSArray *args = [JSContext currentArguments];//获取到share里的所有参数
        //args中的元素是JSValue，需要转成OC的对象
        NSMutableArray *messages = [NSMutableArray array];
        for (JSValue *obj in args) {
            [messages addObject:[obj toObject]];
        }
        NSLog(@&quot;点击分享js传回的参数：\n%@&quot;, messages);
    };
}
</code></pre>
<p>在html或者js的某处，点击a标签调用这个share方法，并传参，如</p>
<pre><code class="html">&lt;a href=&quot;javascript:void(0);&quot; class=&quot;sharebtn&quot; onClick=&quot;share(&#39;分享标题&#39;, &#39;http://cc.cocimg.com/api/uploads/170425/b2d6e7ea5b3172e6c39120b7bfd662fb.jpg&#39;, location.href)&quot;&gt;分享活动，领30元红包&lt;/a&gt;
</code></pre>
<p>此时，如果用户点击了<strong><u>分享活动，领30元红包</u></strong>这个标签，那么在控制台会打印出所有参数<img src="http://ww2.sinaimg.cn/large/006tNc79ly1fff18hle74j31ak0hiah2.jpg" alt=""></p>
<p>上面的代码实现了OC方法替换JS实现。它十分灵活，主要依赖这些Api。</p>
<pre><code class="objective-c">@interface JSContext (SubscriptSupport)
/*!
@method
@abstract Get a particular property on the global object.
@result The JSValue for the global object&#39;s property.
*/
- (JSValue *)objectForKeyedSubscript:(id)key;
/*!
@method
@abstract Set a particular property on the global object.
*/
- (void)setObject:(id)object forKeyedSubscript:(NSObject &lt;NSCopying&gt; *)key;
</code></pre>
<p><code>self.jsContext[@&quot;yourMethodName&quot;] = your block;</code>这样写不仅可以在有<code>yourMethodName</code>方法时替换该JS方法为OC实现，还会在g该方法没有时，添加方法。简而言之，<strong>有则替换，无则添加</strong>。</p>
<p>那如果我想写一个有两个参数，一个返回值的js方法，oc应该怎么替换呢？</p>
<p>js中</p>
<pre><code class="javascript">//该方法传入两个整数，求和，并返回结果
function testAddMethod(a, b) {
     //需要OC实现a+b，并返回
      return a + b;
}
//js调用
console.log(testAddMethod(1, 5));    //output  6
</code></pre>
<p>oc直接替换该方法</p>
<pre><code class="objective-c">self.jsContext[@&quot;testAddMethod&quot;] = ^NSInteger(NSInteger a, NSInteger b) {
      return a + b;
};
</code></pre>
<p>那么当在js调用</p>
<pre><code class="javascript">//js调用
console.log(testAddMethod(1, 5));    //output  6， 方法为 a + b
</code></pre>
<p>如果oc替换该方法为两数相乘</p>
<pre><code class="objective-c">self.jsContext[@&quot;testAddMethod&quot;] = ^NSInteger(NSInteger a, NSInteger b) {
      return a * b;
};
</code></pre>
<p>再次调用js</p>
<pre><code class="javascript">console.log(testAddMethod(1, 5));    //output  5，该方法变为了 a * b。
</code></pre>
<p>举一反三，调用方法原实现，并且在原结果上乘以10。</p>
<pre><code class="objective-c">//调用方法的本来实现，给原结果乘以10
JSValue *value = self.jsContext[@&quot;testAddMethod&quot;];
self.jsContext[@&quot;testAddMethod&quot;] = ^NSInteger(NSInteger a, NSInteger b) {
    JSValue *resultValue = [value callWithArguments:[JSContext currentArguments]];
    return resultValue.toInt32 * 10;
};
</code></pre>
<p>再次调用js</p>
<pre><code class="javascript">console.log(testAddMethod(1, 5));    //output  60，该方法变为了(a + b) * 10
</code></pre>
<p>上面的方法，都是同步函数，如果我想实现JS调用OC的方法，并且异步接收回调，那么该怎么做呢？比如h5中有一个分享按钮，用户点击之后，调用native分享（微信分享、微博分享等），在native分享成功或者失败时，回调h5页面，告诉其分享结果，h5页面刷新对应的UI，显示分享成功或者失败。</p>
<p>这个问题，需要对js有一定了解。下面上js代码。</p>
<pre><code class="javascript">//声明
function share(shareData) {
    var title = shareData.title;
    var imgUrl = shareData.imgUrl;
    var link = shareData.link;
    var result = shareData.result;
      //do something
    //这里模拟异步操作
    setTimeout(function(){
          //2s之后，回调true分享成功
       result(true);
    }, 2000);
}

//调用的时候需要这么写
share({
      title: &quot;title&quot;, 
     imgUrl: &quot;http://img.dd.com/xxx.png&quot;, 
     link: location.href, 
     result: function(res) {    //函数作为参数
         console.log(res ? &quot;success&quot; : &quot;failure&quot;);
    }
});
</code></pre>
<p>从封装的角度上讲，js的<code>share</code>方法的参数是一个<code>对象</code>，该对象包含了几个必要的字段，以及一个回调函数，这个回调函数有点像oc的<code>block</code>，<strong>调用者</strong>把一个<code>function</code>传入一个<code>function</code>当作参数，在适当时候，方法内<strong>实现者</strong>调用该<code>function</code>，实现对<strong>调用者</strong>的异步回调。那么如果此时OC来实现<code>share</code>方法，该怎么做呢？其实大概是这样的：</p>
<pre><code class="objective-c">//异步回调
self.jsContext[@&quot;share&quot;] = ^(JSValue *shareData) {    //首先这里要注意，回调的参数不能直接写NSDictionary类型，为何呢？
    //仔细看，打印出的确实是一个NSDictionary，但是result字段对应的不是block而是一个NSDictionary  
      NSLog(@&quot;%@&quot;, [shareData toObject]);     
    //获取shareData对象的result属性，这个JSValue对应的其实是一个javascript的function。
    JSValue *resultFunction = [shareData valueForProperty:@&quot;result&quot;];
    //回调block，将js的function转换为OC的block
    void (^result)(BOOL) = ^(BOOL isSuccess) {
        [resultFunction callWithArguments:@[@(isSuccess)]];
    };
    //模拟异步回调
    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
        NSLog(@&quot;回调分享成功&quot;);
        result(YES);
    });
};
</code></pre>
<p>其中一些坑，已经在代码的注释写的比较清楚了，这里要注意<code>JavaScript</code>的<code>function</code>和<code>Objective-C</code>的<code>block</code>的转换。</p>
<p>从上面的一些探讨和尝试来看，足以证明<code>JavaScriptCore</code>的强大，这里不再展开，小伙伴们可以自行探索。</p>
<h2 id="UIWebView的Cookie管理"><a href="#UIWebView的Cookie管理" class="headerlink" title="UIWebView的Cookie管理"></a>UIWebView的Cookie管理</h2><h3 id="Cookie简介"><a href="#Cookie简介" class="headerlink" title="Cookie简介"></a>Cookie简介</h3><p>说到<code>Cookie</code>，或许有些小伙伴会比较陌生，有些小伙伴会比较熟悉。如果项目中，所有页面都是纯原生来实现的话，一般<code>Cookie</code>这个东西或许我们永远也不会接触到。但是，这里还是要说一下<code>Cookie</code>，因为它真的很重要，由它产生的一些坑也很多。</p>
<p><code>Cookie</code>在Web利用的最多的地方，是用来记录各种状态。比如你在<code>Safari</code>中打开百度，然后登陆自己的账号，之后打开所有百度相关的页面，都会是登陆状态，而且当你关了电脑，下次开机再次打开<code>Safari</code>打开百度，会发现还是登陆状态，其实这个就利用了<code>Cookie</code>。<code>Cookie</code>中记录了你百度账号的一些信息、有效期等，也维持了跨域请求时登录状态的统计性。<img src="http://ww3.sinaimg.cn/large/006tNc79ly1fff5jbzd4cj31kw0jk11w.jpg" alt="">可以看到<code>Cookie</code>的域各不相同，有效期也各不相同，一般<code>.baidu.com</code>这样的域的<code>Cookie</code>就是为了跨域时，可以维持一些状态。</p>
<p>那么在App中，Cookie最常用的就是维持登录状态了。一般Native端都有自己的一套完整登录注册逻辑，一般大部分页面都是原生实现的。当然，也会有一些页面是h5来实现的，虽然h5页面在App中通过<code>WebView</code>加载或多或少都会有点性能问题，感觉不流畅或者体验不好，但是它的灵活性是Native App无法比拟的。那么由此，便产生了一种需求，当Native端用户是登录状态的，打开一个h5页面，h5也要维持用户的登录状态。</p>
<p>这个需求看似简单，如何实现呢？一般的解决方案是Native保存登录状态的Cookie，在打开h5页面中，把Cookie添加上，以此来维持登录状态。其实坑还是有很多的，比如用户登录或者退出了，h5页面的登录状态也变了，需要刷新，什么时候刷新？<code>WKWebView</code>中<code>Cookie</code>丢失问题？这里简单说下<code>UIWebView</code>的<code>Cookie</code>管理，后面的章节再介绍<code>WKWebView</code>。</p>
<h3 id="Cookie管理"><a href="#Cookie管理" class="headerlink" title="Cookie管理"></a>Cookie管理</h3><p><code>UIWebView</code>的<code>Cookie</code>管理很简单，一般不需要我们手动操作<code>Cookie</code>，因为所有<code>Cookie</code>都会被<code>[NSHTTPCookieStorage sharedHTTPCookieStorage]</code>这个单例管理，而且<code>UIWebView</code>会自动同步<code>CookieStorage</code>中的Cookie，所以只要我们在Native端，正常登陆退出，h5在适当时候刷新，就可以正确的维持登录状态，不需要做多余的操作。</p>
<p>可能有一些情况下，我们需要在访问某个链接时，添加一个固定<code>Cookie</code>用来做区分，那么就可以通过<code>header</code>来实现</p>
<pre><code class="objective-c">NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@&quot;http://www.baidu.com&quot;]];
[request addValue:@&quot;customCookieName=1314521;&quot; forHTTPHeaderField:@&quot;Set-Cookie&quot;];
[self.webView loadRequest:request];
</code></pre>
<p>也可以主动操作<code>NSHTTPCookieStorage</code>，添加一个自定义<code>Cookie</code></p>
<pre><code class="objective-c">NSHTTPCookie *cookie = [NSHTTPCookie cookieWithProperties:@{
    NSHTTPCookieName: @&quot;customCookieName&quot;, 
    NSHTTPCookieValue: @&quot;1314521&quot;, 
    NSHTTPCookieDomain: @&quot;.baidu.com&quot;,
    NSHTTPCookiePath: @&quot;/&quot;
}];
[[NSHTTPCookieStorage sharedHTTPCookieStorage] setCookie:cookie];    //Cookie存在则覆盖，不存在添加
</code></pre>
<p>还有一些常用的方法，如读取所有<code>Cookie</code></p>
<pre><code class="objective-c">NSArray *cookies = [NSHTTPCookieStorage sharedHTTPCookieStorage].cookies;
</code></pre>
<p><code>Cookie</code>转换成<code>HTTPHeaderFields</code>，并添加到<code>request</code>的<code>header</code>中</p>
<pre><code class="objective-c">//Cookies数组转换为requestHeaderFields
NSDictionary *requestHeaderFields = [NSHTTPCookie requestHeaderFieldsWithCookies:cookies];
//设置请求头
request.allHTTPHeaderFields = requestHeaderFields;
</code></pre>
<p>整体来说<code>UIWebView</code>的<code>Cookie</code>管理比较简单，小伙伴们可以自己写个demo测试一下，发挥你们的想象。</p>
<h1 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h1><p>关于<code>UIWebView</code>的介绍，以及使用<code>UIWebView</code>进行JS与OC的交互，<code>Cookie</code>的管理，就先简单介绍到这里。如果有小伙伴对于<a href="https://github.com/marcuswestin/WebViewJavascriptBridge" target="_blank" rel="external">WebViewJavascriptBridge</a>比较感兴趣，可以留言，根据留言我考虑一下写一篇文章，分析它的详细实现。</p>
<p>另外，后续将为您介绍<code>WKWebView</code>的用法，一些OC与JS交互，Cookie管理、如何在<code>Safari</code>中调试以及一些不为人知的坑等，敬请期待~</p>
<p>To be continued…</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/006tNc79ly1fff1sa06wrj30sg0iwwi9.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; titl
    
    </summary>
    
    
      <category term="iOS技术分享" scheme="http://blog.darkangel7.com/tags/iOS%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+Github的Blog搭建</title>
    <link href="http://blog.darkangel7.com/2016/08/19/Hexo+Github%E7%9A%84Blog%E6%90%AD%E5%BB%BA/"/>
    <id>http://blog.darkangel7.com/2016/08/19/Hexo+Github的Blog搭建/</id>
    <published>2016-08-19T04:40:16.000Z</published>
    <updated>2017-05-08T02:38:09.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装："><a href="#安装：" class="headerlink" title="安装："></a>安装：</h1><h2 id="一、安装Homebrew"><a href="#一、安装Homebrew" class="headerlink" title="一、安装Homebrew"></a>一、安装Homebrew</h2><p>Mac上已经安装了ruby环境，只需要输入</p>
<pre><code>ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;
</code></pre><h2 id="二、安装node-js"><a href="#二、安装node-js" class="headerlink" title="二、安装node.js"></a>二、安装node.js</h2><pre><code>sudo brew install node
</code></pre><h2 id="三、安装Hexo"><a href="#三、安装Hexo" class="headerlink" title="三、安装Hexo"></a>三、安装Hexo</h2><p>Hexo是基于node.js的博客系统，这里安装就可以了。</p>
<pre><code>sudo npm install -g hexo 
npm install hexo-renderer-ejs --save
npm install hexo-renderer-stylus --save
npm install hexo-renderer-marked --save
</code></pre><p>安装完成后，找一个放blog的目录</p>
<pre><code>cd ~/Blog
</code></pre><p>然后执行初始化</p>
<pre><code>hexo init
</code></pre><p>然后可以直接预览hello word.md</p>
<pre><code>hexo g
hexo s
=&gt; [info] Hexo is running at localhost:4000/. Press Ctrl+C to stop.
</code></pre><p>g是generate, s是server，还有d是deploy（部署）推荐用首字母，方便快捷。</p>
<h2 id="四、创建Blog-Repository"><a href="#四、创建Blog-Repository" class="headerlink" title="四、创建Blog Repository"></a>四、创建Blog Repository</h2><p>在自己的Github创建Blog的仓库，如Blog-Hexo，命名无所谓。记住勾选README。</p>
<p><img src="http://ww4.sinaimg.cn/large/65e4f1e6jw1f72qarsjd9j20va0aydh0.jpg" alt="repository1"></p>
<p><img src="http://ww2.sinaimg.cn/large/65e4f1e6jw1f72qbhppqfj214a0sqq6q.jpg" alt="repository2"><br>创建完毕，直接进行到下一步。</p>
<h2 id="五、购买域名"><a href="#五、购买域名" class="headerlink" title="五、购买域名"></a>五、购买域名</h2><p>推荐在万网购买，国外的Godaddy也可以。以万网为例：<br>买好域名实名认证了之后，到<code>控制台</code> - <code>云解析DNS</code>中添加一个解析，如：</p>
<p><img src="http://ww4.sinaimg.cn/large/65e4f1e6jw1f72qblgcswj21kw01qglt.jpg" alt=""></p>
<p>CNAME映射到自己的xxx.github.io。这里的xxx是你的在github的名称，我的是<code>DarkAngel7</code>。<br>在终端中输入</p>
<pre><code>dig blog.darkangel7.com +nostats +nocomments +nocmd
</code></pre><p>如果出现下面的结果，证明解析成功。</p>
<pre><code>DarkAngel-MacBook-Pro-2:Blog DarkAngel$ dig blog.darkangel7.com +nostats +nocomments +nocmd

; &lt;&lt;&gt;&gt; DiG 9.8.3-P1 &lt;&lt;&gt;&gt; blog.darkangel7.com +nostats +nocomments +nocmd
;; global options: +cmd
;blog.darkangel7.com.        IN    A
blog.darkangel7.com.    30    IN    CNAME    darkangel7.github.io.
darkangel7.github.io.    2516    IN    CNAME    github.map.fastly.net.
github.map.fastly.net.    30    IN    CNAME    prod.github.map.fastlylb.net.
prod.github.map.fastlylb.net. 30 IN    A    151.101.100.133
</code></pre><h2 id="六、Deploy"><a href="#六、Deploy" class="headerlink" title="六、Deploy"></a>六、Deploy</h2><p>上一步完成域名到github pages的单向映射。本步完成github到域名的映射，完成输入域名解析到对应的内容。</p>
<p>首先在Blog/source里创建CNAME</p>
<pre><code>cd source
touch CNAME
vi CNAME
</code></pre><p>输入你在上一步CNAME的域名，建立映射关系。</p>
<pre><code>blog.darkangel7.com
</code></pre><p>修改<code>_config.yml</code>文件，配置一些东西。</p>
<pre><code># Deployment
## Docs: https://hexo.io/docs/deployment.html
deploy:
      type: git
      repository: git@github.com:DarkAngel7/Blog-Hexo.git
</code></pre><p>安装git插件</p>
<pre><code>npm install hexo-deployer-git --save
</code></pre><p>这里repository的地址可以是https的，也可以是git的，只不过git需要SSH证书，一般用https就可以了，如果出现443错误，替换成git。</p>
<p>然后在Blog目录下</p>
<pre><code>hexo g -d
</code></pre><p>生成静态文件并且部署出去，不出意外，已经可以外网访问了。</p>
<h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><h2 id="一、访问速度"><a href="#一、访问速度" class="headerlink" title="一、访问速度"></a>一、访问速度</h2><p>由于Google被墙，大部分主题中引用的jquery都会因为超时（可以Blog目录下搜索google），而造成页面访问很慢，这里需要将jquery改为百度的<br>​    </p>
<pre><code>&lt;script src=&quot;//apps.bdimg.com/libs/jquery/2.0.3/jquery.min.js&quot;&gt;&lt;/script&gt;
</code></pre><h2 id="二、RSS订阅"><a href="#二、RSS订阅" class="headerlink" title="二、RSS订阅"></a>二、RSS订阅</h2><p>输入命令</p>
<pre><code>$ npm install hexo-generator-feed --save
</code></pre><p>然后在_config.yml中，添加<br>​    </p>
<pre><code>rss: /atom.xml
feed:
     type: atom
    path: atom.xml
     limit: 20
</code></pre><h2 id="三、搜索支持"><a href="#三、搜索支持" class="headerlink" title="三、搜索支持"></a>三、搜索支持</h2><p>现在在百度和Google是搜不到你的网站的，为了让搜索引擎搜索到，需要做一些工作。</p>
<p>搜索引擎入口</p>
<ul>
<li><a href="https://www.google.com/webmasters/tools/home?hl=zh-CN" target="_blank" rel="external">Google搜索引擎提交入口</a></li>
<li><a href="http://www.baidu.com/search/url_submit.htm" target="_blank" rel="external">百度搜索引擎入口</a></li>
</ul>
<p>添加sitemap.xml：</p>
<p>首先输入：</p>
<pre><code>npm install hexo-generator-sitemap --save
npm install hexo-generator-baidu-sitemap --save    
npm install hexo-baidu-url-submit --save
</code></pre><p>前两个插件用于生成sitemap，后一个插件用于主动推送链接到百度（<strong>防止百度爬虫抓取失败，导致百度搜不到您的博客</strong>，这里有一篇<a href="http://guochenglai.com/2016/09/26/baidu-crow-github-page/" target="_blank" rel="external">关于百度无法爬取Github Pages静态网站解决方案</a>）。</p>
<p>然后在<code>_config.yml</code>文件中添加</p>
<pre><code>sitemap:
         path: sitemap.xml
baidusitemap:
         path: baidusitemap.xml

## BaiduUrlSubmit: http://hui-wang.info/2016/10/23/Hexo插件之百度主动提交链接/    
baidu_url_submit:        ##主动推送新文章到百度
  count: 3 ## 比如3，代表提交最新的三个链接
  host: blog.darkangel7.com ## 在百度站长平台中注册的域名
  token: your_token ## 请注意这是您的秘钥， 请不要发布在公众仓库里!
  path: baidu_urls.txt ## 文本文档的地址， 新链接会保存在此文本文档里

##同时要检查这里有没有URL值，必须包含是百度站长平台注册的域名，比如 
# URL
url: http://blog.darkangel7.com
root: /
permalink: :year/:month/:day/:title/

##最后，加入新的deployer，如
deploy:
- type: git
  repository: git@github.com:DarkAngel7/Blog-Hexo.git
- type: baidu_url_submitter  ## 百度链接主动推送
</code></pre><p>先验证网站所有权，下载html，mv到Blog/themes/yourtheme/source目录下，执行</p>
<pre><code>hexo g -d
</code></pre><p>验证成功后，添加百度自动推送脚本，最好在<code>head.ejs</code>中添加百度自动推送的代码，至于<code>head.ejs</code>文件位置，在你使用的theme文件夹下搜索吧。<br>谷歌的话，在<code>抓取</code>-<code>站点地图</code>里面添加就好。</p>
<p>这样主动推送与自动推送结合，能很好的提高您文章的曝光率。    </p>
<h2 id="四、评论功能"><a href="#四、评论功能" class="headerlink" title="四、评论功能"></a>四、评论功能</h2><p>可以使用<a href="http://duoshuo.com" target="_blank" rel="external">多说</a>来提供评论功能。首先，在<code>_config.yml</code>文件中添加</p>
<pre><code># Duoshuo
duoshuo_shortname: yoursite.doushuo.com
</code></pre><p>  然后，搜索themes文件夹下，你使用的theme文件目录下的<code>commemt.ejs</code>（不同的theme可能位置不同，请自行寻找）。修改如下：</p>
<pre><code> &lt;div id=&quot;comment&quot; class=&quot;comments-area&quot;&gt;
     &lt;% if(config.duoshuo_shortname) { %&gt;
     &lt;! -- 多说的代码 --&gt; 
     &lt;% } %&gt; 
&lt;/div&gt;    

 如果报关于data-thread-key的错误，则改成下面这样：
 &lt;div class=&quot;ds-thread&quot; data-thread-key=&quot;&lt;%= page.path %&gt;&quot; data-title=&quot;&lt;%= page.title %&gt;&quot; data-url=&quot;&lt;%= page.permalink %&gt;&quot;&gt;&lt;/div    &gt;
</code></pre><h2 id="五、分享功能"><a href="#五、分享功能" class="headerlink" title="五、分享功能"></a>五、分享功能</h2><p>可以在Blog目录下搜索<code>post/share</code>，一般在<code>article.ejs</code>文件中，或者<code>post.ejs</code>文件中，然后替换</p>
<pre><code>&lt;%- partial(&#39;post/author&#39;) %&gt;
</code></pre><p>为<a href="http://share.baidu.com/code" target="_blank" rel="external">百度分享</a>提供的代码。</p>
<h2 id="六、个人信息完善"><a href="#六、个人信息完善" class="headerlink" title="六、个人信息完善"></a>六、个人信息完善</h2><p>网站的信息一般都在<code>Blog/_config.yml</code>中修改。</p>
<p>关于Theme，去官方提供的<a href="https://github.com/tommy351/hexo/wiki/Themes" target="_blank" rel="external">主题列表</a>中选个现成的，按照里面的方法pull下来，如light主题</p>
<pre><code>$ git clone git://github.com/tommy351/hexo-theme-light.git themes/light
</code></pre><p>然后在<code>_config.yml</code>配置文件中设置：</p>
<pre><code>theme: light
</code></pre><p>关于主题的优化，一般在<code>themes/yourtheme/_config.yml</code>中配置。</p>
<h1 id="写文章"><a href="#写文章" class="headerlink" title="写文章"></a>写文章</h1><p>在Blog目录下，创建</p>
<pre><code>hexo new 文章题目
</code></pre><p>然后用Markdown编写，写好后save。</p>
<pre><code>hexo g
hexo s
</code></pre><p>生成，然后在本地localhost:4000预览一下，如果没有问题，就可以发布了。</p>
<pre><code>hexo d
</code></pre><p>所有的文章都是放在<code>Blog/source/_posts/</code>目录下的，可以随时编辑修改。</p>
<h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>还有一些其他的修改，这里就不一一提了，等待你慢慢发现。现在快开始写作吧~~</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;安装：&quot;&gt;&lt;a href=&quot;#安装：&quot; class=&quot;headerlink&quot; title=&quot;安装：&quot;&gt;&lt;/a&gt;安装：&lt;/h1&gt;&lt;h2 id=&quot;一、安装Homebrew&quot;&gt;&lt;a href=&quot;#一、安装Homebrew&quot; class=&quot;headerlink&quot; titl
    
    </summary>
    
    
  </entry>
  
</feed>
