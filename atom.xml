<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Dark Angel</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.darkangel7.com/"/>
  <updated>2017-05-10T12:14:16.000Z</updated>
  <id>http://blog.darkangel7.com/</id>
  
  <author>
    <name>Dark Angel</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>iOS中UIWebView与WKWebView、JavaScript与OC交互、Cookie管理看我就够（中）</title>
    <link href="http://blog.darkangel7.com/2017/05/10/iOS%E4%B8%ADUIWebView%E4%B8%8EWKWebView%E3%80%81JavaScript%E4%B8%8EOC%E4%BA%A4%E4%BA%92%E3%80%81Cookie%E7%AE%A1%E7%90%86%E7%9C%8B%E6%88%91%E5%B0%B1%E5%A4%9F%EF%BC%88%E4%B8%AD%EF%BC%89/"/>
    <id>http://blog.darkangel7.com/2017/05/10/iOS中UIWebView与WKWebView、JavaScript与OC交互、Cookie管理看我就够（中）/</id>
    <published>2017-05-10T02:10:09.000Z</published>
    <updated>2017-05-10T12:14:16.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1fff1sa06wrj30sg0iwwi9.jpg" alt=""></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>关于<code>UIWebView</code>的介绍，相信看过<a href="http://blog.darkangel7.com/2016/09/01/iOS中UIWebView与WKWebView、JavaScript与OC交互、Cookie管理看我就够（上）/">上文</a>的小伙伴们，已经大概清楚了吧，如果有问题，欢迎提问。</p>
<p>本文是本系列文章的第二篇，主要为小伙伴们分享下<code>WKWebView</code>相关的内容：</p>
<ul>
<li><a href="http://blog.darkangel7.com/2016/09/01/iOS中UIWebView与WKWebView、JavaScript与OC交互、Cookie管理看我就够（上）/">iOS中UIWebView与WKWebView、JavaScript与OC交互、Cookie管理看我就够（上）</a></li>
<li>iOS中UIWebView与WKWebView、JavaScript与OC交互、Cookie管理看我就够（中）</li>
<li><a href="">iOS中UIWebView与WKWebView、JavaScript与OC交互、Cookie管理看我就够（下）</a>（待填坑…）</li>
</ul>
<p>关于文中提到的一些内容，这里我准备了个<a href="https://github.com/DarkAngel7/Demos-WebViewDemo" target="_blank" rel="external">Demo</a>，有需要的小伙伴可以下载。</p>
<h1 id="WKWebView"><a href="#WKWebView" class="headerlink" title="WKWebView"></a>WKWebView</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>WKWebView</code>是Apple于iOS 8.0推出的<code>WebKit</code>中的核心控件，用来替代<code>UIWebView</code>。<code>WKWebView</code>比<code>UIWebView</code>的优势在于：</p>
<ul>
<li><p>更多的支持HTML5的特性</p>
</li>
<li><p>高达60fps的滚动刷新率以及内置手势</p>
</li>
<li>与Safari相同的JavaScript引擎</li>
<li>将UIWebViewDelegate与UIWebView拆分成了14类与3个协议（<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/WebKit/ObjC_classic/index.html" target="_blank" rel="external">官方文档说明</a>）</li>
<li>可以获取加载进度：<code>estimatedProgress</code>（UIWebView需要调用私有Api）</li>
</ul>
<p>作者本人在项目中使用<code>WKWebView</code>也1年多了，确确实实感受到了它的优势，但是同样也感受到了它带来的一些坑。下面来具体的介绍下<code>WKWebView</code>。其实Apple开源了<a href="https://opensource.apple.com/source/WebKit2/" target="_blank" rel="external">WebKit</a>，有兴趣的小伙伴可以研究下它的实现。</p>
<h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><p><code>WKWebView</code>的创建方法有这两种</p>
<pre><code class="objective-c">/*-initWithFrame: to initialize an instance with the default configuration. 如果使用initWithFrame方法将使用默认的configuration
The initializer copies the specified configuration, so mutating the configuration after invoking the initializer has no effect on the web view. 我们需要先设置configuration，再调用init，在init之后修改configuration则无效
*/
- (instancetype)initWithFrame:(CGRect)frame configuration:(WKWebViewConfiguration *)configuration NS_DESIGNATED_INITIALIZER;
- (nullable instancetype)initWithCoder:(NSCoder *)coder NS_DESIGNATED_INITIALIZER;
</code></pre>
<p>仔细看第一个方法，比<code>UIWebView</code>多了个<code>configuration</code>，这个配置可以设置很多东西。具体查看<code>WKWebViewConfiguration.h</code>，可以配置js是否支持，画中画是否开启等，这里主要讲两个比较常用的属性。</p>
<p>第一个属性是<code>websiteDataStore</code>。</p>
<pre><code class="objective-c">/*! @abstract The website data store to be used by the web view.
 */
@property (nonatomic, strong) WKWebsiteDataStore *websiteDataStore API_AVAILABLE(macosx(10.11), ios(9.0));
</code></pre>
<p>业界普遍认为 <code>WKWebView</code> 拥有自己的私有存储，它的一些缓存等数据都存在<code>websiteDataStore</code>中，具体增删改查就可以通过<code>WKWebsiteDataStore.h</code>中提供的方法，这里不多说，一般用的时候比较少，真的要清除缓存，简单粗暴的方法是删除沙盒目录中的Cache文件夹。</p>
<p>第二个属性是<code>userContentController</code>。</p>
<pre><code class="objective-c">/*! @abstract The user content controller to associate with the web view.
*/
@property (nonatomic, strong) WKUserContentController *userContentController;
</code></pre>
<p>这个属性很重要，后面讲的js-&gt;oc的交互，以及注入js代码都会用到它。查看<code>WKUserContentController</code>的头文件，你会发现它有如下几个方法：</p>
<pre><code class="objective-c">@interface WKUserContentController : NSObject &lt;NSCoding&gt;
//读取添加过的脚本
@property (nonatomic, readonly, copy) NSArray&lt;WKUserScript *&gt; *userScripts;
//添加脚本
- (void)addUserScript:(WKUserScript *)userScript;
//删除所有添加的脚本
- (void)removeAllUserScripts;
//通过window.webkit.messageHandlers.&lt;name&gt;.postMessage(&lt;messageBody&gt;) 来实现js-&gt;oc传递消息，并添加handler
- (void)addScriptMessageHandler:(id &lt;WKScriptMessageHandler&gt;)scriptMessageHandler name:(NSString *)name;
//删除handler
- (void)removeScriptMessageHandlerForName:(NSString *)name;
@end
</code></pre>
<p>那么整体我创建一个<code>WKWebView</code>的代码如下：</p>
<pre><code class="objective-c">WKWebViewConfiguration *configuration = [[WKWebViewConfiguration alloc] init];
WKUserContentController *controller = [[WKUserContentController alloc] init];
configuration.userContentController = controller;
self.webView = [[WKWebView alloc] initWithFrame:self.view.bounds configuration:configuration];
self.webView.allowsBackForwardNavigationGestures = YES;    //允许右滑返回上个链接，左滑前进
self.webView.allowsLinkPreview = YES; //允许链接3D Touch
self.webView.customUserAgent = @&quot;WebViewDemo/1.0.0&quot;; //自定义UA，UIWebView就没有此功能，后面会讲到通过其他方式实现
self.webView.UIDelegate = self;
self.webView.navigationDelegate = self;
[self.view addSubview:self.webView];
</code></pre>
<h4 id="动态注入js"><a href="#动态注入js" class="headerlink" title="动态注入js"></a>动态注入js</h4><p>通过给<code>userContentController</code>添加<code>WKUserScript</code>，可以实现动态注入js。比如我先注入一个脚本，给每个页面添加一个Cookie</p>
<pre><code class="objective-c">//注入一个Cookie
WKUserScript *newCookieScript = [[WKUserScript alloc] initWithSource:@&quot;document.cookie = &#39;DarkAngelCookie=DarkAngel;&#39;&quot; injectionTime:WKUserScriptInjectionTimeAtDocumentStart forMainFrameOnly:NO];
[controller addUserScript:newCookieScript];
</code></pre>
<p>然后再注入一个脚本，每当页面加载，就会alert当前页面cookie，在OC中的实现</p>
<pre><code class="objective-c">//创建脚本
WKUserScript *cookieScript = [[WKUserScript alloc] initWithSource:@&quot;alert(document.cookie);&quot; injectionTime:WKUserScriptInjectionTimeAtDocumentEnd forMainFrameOnly:NO];
//添加脚本
[controller addUserScript:script];
</code></pre>
<p>这样每当页面出现的时候，会alet弹出当前页面所有的cookie字符串。<img src="http://ww1.sinaimg.cn/large/006tNc79ly1ffgc3n3b8fj30ku12aq38.jpg" width="200px;"></p>
<p>注入的js source可以是任何js字符串，也可以js文件。比如你有很多提供给h5使用的js方法，那么你本地可能就会有一个<code>native_functions.js</code>，你可以通过以下的方式添加</p>
<pre><code class="objective-c">//防止频繁IO操作，造成性能影响
static NSString *jsSource;
static dispatch_once_t onceToken;
  dispatch_once(&amp;onceToken, ^{
      jsSource = [NSString stringWithContentsOfFile:[[NSBundle mainBundle] pathForResource:@&quot;native_functions&quot; ofType:@&quot;js&quot;] encoding:NSUTF8StringEncoding error:nil];
});
//添加自定义的脚本
WKUserScript *js = [[WKUserScript alloc] initWithSource:jsSource injectionTime:WKUserScriptInjectionTimeAtDocumentEnd forMainFrameOnly:NO];
[self.configuration.userContentController addUserScript:js];
</code></pre>
<h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p>加载一个请求或者页面也很简单</p>
<pre><code class="objective-c">- (nullable WKNavigation *)loadRequest:(NSURLRequest *)request;
- (nullable WKNavigation *)loadFileURL:(NSURL *)URL allowingReadAccessToURL:(NSURL *)readAccessURL API_AVAILABLE(macosx(10.11), ios(9.0));
- (nullable WKNavigation *)loadHTMLString:(NSString *)string baseURL:(nullable NSURL *)baseURL;
- (nullable WKNavigation *)loadData:(NSData *)data MIMEType:(NSString *)MIMEType characterEncodingName:(NSString *)characterEncodingName baseURL:(NSURL *)baseURL API_AVAILABLE(macosx(10.11), ios(9.0));
</code></pre>
<p>基本与<code>UIWebView</code>的很相似，但是需要说明的是，加载本地的一个html需要使用<code>loadRequest:</code>方法，使用<code>loadHTMLString:baseURL:</code>方法会有问题。</p>
<pre><code class="objective-c">[self.webView loadRequest:[NSURLRequest requestWithURL:[NSURL fileURLWithPath:[[NSBundle mainBundle] pathForResource:@&quot;test&quot; ofType:@&quot;html&quot;]]]];
</code></pre>
<h4 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h4><p>在<code>WKWebView</code>的头文件，你会发现</p>
<pre><code class="objective-c">@protocol WKNavigationDelegate;    //类似于UIWebView的加载成功、失败、是否允许跳转等
@protocol WKUIDelegate;    //主要是一些alert、打开新窗口之类的
</code></pre>
<p>有两个协议，它将<code>UIWebView</code>的代理协议拆成了一个跳转的协议和一个关于UI的协议。虽说这两个协议中的所有方法都是Optional，但是关于<code>WKUIDelegate</code>协议是有坑的，后面的<strong>各种坑</strong>中会提到。简单说下<code>WKNavigationDelegate</code>中比较常用的方法</p>
<pre><code class="objective-c">//下面这2个方法共同对应了UIWebView的 - (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType;
//先：针对一次action来决定是否允许跳转，action中可以获取request，允许与否都需要调用decisionHandler，比如decisionHandler(WKNavigationActionPolicyCancel);
- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler；
//后：根据response来决定，是否允许跳转，允许与否都需要调用decisionHandler，如decisionHandler(WKNavigationResponsePolicyAllow);
- (void)webView:(WKWebView *)webView decidePolicyForNavigationResponse:(WKNavigationResponse *)navigationResponse decisionHandler:(void (^)(WKNavigationResponsePolicy))decisionHandler;

//开始加载，对应UIWebView的- (void)webViewDidStartLoad:(UIWebView *)webView;
- (void)webView:(WKWebView *)webView didStartProvisionalNavigation:(null_unspecified WKNavigation *)navigation;

//加载成功，对应UIWebView的- (void)webViewDidFinishLoad:(UIWebView *)webView;
- (void)webView:(WKWebView *)webView didFinishNavigation:(null_unspecified WKNavigation *)navigation;

//加载失败，对应UIWebView的- (void)webView:(UIWebView *)webView didFailLoadWithError:(NSError *)error;
- (void)webView:(WKWebView *)webView didFailNavigation:(null_unspecified WKNavigation *)navigation withError:(NSError *)error;
</code></pre>
<p><code>WKUIDelegate</code>这里先不提了，小伙伴们可以参考我<a href="https://github.com/DarkAngel7/Demos-WebViewDemo" target="_blank" rel="external">Demo</a>中的实现。</p>
<h4 id="新属性"><a href="#新属性" class="headerlink" title="新属性"></a>新属性</h4><p><code>WKWebView.h</code>定义了如下几个常用的<code>readonly</code>属性：</p>
<pre><code class="objective-c">@property (nullable, nonatomic, readonly, copy) NSString *title;    //页面的title，终于可以直接获取了
@property (nullable, nonatomic, readonly, copy) NSURL *URL;        //当前webView的URL
@property (nonatomic, readonly, getter=isLoading) BOOL loading;    //是否正在加载
@property (nonatomic, readonly) double estimatedProgress;    //加载的进度
@property (nonatomic, readonly) BOOL canGoBack;    //是否可以后退，跟UIWebView相同
@property (nonatomic, readonly) BOOL canGoForward;    //是否可以前进，跟UIWebView相同
</code></pre>
<p>这些属性都很有用，而且支持KVO，所以我们可以通过KVO观察这些值的变化，以便于我们做出最友好的交互。</p>
<h2 id="JavaScript与Objective-C的交互"><a href="#JavaScript与Objective-C的交互" class="headerlink" title="JavaScript与Objective-C的交互"></a>JavaScript与Objective-C的交互</h2><p>介绍完<code>WKWebView</code>的基本用法，让我们来研究下基于它的js与oc的交互。</p>
<h3 id="OC-gt-JS"><a href="#OC-gt-JS" class="headerlink" title="OC -&gt; JS"></a>OC -&gt; JS</h3><p>这个比较简单，<code>WKWebView</code>提供了一个类似<code>JavaScriptCore</code>的方法</p>
<pre><code class="objective-c">//执行一段js，并将结果返回，如果出错，error则不为空
- (void)evaluateJavaScript:(NSString *)javaScriptString completionHandler:(void (^ _Nullable)(_Nullable id result, NSError * _Nullable error))completionHandler;
</code></pre>
<p>该方法很好的解决了之前文章中提到的<code>UIWebView</code>使用<code>stringByEvaluatingJavaScriptFromString:</code>方法的两个缺点（1. 返回值只能是NSString。2. 报错无法捕获）。比如我想获取页面中的<code>title</code>，除了直接<code>self.webView.title</code>外，还可以通过这个方法：</p>
<pre><code class="objective-c">[self.webView evaluateJavaScript:@&quot;document.title&quot; completionHandler:^(id _Nullable title, NSError * _Nullable error) {
        NSLog(@&quot;调用evaluateJavaScript异步获取title：%@&quot;, title);
}];
</code></pre>
<h3 id="JS-gt-OC"><a href="#JS-gt-OC" class="headerlink" title="JS -&gt; OC"></a>JS -&gt; OC</h3><h4 id="URL拦截"><a href="#URL拦截" class="headerlink" title="URL拦截"></a>URL拦截</h4><p>此方法与上篇文章中<code>UIWebView</code>介绍到的URL拦截方法一致，都是通过自定义Scheme，在链接激活时，拦截该URL，拿到参数，调用OC方法，缺点依然明显。<code>WKWebView</code>实现起来如下：</p>
<p>比如我的链接依然是</p>
<pre><code class="html">&lt;a href=&quot;darkangel://smsLogin?username=12323123&amp;code=892845&quot;&gt;短信验证登录&lt;/a&gt;
</code></pre>
<p>当用户点击这个a标签时，会被拦截</p>
<pre><code class="objective-c">- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler {
    //可以通过navigationAction.navigationType获取跳转类型，如新链接、后退等
    NSURL *URL = navigationAction.request.URL;
    //判断URL是否符合自定义的URL Scheme
    if ([URL.scheme isEqualToString:@&quot;darkangel&quot;]) {
        //根据不同的业务，来执行对应的操作，且获取参数
        if ([URL.host isEqualToString:@&quot;smsLogin&quot;]) {
            NSString *param = URL.query;
            NSLog(@&quot;短信验证码登录, 参数为%@&quot;, param);
            decisionHandler(WKNavigationActionPolicyCancel);
            return;
        }
    }
    decisionHandler(WKNavigationActionPolicyAllow);
    NSLog(@&quot;%@&quot;, NSStringFromSelector(_cmd));
}
</code></pre>
<p>整体实现是与<code>UIWebView</code>十分相似的，这里就不多说了。</p>
<p>这里再次提一下<a href="https://github.com/marcuswestin/WebViewJavascriptBridge" target="_blank" rel="external">WebViewJavascriptBridge</a>，它在最近的新版本中支持了<code>WKWebView</code>。使用的方案同样是<strong>拦截URL</strong>，具体原理在之前的文章中简单描述过，这里不再赘述。下面说下Apple的新方法。</p>
<h4 id="scriptMessageHandler"><a href="#scriptMessageHandler" class="headerlink" title="scriptMessageHandler"></a>scriptMessageHandler</h4><p>这是Apple在<code>WebKit</code>里新增加的方法，位于<code>WKUserContentController.h</code>。</p>
<pre><code class="objective-c">/*! @abstract Adds a script message handler.
 @param scriptMessageHandler The message handler to add.
 @param name The name of the message handler.
 @discussion Adding a scriptMessageHandler adds a function
 window.webkit.messageHandlers.&lt;name&gt;.postMessage(&lt;messageBody&gt;) for all
 frames.
 */
- (void)addScriptMessageHandler:(id &lt;WKScriptMessageHandler&gt;)scriptMessageHandler name:(NSString *)name;

/*! @abstract Removes a script message handler.
 @param name The name of the message handler to remove.
 */
- (void)removeScriptMessageHandlerForName:(NSString *)name;
</code></pre>
<p>其实Apple的注释已经很清楚了，在OC中添加一个scriptMessageHandler，则会在<code>all frames</code>中添加一个js的function： <code>window.webkit.messageHandlers.&lt;name&gt;.postMessage(&lt;messageBody&gt;)</code> 。那么当我在OC中通过如下的方法添加了一个handler，如</p>
<pre><code class="objective-c">[controller addScriptMessageHandler:self name:@&quot;currentCookies&quot;]; //这里self要遵循协 WKScriptMessageHandler
</code></pre>
<p>则当我在js中调用下面的方法时</p>
<pre><code class="javascript">window.webkit.messageHandlers.currentCookies.postMessage(document.cookie);
</code></pre>
<p>我在OC中将会收到<code>WKScriptMessageHandler</code>的回调</p>
<pre><code class="objective-c">- (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message {
    if ([message.name isEqualToString:@&quot;currentCookies&quot;]) {
        NSString *cookiesStr = message.body;    //message.body返回的是一个id类型的对象，所以可以支持很多种js的参数类型(js的function除外)
        NSLog(@&quot;当前的cookie为： %@&quot;, cookiesStr);
    }
}
</code></pre>
<p>当然，记得在适当的地方调用removeScriptMessageHandler</p>
<pre><code class="objective-c">- (void)dealloc {
    //记得移除
    [self.webView.configuration.userContentController removeScriptMessageHandlerForName:@&quot;currentCookies&quot;];
}
</code></pre>
<p>这样就完成了一次完整的JS -&gt; OC的交互。</p>
<p><strong>问题</strong>：</p>
<ol>
<li>该方法还是<strong>没有办法直接获取返回值</strong>。</li>
<li>通过<code>window.webkit.messageHandlers.&lt;name&gt;.postMessage(&lt;messageBody&gt;)</code>传递的messageBody中不能包含js的function，<strong>如果包含了function，那么 OC端将不会收到回调</strong>。</li>
</ol>
<p>对于问题1，我们可以采用异步回调的方式，将返回值返回给js。对于问题2，一般js的参数中包含function是为了异步回调，这里我们可以把js的function转换为字符串，再传递给OC。</p>
<h3 id="实际运用"><a href="#实际运用" class="headerlink" title="实际运用"></a>实际运用</h3><p>关于上述问题1和问题2的结合利用，实现JS -&gt; OC的调用，并且OC -&gt; JS 异步回调结果，这里还是拿分享来举个例子。</p>
<p>比如js端实现了如下的方法（这段js的封装前面的文章里也有提及，小伙伴有问题可以看下之前的）：</p>
<pre><code class="javascript">  /**
   * 分享方法，并且会异步回调分享结果
   * @param  {对象类型} shareData 一个分享数据的对象，包含title,imgUrl,link以及一个回调function
   * @return {void}     无同步返回值
   */
  function shareNew(shareData) {

    //这是该方法的默认实现，上篇文章中有所提及
      var title = shareData.title;
      var imgUrl = shareData.imgUrl;
      var link = shareData.link;
      var result = shareData.result;
      //do something
      //这里模拟异步操作
      setTimeout(function() {
          //2s之后，回调true分享成功
          result(true);
      }, 2000);

      //用于WKWebView，因为WKWebView并没有办法把js function传递过去，因此需要特殊处理一下
      //把js function转换为字符串，oc端调用时 (&lt;js function string&gt;)(true); 即可
      shareData.result = result.toString();
      window.webkit.messageHandlers.shareNew.postMessage(shareData);
  }

  function test() {
     //清空分享结果
    shareResult.innerHTML = &quot;&quot;;

      //调用时，应该
      shareNew({
          title: &quot;title&quot;,
          imgUrl: &quot;http://img.dd.com/xxx.png&quot;,
          link: location.href,
          result: function(res) {
              //这里shareResult 等同于 document.getElementById(&quot;shareResult&quot;)
              shareResult.innerHTML = res ? &quot;success&quot; : &quot;failure&quot;;
          }
      });
  }
</code></pre>
<p>在html页面中我定义了一个a标签来触发test()函数</p>
<pre><code class="html">&lt;a href=&quot;javascript:void(0);&quot; onClick=&quot;test()&quot;&gt;测试新分享&lt;/a&gt;
</code></pre>
<p>在OC端，实现如下</p>
<pre><code class="objective-c">//首先别忘了，在configuration中的userContentController中添加scriptMessageHandler
[controller addScriptMessageHandler:self name:@&quot;shareNew&quot;];    //记得适当时候remove哦


//点击a标签时，则会调用下面的方法
#pragma mark - WKScriptMessageHandler 

- (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message {
    if ([message.name isEqualToString:@&quot;shareNew&quot;]) {
        NSDictionary *shareData = message.body;
        NSLog(@&quot;shareNew分享的数据为： %@&quot;, shareData);
        //模拟异步回调
        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(4 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
            //读取js function的字符串
            NSString *jsFunctionString = shareData[@&quot;result&quot;];
            //拼接调用该方法的js字符串
            NSString *callbackJs = [NSString stringWithFormat:@&quot;(%@)(%d);&quot;, jsFunctionString, NO];    //后面的参数NO为模拟分享失败
            //执行回调
            [self.webView evaluateJavaScript:callbackJs completionHandler:^(id _Nullable result, NSError * _Nullable error) {
                if (!error) {
                    NSLog(@&quot;模拟回调，分享失败&quot;);
                }
            }];
        });
    }
}
</code></pre>
<p>那么当我点击a标签时，html页面上过2s，会显示<strong>success</strong>，然后再过2s，会显示<strong>failure</strong>。<img src="http://ww2.sinaimg.cn/large/006tNc79ly1ffgcsdc7m3g309w0i776l.gif" alt="new"></p>
<p>我们来简单分析一下，点击之后，触发了<code>test()</code>函数，<code>test()</code>中封装了对<code>share()</code>函数的调用，且传了一个对象作为参数，对象中<code>result</code>字段对应的是个匿名函数，紧接着<code>share()</code>函数调用，其中的实现是2s过后，<code>result(true);</code>模拟js异步实现异步回调结果，分享成功。同时<code>share()</code>函数中，因为通过<code>scriptMessageHandler</code>无法传递<code>function</code>，所以先把<code>shareData</code>对象中的result这个匿名<code>function</code>转成<code>String</code>，然后替换<code>shareData</code>对象的<code>result</code>属性为这个<code>String</code>，并回传给OC，OC这边对应JS对象的数据类型是<code>NSDictionary</code>，我们打印并得到了所有参数，同时，把<code>result</code>字段对应的js <code>function String</code>取出来。这里我们延迟4s回调，模拟Native分享的异步过程，在4s后，也就是js中显示<strong>success</strong>的2s过后，调用js的匿名<code>function</code>，并传递参数（分享结果）。调用一个js function的方法是 <code>functionName(argument);</code> ，这里由于这个js的function已经是一个String了，所以我们调用时，需要加上<code>()</code>，如 <code>(functionString)(argument);</code>因此，最终我们通过OC -&gt; JS 的<code>evaluateJavaScript:completionHandler:</code>方法，成功完成了异步回调，并传递给js一个分享失败的结果。</p>
<p>上面的描述看起来很复杂，其实就是先执行了JS的默认实现，后执行了OC的实现。上面的代码展示了如何解决<code>scriptMessageHandler</code>的两个问题，并且实现了一个 JS -&gt; OC、OC -&gt; JS 完整的交互流程。</p>
<h2 id="Cookie管理"><a href="#Cookie管理" class="headerlink" title="Cookie管理"></a>Cookie管理</h2><p>比起<code>UIWebView</code>的自动管理，<code>WKWebView</code>坑爹的<code>Cookie</code>管理，相信阻止了很多的尝试者。许多小伙伴也许曾经都想从<code>UIWebView</code>转到<code>WKWebView</code>，但估计因为<code>Cookie</code>的问题，最终都放弃了，笔者折腾<code>WKWebView</code>的<code>Cookie</code>长达多半年之久，也曾想放弃，但最终还是坚持下来了，虽说现在不敢说完全掌握，至少也不影响正常使用了。</p>
<p>下面来说几点注意事项：</p>
<ol>
<li><code>WKWebView</code>加载网页得到的<code>Cookie</code>会同步到<code>NSHTTPCookieStorage</code>中（也许你看过一些文章说不能同步，但笔者这里说下，它真的会，大家可以尝试下，实践出真知）。</li>
<li><code>WKWebView</code>加载请求时，不会同步<code>NSHTTPCookieStorage</code>中已有的<code>Cookie</code>（是的，<strong>最坑的地方</strong>）。</li>
<li>通过共用一个<code>WKProcessPool</code>并不能解决2中<code>Cookie</code>同步问题，且可能会造成<code>Cookie</code>丢失。</li>
</ol>
<p>结合自己的实践和参考一些资料，笔者得到上面的结论。</p>
<p>关于如何操作<code>NSHTTPCookieStorage</code>，前面的文章中提到过了，本文不再赘述。对于问题2，<a href="http://stackoverflow.com/questions/26573137/can-i-set-the-cookies-to-be-used-by-a-wkwebview" target="_blank" rel="external">StackOverFlow上有些解答</a>，但经过实际尝试，发现还是或多或少有一些问题。</p>
<p>为了解决这个最为致命的Cookie问题，需要的做的有以下几点：</p>
<h3 id="解决首次加载Cookie带不上问题"><a href="#解决首次加载Cookie带不上问题" class="headerlink" title="解决首次加载Cookie带不上问题"></a>解决首次加载Cookie带不上问题</h3><p>在request的requestHeader中添加Cookie：</p>
<pre><code class="objective-c">NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@&quot;http://www.baidu.com&quot;]];
NSArray *cookies = [NSHTTPCookieStorage sharedHTTPCookieStorage].cookies;
//Cookies数组转换为requestHeaderFields
NSDictionary *requestHeaderFields = [NSHTTPCookie requestHeaderFieldsWithCookies:cookies];
//设置请求头
request.allHTTPHeaderFields = requestHeaderFields;
[self.webView loadRequest:request];
</code></pre>
<p>这样，只要你<strong>保证<code>sharedHTTPCookieStorage</code>中你的Cookie存在</strong>，首次访问一个页面，就不会有问题。</p>
<h3 id="解决后续Ajax请求Cookie丢失问题"><a href="#解决后续Ajax请求Cookie丢失问题" class="headerlink" title="解决后续Ajax请求Cookie丢失问题"></a>解决后续Ajax请求Cookie丢失问题</h3><p>解决此问题，也比较简单，添加<code>WKUserScript</code>。</p>
<pre><code class="objective-c">/*!
 *  更新webView的cookie
 */
- (void)updateWebViewCookie
{
    WKUserScript * cookieScript = [[WKUserScript alloc] initWithSource:[self cookieString] injectionTime:WKUserScriptInjectionTimeAtDocumentStart forMainFrameOnly:NO];
    //添加Cookie
    [self.configuration.userContentController addUserScript:cookieScript];
}

- (NSString *)cookieString
{
    NSMutableString *script = [NSMutableString string];
    for (NSHTTPCookie *cookie in [[NSHTTPCookieStorage sharedHTTPCookieStorage] cookies]) {
        // Skip cookies that will break our script
        if ([cookie.value rangeOfString:@&quot;&#39;&quot;].location != NSNotFound) {
            continue;
        }
        // Create a line that appends this cookie to the web view&#39;s document&#39;s cookies
        [script appendFormat:@&quot;document.cookie=&#39;%@&#39;; \n&quot;, cookie.da_javascriptString];
    }
    return script;
}

@interface NSHTTPCookie (Utils)

- (NSString *)da_javascriptString;

@end

@implementation NSHTTPCookie (Utils)

- (NSString *)da_javascriptString
{
    NSString *string = [NSString stringWithFormat:@&quot;%@=%@;domain=%@;path=%@&quot;,
                        self.name,
                        self.value,
                        self.domain,
                        self.path ?: @&quot;/&quot;];
    if (self.secure) {
        string = [string stringByAppendingString:@&quot;;secure=true&quot;];
    }
    return string;
}

@end
</code></pre>
<p>同样只要你<strong>保证<code>sharedHTTPCookieStorage</code>中你的Cookie存在</strong>，后续Ajax请求就不会有问题。</p>
<h3 id="解决跳转新页面时Cookie带不过去问题"><a href="#解决跳转新页面时Cookie带不过去问题" class="headerlink" title="解决跳转新页面时Cookie带不过去问题"></a>解决跳转新页面时Cookie带不过去问题</h3><p>即便你做到了上面两点，你会发现，当你点击页面上的某个链接，跳转到新的页面，<code>Cookie</code>又丢了😳，此时你是想狗带的~怎么解决呢？</p>
<pre><code class="objective-c">//核心方法：
/**
 修复打开链接Cookie丢失问题

 @param request 请求
 @return 一个fixedRequest
 */
- (NSURLRequest *)fixRequest:(NSURLRequest *)request
{
    NSMutableURLRequest *fixedRequest;
    if ([request isKindOfClass:[NSMutableURLRequest class]]) {
        fixedRequest = (NSMutableURLRequest *)request;
    } else {
        fixedRequest = request.mutableCopy;
    }
    //防止Cookie丢失
    NSDictionary *dict = [NSHTTPCookie requestHeaderFieldsWithCookies:[NSHTTPCookieStorage sharedHTTPCookieStorage].cookies];
    if (dict.count) {
        NSMutableDictionary *mDict = request.allHTTPHeaderFields.mutableCopy;
        [mDict setValuesForKeysWithDictionary:dict];
        fixedRequest.allHTTPHeaderFields = mDict;
    }
    return fixedRequest;
}

#pragma mark - WKNavigationDelegate 

- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler {

#warning important 这里很重要
    //解决Cookie丢失问题
    NSURLRequest *originalRequest = navigationAction.request;
    [self fixRequest:originalRequest];
    //如果originalRequest就是NSMutableURLRequest, originalRequest中已添加必要的Cookie，可以跳转
    //允许跳转
    decisionHandler(WKNavigationActionPolicyAllow);
    //可能有小伙伴，会说如果originalRequest是NSURLRequest，不可变，那不就添加不了Cookie了，是的，我们不能因为这个问题，不允许跳转，也不能在不允许跳转之后用loadRequest加载fixedRequest，否则会出现死循环，具体的，小伙伴们可以用本地的html测试下。

    NSLog(@&quot;%@&quot;, NSStringFromSelector(_cmd));
}

#pragma mark - WKUIDelegate

- (WKWebView *)webView:(WKWebView *)webView createWebViewWithConfiguration:(WKWebViewConfiguration *)configuration forNavigationAction:(WKNavigationAction *)navigationAction windowFeatures:(WKWindowFeatures *)windowFeatures {

#warning important 这里也很重要
    //这里不打开新窗口
    [self.webView loadRequest:[self fixRequest:navigationAction.request]];
    return nil;
}
</code></pre>
<p>最终的方法，已经附上。小伙伴们自行参考。同样需要你<strong>保证<code>sharedHTTPCookieStorage</code>中你的Cookie存在</strong>。</p>
<h3 id="解决上面3步都做了Cookie依然丢失"><a href="#解决上面3步都做了Cookie依然丢失" class="headerlink" title="解决上面3步都做了Cookie依然丢失"></a>解决上面3步都做了Cookie依然丢失</h3><p>看过上面的方法过后，小伙伴们应该记得最清楚的是<strong>保证<code>sharedHTTPCookieStorage</code>中你的Cookie存在</strong>。怎么保证呢？由于<strong><code>WKWebView</code>加载网页得到的<code>Cookie</code>会同步到<code>NSHTTPCookieStorage</code>中</strong>的特点，有时候你强行添加的<code>Cookie</code>会在同步过程中丢失。抓包（<a href="https://www.charlesproxy.com" target="_blank" rel="external">Mac推荐Charles</a>）你就会发现，点击一个链接时，<code>Request</code>的<code>header</code>中多了<code>Set-Cookie</code>字段，其实Cookie已经丢了。下面推荐笔者的解决方案，那就是把自己需要的<code>Cookie</code>主动保存起来，每次调用<code>[NSHTTPCookieStorage sharedHTTPCookieStorage].cookies</code>方法时，保证返回的数组中有自己需要的<code>Cookie</code>。下面上代码，用了<code>runtime</code>的<code>Method Swizzling</code>，详细代码，请参考<a href="https://github.com/DarkAngel7/Demos-WebViewDemo" target="_blank" rel="external">Demo</a>。</p>
<p>首先是在适当的时候，保存</p>
<pre><code class="objective-c">//比如登录成功，保存Cookie
NSArray *allCookies = [[NSHTTPCookieStorage sharedHTTPCookieStorage] cookies];
for (NSHTTPCookie *cookie in allCookies) {
    if ([cookie.name isEqualToString:DAServerSessionCookieName]) {
        NSDictionary *dict = [[NSUserDefaults standardUserDefaults] dictionaryForKey:DAUserDefaultsCookieStorageKey];
        if (dict) {
            NSHTTPCookie *localCookie = [NSHTTPCookie cookieWithProperties:dict];
            if (![cookie.value isEqual:localCookie.value]) {
                NSLog(@&quot;本地Cookie有更新&quot;);
            }
        }
        [[NSUserDefaults standardUserDefaults] setObject:cookie.properties forKey:DAUserDefaultsCookieStorageKey];
        [[NSUserDefaults standardUserDefaults] synchronize];
        break;
    }
}
</code></pre>
<p>在读取时，如果没有则添加</p>
<pre><code class="objective-c">@implementation NSHTTPCookieStorage (Utils)

+ (void)load
{
    class_methodSwizzling(self, @selector(cookies), @selector(da_cookies));
}

- (NSArray&lt;NSHTTPCookie *&gt; *)da_cookies
{
    NSArray *cookies = [self da_cookies];
    BOOL isExist = NO;
    for (NSHTTPCookie *cookie in cookies) {
        if ([cookie.name isEqualToString:DAServerSessionCookieName]) {
            isExist = YES;
            break;
        }
    }
    if (!isExist) {
        //CookieStroage中添加
        NSDictionary *dict = [[NSUserDefaults standardUserDefaults] dictionaryForKey:DAUserDefaultsCookieStorageKey];
        if (dict) {
            NSHTTPCookie *cookie = [NSHTTPCookie cookieWithProperties:dict];
            [[NSHTTPCookieStorage sharedHTTPCookieStorage] setCookie:cookie];
            NSMutableArray *mCookies = cookies.mutableCopy;
            [mCookies addObject:cookie];
            cookies = mCookies.copy;
        }
    }
    return cookies;
}

@end
</code></pre>
<p>当打开手机百度首页后，我们查看页面中的Cookie<img src="http://ww4.sinaimg.cn/large/006tNc79ly1ffgge4xfiqj31jk104tj9.jpg" alt="DB6E63BA-868D-4CD2-9B1B-AC4BD1368437"></p>
<p>其中第一个，是之前测试添加的，用来动态注入js。</p>
<pre><code class="objective-c">WKUserScript *newCookieScript = [[WKUserScript alloc] initWithSource:@&quot;document.cookie = &#39;DarkAngelCookie=DarkAngel;&#39;&quot; injectionTime:WKUserScriptInjectionTimeAtDocumentStart forMainFrameOnly:NO];
[controller addUserScript:newCookieScript];
</code></pre>
<p>第二个，就是真正有用的Cookie啦，这幅图用到了<code>Safari</code>调试，后面会讲到。通过上面的折腾，一般，就能够有效减少Cookie的丢失了。</p>
<h2 id="性能对比"><a href="#性能对比" class="headerlink" title="性能对比"></a>性能对比</h2><p>加载一般的页面，对比不出什么，这里我就测试下内存占用吧，同样一个html，分布看下内存占用。</p>
<p>UIWebView<img src="http://ww4.sinaimg.cn/large/006tNc79ly1ffggxn9b71j318q0gowhc.jpg" alt="C9A288B5-77EE-4FAF-8BAE-1F3E3AD7C86C"></p>
<p>WKWebView<img src="http://ww4.sinaimg.cn/large/006tNc79ly1ffggyx4o9wj31880gqgon.jpg" alt="A8AC12E1-DCDB-453A-AC24-30434485B287"></p>
<p>从页面UI元素上看，<code>WKWebView</code>还多个<code>barButtonItem</code>呢，这么简单个页，内存占用也小了3M，复杂的页面可想而知。</p>
<h2 id="各种坑"><a href="#各种坑" class="headerlink" title="各种坑"></a>各种坑</h2><p>虽然<code>WKWebView</code>真的很不错，但是它的坑，还是有很多的，下面简单说下。</p>
<h3 id="js-alert方法不弹窗"><a href="#js-alert方法不弹窗" class="headerlink" title="js alert方法不弹窗"></a>js alert方法不弹窗</h3><p>之前提过<code>WKUIDelegate</code>所有的方法都是<code>Optional</code>，但如果你不实现，它就会</p>
<blockquote>
<p> If you do not implement this method, the web view will behave as if the user selected the OK button.</p>
<pre><code class="objective-c">- (void)webView:(WKWebView *)webView runJavaScriptAlertPanelWithMessage:(NSString *)message initiatedByFrame:(WKFrameInfo *)frame completionHandler:(void (^)(void))completionHandler;
</code></pre>
</blockquote>
<p>OK，意思就是说，如果不实现，就什么都不发生，好吧，乖乖实现吧，实现了就能弹窗了。</p>
<h3 id="白屏问题"><a href="#白屏问题" class="headerlink" title="白屏问题"></a>白屏问题</h3><p>当WKWebView加载的网页占用内存过大时，会出现白屏现象。解决方案是</p>
<pre><code class="objective-c">/*! @abstract Invoked when the web view&#39;s web content process is terminated.
 @param webView The web view whose underlying web content process was terminated.
 */
- (void)webViewWebContentProcessDidTerminate:(WKWebView *)webView {
    [webView reload];    //刷新就好了
}
</code></pre>
<p>有时白屏，不会调用该方法，具体的解决方案是</p>
<blockquote>
<p>比如，最近遇到在一个高内存消耗的H5页面上 present 系统相机，拍照完毕后返回原来页面的时候出现白屏现象（拍照过程消耗了大量内存，导致内存紧张，WebContent Process 被系统挂起），但上面的回调函数并没有被调用。在WKWebView白屏的时候，另一种现象是 webView.titile 会被置空, 因此，可以在 viewWillAppear 的时候检测 webView.title 是否为空来 reload 页面。（出自<a href="http://mp.weixin.qq.com/s/rhYKLIbXOsUJC_n6dt9UfA" target="_blank" rel="external">WKWebView 那些坑</a>）</p>
</blockquote>
<h3 id="Cookie丢失"><a href="#Cookie丢失" class="headerlink" title="Cookie丢失"></a>Cookie丢失</h3><p>从一个登录状态的页面跳转到另一个页面，WTF，登录状态丢失了？什么鬼？其实上文中的<strong>Cookie管理</strong>一节，已经介绍过解决方案了，原因也就是<strong><code>WKWebView</code>加载请求时，不会同步<code>NSHTTPCookieStorage</code>中已有的<code>Cookie</code></strong>。如果偶尔还是会出现丢失登录状态的情况，那笔者只能说，再检查下自己的代码，找找原因，有好的解决方案，欢迎告知笔者。</p>
<h3 id="evaluateJavaScript-completionHandler-异步"><a href="#evaluateJavaScript-completionHandler-异步" class="headerlink" title="evaluateJavaScript:completionHandler:异步"></a>evaluateJavaScript:completionHandler:异步</h3><p>该方法是异步回调，这个一看方法的声明便知。可能有小伙伴就是需要同步获取返回值，有没有办法呢？答案是<strong>没有</strong>。</p>
<p>可能你会说用信号量<code>dispatch_semaphore_t</code>。好吧，可能你会这么写~</p>
<pre><code class="objective-c">__block id cookies;
dispatch_semaphore_t semaphore = dispatch_semaphore_create(0);
[self.webView evaluateJavaScript:@&quot;document.cookie&quot; completionHandler:^(id _Nullable result, NSError * _Nullable error) {
    cookies = result;
    dispatch_semaphore_signal(semaphore);
}];
//等待三秒，接收参数
dispatch_semaphore_wait(semaphore, dispatch_time(DISPATCH_TIME_NOW, 3 * NSEC_PER_SEC));
//打印cookie，肯定为空，因为足足等了3s，dispatch_semaphore_signal都没有起作用
NSLog(@&quot;cookie的值为：%@&quot;, cookies);
</code></pre>
<p>笔者故意只等待了3s，如果你等待<code>DISPATCH_TIME_FOREVER</code>，恭喜你，程序不会Crash，但界面卡死了。笔者测试的结果是，<code>NSLog</code>的触发时间要早于<code>completionHandler</code>回调，不论你等多久，它都会打印null。所以当你永久等待时，就卡死了。这里的缘由，笔者不太清楚，有搞清楚的小伙伴可以帮忙指点一下，谢谢~</p>
<p>所以还是老实的接受异步回调吧，不要用信号来搞成同步，会卡死的。</p>
<h3 id="自定义contentInset刷新时页面跳动的bug"><a href="#自定义contentInset刷新时页面跳动的bug" class="headerlink" title="自定义contentInset刷新时页面跳动的bug"></a>自定义contentInset刷新时页面跳动的bug</h3><p>PM说毛玻璃好看，👌，so easy，于是我们在代码如敲下</p>
<pre><code class="objective-c">self.webView.scrollView.contentInset = UIEdgeInsetsMake(64, 0, 49, 0);
</code></pre>
<p>然后默默的微笑着点击了cmd + R，太简单了。然后看到了这样的画面</p>
<p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1ffgi7f2g9qg30ck0n9anq.gif" alt="new"></p>
<p><img src="http://ww1.sinaimg.cn/large/006tNc79ly1ffghw4zwopj3068061wed.jpg" alt="timg"></p>
<p>是的，上面的方法在<code>UIWebView</code>中没毛病，可是在<code>WKWebView</code>中，就产生了刷新时页面跳动的bug。</p>
<p>这个坑，坑了我大半年之久，Apple的<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/WebKit/ObjC_classic/index.html" target="_blank" rel="external">Document</a>中没有记录，最终笔者在Apple开源的<a href="https://opensource.apple.com/source/WebKit2/" target="_blank" rel="external">WebKit2</a>的<a href="[https://opensource.apple.com/source/WebKit2/WebKit2-7603.1.30.0.34/ChangeLog-2014-10-07.auto.html](https://opensource.apple.com/source/WebKit2/WebKit2-7603.1.30.0.34/ChangeLog-2014-10-07.auto.html">ChangeLog</a>)中找到了答案。下面是官方人员的回答：</p>
<p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1ffghllqjz6j310w0ewagc.jpg" alt="A9018C2C-BB21-41A1-9A67-E6CCE2D75A0E"></p>
<p>厉害了，word哥，我选择狗带，居然还是私有Api。怎么整呢？</p>
<pre><code class="objective-c">self.webView.scrollView.contentInset = UIEdgeInsetsMake(64, 0, 49, 0);
//史诗级神坑，为何如此写呢？参考https://opensource.apple.com/source/WebKit2/WebKit2-7600.1.4.11.10/ChangeLog  
[self.webView setValue:[NSValue valueWithUIEdgeInsets:self.webView.scrollView.contentInset] forKey:@&quot;_obscuredInsets&quot;];    //kvc给WKWebView的私有变量_obscuredInsets设置值
</code></pre>
<p>这么写就OK了，通过KVC设置私有变量的值，笔者用了半年了，过Apple审核没问题，不用担心。如果这个能帮助到大家，不用感谢我~</p>
<h3 id="加载POST请求丢失RequestBody"><a href="#加载POST请求丢失RequestBody" class="headerlink" title="加载POST请求丢失RequestBody"></a>加载POST请求丢失RequestBody</h3><p>这个问题，没有直接的解决办法。问题的根源在于：</p>
<blockquote>
<p>在 webkit2 的设计里使用 MessageQueue 进行进程之间的通信，Network Process 会将请求 encode 成一个 Message,然后通过 IPC 发送给 App Process。出于性能的原因，encode 的时候 HTTPBody 和 HTTPBodyStream 这两个字段被丢弃掉了。</p>
<p>因此，<strong>如果通过 registerSchemeForCustomProtocol 注册了 http(s) scheme, 那么由 WKWebView 发起的所有 http(s)请求都会通过 IPC 传给主进程 NSURLProtocol 处理，导致 post 请求 body 被清空</strong>。</p>
<p>（出自<a href="http://mp.weixin.qq.com/s/rhYKLIbXOsUJC_n6dt9UfA" target="_blank" rel="external">WKWebView 那些坑</a>）</p>
</blockquote>
<p>参考 <a href="https://github.com/WebKit/webkit/blob/fe39539b83d28751e86077b173abd5b7872ce3f9/Source/WebKit2/Shared/mac/WebCoreArgumentCodersMac.mm#L61-L88" target="_blank" rel="external">Apple源码</a> 及 <a href="https://bugs.webkit.org/show_bug.cgi?id=138169" target="_blank" rel="external">bug report</a> 。</p>
<p>具体的解决办法，就是另辟蹊径，<a href="http://mp.weixin.qq.com/s/rhYKLIbXOsUJC_n6dt9UfA" target="_blank" rel="external">WKWebView 那些坑</a>中有介绍，这里笔者不再展开。</p>
<p>因为<code>WKWebView</code>被设计的使用场景，是用来当做浏览器，解决Native可以直接在App内浏览网页的问题。而浏览器浏览一个网站，怎么可能是POST请求呢？所以这个问题，笔者目前感受较小，有需要的小伙伴可以自行解决。</p>
<h3 id="NSURLProtocol问题"><a href="#NSURLProtocol问题" class="headerlink" title="NSURLProtocol问题"></a>NSURLProtocol问题</h3><p><code>WKWebView</code>不同于<code>UIWebView</code>，其实并不支持<code>NSURLProtocol</code>。如果想拦截，可以通过调用私有Api。</p>
<pre><code class="objective-c">+ [WKBrowsingContextController registerSchemeForCustomProtocol:]
</code></pre>
<p>此方法缺点也很多，笔者这里不推荐小伙伴使用，毕竟调用私有Api是Apple禁止的。况且，真的必须使用<code>NSURLProtocol</code>的话，还是用<code>UIWebView</code>吧。</p>
<h1 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h1><p>本文主要讲述了<code>WKWebView</code>的一些基础用法、OC与JS的交互，Cookie的管理，以及一些使用过程中的坑，旨在为没用过的小伙伴们详细介绍下。虽然它的坑很多，但是它的优点也有很多，我们应该敢于拥抱新事物，拥抱新知识。还在等什么？<code>WKWebView</code>赶快用起来吧~</p>
<p>下篇文章，将主要为小伙伴们介绍下如果用Safari调试，实际应用中一些需求如何实现，如何更好的与前端h5开发同学配合以及如何找出问题所在等。下篇文章见~</p>
<p>To be continued…</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/006tNc79ly1fff1sa06wrj30sg0iwwi9.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; titl
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>iOS中NSUserDefaults的黑科技</title>
    <link href="http://blog.darkangel7.com/2017/05/05/iOS%E4%B8%ADNSUserDefaults%E7%9A%84%E9%BB%91%E7%A7%91%E6%8A%80/"/>
    <id>http://blog.darkangel7.com/2017/05/05/iOS中NSUserDefaults的黑科技/</id>
    <published>2017-05-05T04:18:12.000Z</published>
    <updated>2017-05-05T09:24:15.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在iOS开发中，我们时常需要保存一些数据，或者希望在用户下次打开App时，依然可以保留一些设置等，比如<strong>主题设置</strong>、<strong>语言设置</strong>，那么我们一般会选择使用<code>NSUserDefaults</code>作为轻量级数据持久化方案。这里不对其他的数据持久化方案（如Plist、归档、Sqlite3、CoreData等）进行探讨，主要来介绍一下<code>NSUserDefaults</code>中的一些黑科技。</p>
<h1 id="NSUserDefaults简介"><a href="#NSUserDefaults简介" class="headerlink" title="NSUserDefaults简介"></a>NSUserDefaults简介</h1><p><code>NSUserDefaults</code>在Foundation框架中被定义，用来存储和读取一些轻量级数据。其本质是操作plist文件。</p>
<p>它比其他数据持久化方案的优点在于：</p>
<ul>
<li>轻量级。</li>
<li>方便快捷直接使用。</li>
<li>支持<code>NSData</code>, <code>NSString</code>, <code>NSNumber</code>, <code>NSDate</code>, <code>NSArray</code> and  <code>NSDictionary</code>。</li>
</ul>
<p>缺点在于：</p>
<ul>
<li>不适合大量数据。</li>
<li>无法存储自定义<code>model</code>。</li>
</ul>
<h1 id="黑科技"><a href="#黑科技" class="headerlink" title="黑科技"></a>黑科技</h1><p>一些<code>NSUserDefaults</code>最基础的用法，这里就不赘述了。说到黑科技，一般指的是鲜为人知而又十分厉害的技术。这里主要介绍两个黑科技。</p>
<h2 id="还原默认值"><a href="#还原默认值" class="headerlink" title="还原默认值"></a>还原默认值</h2><p>一般<code>NSUserDefaults</code>使用，都会保存一些自定义的Key和Value，其实这个不涉及还原默认值的问题。其实有些时候，是需要修改其中的系统默认值的。比如应用内切换中英文，就需要修改<code>AppleLanguages</code>的value。既然修改了系统默认值，怎么还原默认值呢？</p>
<p>我们先来看一下修改前的：</p>
<pre><code>po [NSUserDefaults standardUserDefaults].dictionaryRepresentation

{
    ...
    AppleLanguages =     (
        en,
        &quot;zh-Hans-US&quot;
    );
    AppleLocale = &quot;en_US&quot;;
    ...
}
</code></pre><p>可以看到<code>AppleLanguages</code>对应的是一个数组，如果我们在App内想切换成中文，执行</p>
<pre><code class="objective-c">[[NSUserDefaults standardUserDefaults] setObject:@[@&quot;zh-Hans&quot;] forKey:@&quot;AppleLanguages&quot;];
</code></pre>
<p>再次看下修改后</p>
<pre><code>po [NSUserDefaults standardUserDefaults].dictionaryRepresentation

{
    ...
    AppleLanguages =     (
        zh-Hans
    );
    AppleLocale = &quot;en_US&quot;;
    ...
}
</code></pre><p>好吧，这个<code>AppleLanguages</code>字段的值已经被记录了。这时候，kill客户端，重新打开客户端，发现，这个值肯定不会变。那么如果这个时候用户在系统设置中切换到了日语，那么我想在客户端中通过<strong>跟随手机系统</strong>的设置，还原到日语，该怎么办呢？</p>
<p>或许你会想到记录初始值，只要提前记录，在还原时再set回去就可以了。嗯~没毛病，可是在什么地方什么时候记录初始值呢？这个<code>AppleLanguages</code>字段其实就是系统的语言默认值，你已经把它改过了，如果在你改过之后用户又修改了系统语言，那你是拿不到新默认值的，所以这条路是走不通的。</p>
<p>那怎么实现还原默认值呢？看下这个方法：</p>
<pre><code>/*!
 -setObject:forKey: immediately stores a value (or removes the value if nil is passed as the value) for the provided key in the search list entry for the receiver&#39;s suite name in the current user and any host, then asynchronously stores the value persistently, where it is made available to other processes.
 */
- (void)setObject:(nullable id)value forKey:(NSString *)defaultName;
</code></pre><p>这个方法Document中并没有描述过多，基本都是在强调<code>value</code>必须是<code>NSData</code>, <code>NSString</code>, <code>NSNumber</code>, <code>NSDate</code>, <code>NSArray</code> and  <code>NSDictionary</code>中的一种，且<code>NSArray</code> and  <code>NSDictionary</code>中的值也必须是Plist支持的类型。在注释中有强调，<code>removes the value if nil is passed as the value</code>，传nil等同于删除这个键值对。</p>
<pre><code>/// -removeObjectForKey: is equivalent to -[... setObject:nil forKey:defaultName]
- (void)removeObjectForKey:(NSString *)defaultName;
</code></pre><p>其实这里才是关键</p>
<pre><code>[[NSUserDefaults standardUserDefaults] setObject:nil forKey:@&quot;AppleLanguages&quot;];
//or
[[NSUserDefaults standardUserDefaults] removeObjectForKey:@&quot;AppleLanguages&quot;];
</code></pre><p>然后再次</p>
<pre><code>po [NSUserDefaults standardUserDefaults].dictionaryRepresentation

{
    ...
    AppleLanguages =     (
        en,
        &quot;zh-Hans-US&quot;
    );
    AppleLocale = &quot;en_US&quot;;
    ...
}
</code></pre><p>你会发现，WTF，居然这个字段还存在，且还原成了默认值，厉害了word哥。本方法是本人历经各种坑之后发现的，且官方文档中没有任何提及，只能说Apple爸爸任性。</p>
<h2 id="巧用SuiteName"><a href="#巧用SuiteName" class="headerlink" title="巧用SuiteName"></a>巧用SuiteName</h2><pre><code>- (nullable instancetype)initWithSuiteName:(nullable NSString *)suitename NS_AVAILABLE(10_9, 7_0) NS_DESIGNATED_INITIALIZER;
</code></pre><p>这个方法，想必各位不会陌生，在跨App间通信或者主App与Extension共享数据，都会用到，一般配合使用的是<strong>App Groups</strong>。</p>
<h3 id="App-Groups数据共享"><a href="#App-Groups数据共享" class="headerlink" title="App Groups数据共享"></a>App Groups数据共享</h3><p>在App Groups中使用，一般两个App都需要加入同一个Group。<img src="http://ww1.sinaimg.cn/large/006tNbRwly1ffajfof2qdj30x00cqjsl.jpg" alt="">然后在两个App分别使用</p>
<pre><code class="objective-c">- (NSUserDefaults *)userDefaults
{
    return [[NSUserDefaults alloc] initWithSuiteName:@&quot;group.urwork.autosignin&quot;];    //name需要是Group的id
}
</code></pre>
<p>来存储和读取数据，即可实现数据共享。</p>
<h3 id="超微型简单方便易用数据库"><a href="#超微型简单方便易用数据库" class="headerlink" title="超微型简单方便易用数据库"></a>超微型简单方便易用数据库</h3><p>这里，其实主要介绍一下<code>initWithSuiteName:</code>的另一个用途，我称之为<strong>超微型简单方便易用数据库</strong>。</p>
<p><strong>需求</strong>：后台同学最近太忙（😳这不是理由），需要客户端同学临时开发一个本地的浏览历史功能。简单的说就是在客户端本地保存每个用户浏览的文章记录。</p>
<p><strong>吐糟</strong>：好吧，时间紧，任务重，功能先上线，后续再优化已经是一个习惯了😳。</p>
<p><strong>实现方案</strong>：简单，本地存个字典（或者Plist文件），每个key是一个用户id，value是一个数组，数组里的每个元素是一个字典，这个字典里有<code>articleId</code>、<code>title</code>、<code>imgUrl</code>、<code>...</code>。结构大概是这样：</p>
<pre><code>{
  &quot;10086&quot; : [
    {
      &quot;articleId&quot; : 1,
      &quot;imgUrl&quot; : &quot;https://img.xxx.com/abcdefg.png&quot;,
      &quot;title&quot; : &quot;中国历史&quot;,
      ...
    },
    {
      &quot;articleId&quot; : 2,
      &quot;imgUrl&quot; : &quot;https://img.xxx.com/abcdefg.png&quot;,
      &quot;title&quot; : &quot;中国教育&quot;,
      ...
    },
    ...
  ],
  &quot;10087&quot; : [
    {
      &quot;articleId&quot; : 2,
      &quot;imgUrl&quot; : &quot;https://img.xxx.com/abcdefg.png&quot;,
      &quot;title&quot; : &quot;中国教育&quot;,
      ...
    },
    ...
  ]
}
</code></pre><p>看起来OK，但是小伙伴们，性能问题还是要考虑的。我想获取某个用户的浏览历史，需要把文件整体读到内存中，然后用<code>dict[@&quot;10086&quot;]</code>的方法，得到这个用户的浏览历史<code>Array</code>，用户少还好，多了，每次读取的IO操作会很耗时，对性能有影响。</p>
<p>可能你会说用数据库啊什么的，当然可以，但是又是需要依赖一堆第三方，还要写好多代码，创建好多类。我就是想简单实现一下，有没有更好的方法呢？当然有，<strong>超微型简单方便易用数据库</strong>。</p>
<p>每个用户都可以用一个<code>NSUserDefaults</code>来代替，每个用户的浏览历史，可以直接用<code>setObject:forKey:</code>的方式来存储，如：</p>
<pre><code class="objective-c">//这个跟App Groups没有关系
//已有则读取，没有则创建
NSUserDefaults *userDefaults = [[NSUserDefaults alloc] initWithSuiteName:@&quot;10086&quot;];
//存储
[userDefaults setObject:history forKey:@&quot;ArticleBrowsingHistory&quot;];
//读取
NSArray *history = [userDefaults objectForKey:@&quot;ArticleBrowsingHistory&quot;];
</code></pre>
<p>所有用户相对独立，每个用户是一个plist文件，在沙盒目录<code>/Library/Preferences/</code>中，<img src="http://ww2.sinaimg.cn/large/006tNbRwly1ffalfnmhudj30z007kab7.jpg" alt="">想删除也很容易，直接删除这个文件即可。</p>
<p>其实这个<strong>超微型简单方便易用数据库</strong>还可以实现好多功能，看你怎么操作了。如果你的App没有后台，不同用户的主题设置、语言设置可能不同，都可以通过这个来存储。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实很多我们很常用的东西都有很多我们未发掘出的用途，生活也是同样，学会发现，一切会更美好。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;在iOS开发中，我们时常需要保存一些数据，或者希望在用户下次打开App时，依然可以保留一些设置等，比如&lt;strong&gt;主题设置&lt;/stron
    
    </summary>
    
    
      <category term="iOS技术分享" scheme="http://blog.darkangel7.com/tags/iOS%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>在iOS App内优雅的动态切换语言</title>
    <link href="http://blog.darkangel7.com/2017/05/04/%E5%9C%A8iOSApp%E5%86%85%E4%BC%98%E9%9B%85%E7%9A%84%E5%8A%A8%E6%80%81%E5%88%87%E6%8D%A2%E8%AF%AD%E8%A8%80/"/>
    <id>http://blog.darkangel7.com/2017/05/04/在iOSApp内优雅的动态切换语言/</id>
    <published>2017-05-04T03:46:56.000Z</published>
    <updated>2017-05-05T09:28:31.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>随着公司业务的发展，App版本的迭代，相信不少App都需要英文化（国际化）。App英文化，不外乎这三点：</p>
<ol>
<li>纯代码中引用的strings国际化；</li>
<li>Storyboard/Xib国际化；</li>
<li>Info.plist国际化。</li>
</ol>
<p>具体这三种分别如何操作，怎么国际化，这里不再赘述。一般App做了国际化，那么在用户切换手机系统Settings里的Language时，App就会切换成对应的语言（前提是做过该语言国际化）。那么如果想实现<strong>微博</strong>和<strong>微信</strong>等App，在App内部实现切换语言，应该怎么做呢？如何做，才能更加优雅的动态切换语言呢？</p>
<p>下面，讲一讲如何在iOS App内优雅的动态切换语言。</p>
<h1 id="调研"><a href="#调研" class="headerlink" title="调研"></a>调研</h1><p>如果有相关需求，一般成熟的App都会怎么做呢？这里我们来看一下<strong>微博</strong>和<strong>微信</strong>。</p>
<p><strong>微博</strong>：</p>
<p><img src="http://ww3.sinaimg.cn/large/006tKfTcly1ff9jfo5a8ig306y0cctz0.gif" alt=""></p>
<p><strong>微信</strong>：</p>
<p><img src="http://ww1.sinaimg.cn/large/006tKfTcly1ff9d5ezj9jg30680b3kif.gif" alt=""></p>
<p>对比一下可以看出，微博整体的效果比微信好很多，丝滑流畅。</p>
<p><strong><em>这里注意一下细节</em></strong>：我在微博的个人中心是故意上滑了一下，然后点击进入设置，进行语言切换，可以看到切换时很自然，然后返回个人中心时，页面<code>scrollView</code>的<code>contentOffset</code>并没有发生变化，由此可以推测：</p>
<p><strong><u>微博的思路是，在切换语言时，发送通知<code>NSNotification</code>，所有的UI控件监听通知，然后在适当的时候刷新UI</u></strong>。那么其实这么写，需要做的东西很多，或是通过Base类来实现，或是通过<code>runtime</code>实现，总之<code>Button</code>、<code>Label</code>、<code>TextField</code>等等都需要有一套统一的更新机制，可能不是一个最简单的办法。</p>
<p><strong><u>而微信切换的方案是，刷新<code>keyWindow</code>的<code>rootViewController</code>，然后跳转到设置页，所以你会看到切换语言的一瞬间界面出现匪夷所思的bug，如下图</u></strong></p>
<p><img src="http://ww1.sinaimg.cn/large/006tKfTcly1ff9iduf60aj306y0cbjrm.jpg" alt=""></p>
<p>其实微信的方案是个最简单的方案，只不过没有处理好这个小系统bug。</p>
<h1 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h1><h2 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h2><h3 id="NSBundle"><a href="#NSBundle" class="headerlink" title="NSBundle"></a>NSBundle</h3><p>其实大家应该知道，无论是代码还是Storyboard/Xib，显示的国际化字符串都会走这个方法，传入一个<code>key</code>，获取<code>localizedString</code>。</p>
<p><code>NSBundle</code>的方法：</p>
<pre><code class="objective-c">- (NSString *)localizedStringForKey:(NSString *)key value:(nullable NSString *)value table:(nullable NSString *)tableName;
</code></pre>
<p>比如我们常用的宏<code>NSLocalizedString(@&quot;done&quot;, nil)</code></p>
<pre><code class="objective-c">#define NSLocalizedString(key, comment) \
        [NSBundle.mainBundle localizedStringForKey:(key) value:@&quot;&quot; table:nil]
</code></pre>
<p>那么为何，系统切换语言的时候，此方法返回的就是对应语言（前提做了该语言的国际化）的字符串呢？原因在是哪个<code>bundle</code>调用了这个方法，一般默认的都是<code>NSBundle.mainBundle</code>这个对象。</p>
<pre><code> po [NSBundle allBundles]

&lt;__NSArrayI 0x608000052f60&gt;(
NSBundle &lt;/Users/DarkAngel/Library/Developer/CoreSimulator/Devices/CF831783-E4A6-4EC2-AB99-E04304331C3A/data/Containers/Bundle/Application/B391ED77-F57B-4B5E-9E53-CFD1245583D8/LanguageSettingsDemo.app/en.lproj&gt; (not yet loaded),
NSBundle &lt;/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer/SDKs/iPhoneSimulator.sdk/System/Library/Frameworks/UIKit.framework/Artwork.bundle&gt; (not yet loaded),
DABundle &lt;/Users/DarkAngel/Library/Developer/CoreSimulator/Devices/CF831783-E4A6-4EC2-AB99-E04304331C3A/data/Containers/Bundle/Application/B391ED77-F57B-4B5E-9E53-CFD1245583D8/LanguageSettingsDemo.app&gt; (loaded)
)
</code></pre><p>可以看到有默认加载的bundle，还有个没加载的en bundle。所以，切换语言，其实只要切换了<code>bundle</code>对象，就可以让这个<code>bundle</code>根据<code>key</code>返回不同的<code>localizedString</code>。</p>
<h3 id="NSUserDefaults"><a href="#NSUserDefaults" class="headerlink" title="NSUserDefaults"></a>NSUserDefaults</h3><p>其实语言设置，只要修改<code>AppleLanguages</code>对应的值就好了。这样才能加载正确语言的<code>Storyboard/Xib</code>，以及一些<code>resources</code>(图片之类的)。</p>
<h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>方案其实很简单，每次切换语言，把用户选择的语言保存在本地，同时更改<code>bundle</code>对象，然后刷新页面就可以了。</p>
<p><img src="http://ww2.sinaimg.cn/large/006tKfTcly1ff9ji4gz3kg306y0cce09.gif" alt=""></p>
<h2 id="技术细节"><a href="#技术细节" class="headerlink" title="技术细节"></a>技术细节</h2><h3 id="保存用户设置"><a href="#保存用户设置" class="headerlink" title="保存用户设置"></a>保存用户设置</h3><p>很简单，保存在<code>NSUserDefaults</code>里。</p>
<p>这里需要说明的是<strong>跟随手机系统</strong>，即清除用户自定义设置，只需要将<code>AppleLanguages</code>字段设为<code>nil</code>即可。</p>
<p>但是当<code>AppleLanguages</code>字段设为nil，你再去获取它的值时，会发现他已经变成了系统语言的默认值。这里可以参考<a href="http://blog.darkangel7.com/2017/05/05/iOS中NSUserDefaults的黑科技/">这篇文章</a>。</p>
<p>.h</p>
<pre><code class="objective-c">/**
 设置类
 */
@interface UWConfig : NSObject
/**
 用户自定义使用的语言，当传nil时，等同于resetSystemLanguage
 */
@property (class, nonatomic, strong, nullable) NSString *userLanguage;
/**
 重置系统语言
 */
+ (void)resetSystemLanguage;
@end
</code></pre>
<p>.m</p>
<pre><code class="objective-c">#import &quot;UWConfig.h&quot;

static NSString *const UWUserLanguageKey = @&quot;UWUserLanguageKey&quot;;
#define STANDARD_USER_DEFAULT  [NSUserDefaults standardUserDefaults]

@implementation UWConfig
+ (void)setUserLanguage:(NSString *)userLanguage
{
    //跟随手机系统
    if (!userLanguage.length) {
        [self resetSystemLanguage];
        return;
    }
    //用户自定义
    [STANDARD_USER_DEFAULT setValue:userLanguage forKey:UWUserLanguageKey];
    [STANDARD_USER_DEFAULT setValue:@[userLanguage] forKey:@&quot;AppleLanguages&quot;];
    [STANDARD_USER_DEFAULT synchronize];
}

+ (NSString *)userLanguage
{
    return [STANDARD_USER_DEFAULT valueForKey:UWUserLanguageKey];
}

/**
 重置系统语言
 */
+ (void)resetSystemLanguage
{
    [STANDARD_USER_DEFAULT removeObjectForKey:UWUserLanguageKey];
    [STANDARD_USER_DEFAULT setValue:nil forKey:@&quot;AppleLanguages&quot;];
    [STANDARD_USER_DEFAULT synchronize];
}

@end
</code></pre>
<p>在需要的地方调用即可，如</p>
<pre><code class="objective-c">   if (indexPath.row == 0) {
        [UWConfig setUserLanguage:nil];
    } else if (indexPath.row == 1) {
        [UWConfig setUserLanguage:@&quot;zh-Hans&quot;];
    } else {
        [UWConfig setUserLanguage:@&quot;en&quot;];
    }
</code></pre>
<h3 id="切换Bundle"><a href="#切换Bundle" class="headerlink" title="切换Bundle"></a>切换Bundle</h3><p>当需要展示内容时，才需要用到<code>bundle</code>，我们要手动切换<code>bundle</code>对象，就用到了这几个方法：</p>
<pre><code class="objective-c">+ (nullable instancetype)bundleWithPath:(NSString *)path;
- (nullable instancetype)initWithPath:(NSString *)path NS_DESIGNATED_INITIALIZER;

+ (nullable instancetype)bundleWithURL:(NSURL *)url NS_AVAILABLE(10_6, 4_0);
- (nullable instancetype)initWithURL:(NSURL *)url NS_AVAILABLE(10_6, 4_0);
</code></pre>
<p>这里直接上代码</p>
<p>.h</p>
<pre><code class="objective-c">@interface NSBundle (UWUtils)

+ (BOOL)isChineseLanguage;

+ (NSString *)currentLanguage;

@end
</code></pre>
<p>.m</p>
<pre><code class="objective-c">#import &quot;NSBundle+UWUtils.h&quot;

@interface UWBundle : NSBundle

@end

@implementation NSBundle (UWUtils)

+ (BOOL)isChineseLanguage
{
    NSString *currentLanguage = [self currentLanguage];
    if ([currentLanguage hasPrefix:@&quot;zh-Hans&quot;]) {
        return YES;
    } else {
        return NO;
    }
}

+ (NSString *)currentLanguage
{
    return [UWConfig userLanguage] ? : [NSLocale preferredLanguages].firstObject;
}

+ (void)load
{
    static dispatch_once_t onceToken;
    dispatch_once(&amp;onceToken, ^{
        //动态继承、交换，方法类似KVO，通过修改[NSBundle mainBundle]对象的isa指针，使其指向它的子类UWBundle，这样便可以调用子类的方法；其实这里也可以使用method_swizzling来交换mainBundle的实现，来动态判断，可以同样实现。
        object_setClass([NSBundle mainBundle], [UWBundle class]);
    });
}

@end

@implementation UWBundle

- (NSString *)localizedStringForKey:(NSString *)key value:(NSString *)value table:(NSString *)tableName
{
    if ([UWBundle uw_mainBundle]) {
        return [[UWBundle uw_mainBundle] localizedStringForKey:key value:value table:tableName];
    } else {
        return [super localizedStringForKey:key value:value table:tableName];
    }
}

+ (NSBundle *)uw_mainBundle
{
    if ([NSBundle currentLanguage].length) {
        NSString *path = [[NSBundle mainBundle] pathForResource:[NSBundle currentLanguage] ofType:@&quot;lproj&quot;];
        if (path.length) {
            return [NSBundle bundleWithPath:path];
        }
    }
    return nil;
}

@end
</code></pre>
<p>这里涉及到了<code>runtime</code>的使用，代码中有注释，这里就不展开了。</p>
<h3 id="刷新页面"><a href="#刷新页面" class="headerlink" title="刷新页面"></a>刷新页面</h3><p>用微信的思路，简单化，不必要处理很多，我们只要替换<code>keyWindow</code>的<code>rootViewController</code>就好，同时解决微信的bug。</p>
<pre><code class="objective-c">    UITabBarController *tbc = [[UIStoryboard storyboardWithName:@&quot;Main&quot; bundle:[NSBundle mainBundle]] instantiateInitialViewController];
    //我这里的storyboard为了便于多人合作，这里只包含根tabBarController和多个nvc，每个nvc只有自己的rootViewController
    //跳转到个人中心
    tbc.selectedIndex = 4;
    //创建设置页面
    UWSettingViewController *vc1 = [[UIStoryboard storyboardWithName:@&quot;Main&quot; bundle:[NSBundle mainBundle]] instantiateViewControllerWithIdentifier:NSStringFromClass([UWSettingViewController class])];
    vc1.hidesBottomBarWhenPushed = YES;
    //创建语言切换页
    UWLanguageSettingsViewController *vc2 = [[UIStoryboard storyboardWithName:@&quot;Main&quot; bundle:[NSBundle mainBundle]] instantiateViewControllerWithIdentifier:NSStringFromClass([UWLanguageSettingsViewController class])];
    vc2.hidesBottomBarWhenPushed = YES;
    UINavigationController *nvc = tbc.selectedViewController;
    //备用
    NSMutableArray *vcs = nvc.viewControllers.mutableCopy;
    [vcs addObjectsFromArray:@[vc1, vc2]];
    //解决奇怪的动画bug。异步执行
    dispatch_async(dispatch_get_main_queue(), ^{
        //注意刷新rootViewController的时机，在主线程异步执行
        //先刷新rootViewController
        [UIApplication sharedApplication].keyWindow.rootViewController = tbc;
        //然后再给个人中心的nvc设置viewControllers
        nvc.viewControllers = vcs;
        //一些UI提示，可以提供更友好的用户交互（也可以删掉）
        [UWProgressHUD showLoadingWithMessage:NSLocalizedString(UWSettingMessage, nil)];
        dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(.5 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
            [UWProgressHUD dismiss];
        });
    });
</code></pre>
<p>整体下来，就可以实现在App内优雅的切换语言。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>其实在实践过程中，坑还是很多的，欢迎提问。</p>
<p>下面附上个简单的<a href="https://github.com/DarkAngel7/Demos-LanguageSettingsDemo/" target="_blank" rel="external">Demo</a>，是上面说的简化版本，大家有需要可以下载看下。里面有小福利哦，慢慢找吧~</p>
<p>最后，<a href="https://itunes.apple.com/cn/app/you-ke-gong-chang/id1034170822?mt=8" target="_blank" rel="external">优客工场</a>欢迎您。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;随着公司业务的发展，App版本的迭代，相信不少App都需要英文化（国际化）。App英文化，不外乎这三点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;纯代码中
    
    </summary>
    
    
      <category term="iOS技术分享" scheme="http://blog.darkangel7.com/tags/iOS%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>Jenkins部署MacOS Slave实现持续集成(iOS)</title>
    <link href="http://blog.darkangel7.com/2017/04/28/Jenkins%E9%83%A8%E7%BD%B2MacOS%20Slave%E5%AE%9E%E7%8E%B0%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90(iOS)/"/>
    <id>http://blog.darkangel7.com/2017/04/28/Jenkins部署MacOS Slave实现持续集成(iOS)/</id>
    <published>2017-04-28T10:49:16.000Z</published>
    <updated>2017-05-04T04:30:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>解决Linux服务器上的Jenkins无法构建Xcode工程</p>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>由于Linux服务器无法安装Xcode，所以Jenkins无法通过shell来调用xcodebuild、xcrun等命令来构建Xcode工程，因此无法持续集成，敏捷开发。下面介绍一种配置Jenkins节点的方式，来实现Linux上的Jenkins构建Xcode工程，并上传ipa到蒲公英pgyer来进行测试。</p>
<h2 id="一、配置MacOS-Slave"><a href="#一、配置MacOS-Slave" class="headerlink" title="一、配置MacOS Slave"></a>一、配置MacOS Slave</h2><p>Jenkins有个强大的功能，配置Slave(奴隶)服务器，来实现分布式部署构建。具体步骤如下：</p>
<h3 id="1-配置Mac电脑。"><a href="#1-配置Mac电脑。" class="headerlink" title="1. 配置Mac电脑。"></a>1. 配置Mac电脑。</h3><p>在<strong>系统偏好设置</strong> &gt; <strong>共享</strong> 中开启 <strong>远程登录</strong>，如下图：<br><img src="https://ww3.sinaimg.cn/large/006tNc79ly1ff2hls2iauj31140tidjg.jpg" alt=""> </p>
<h3 id="2-创建节点。"><a href="#2-创建节点。" class="headerlink" title="2. 创建节点。"></a>2. 创建节点。</h3><p>Jenkins &gt; 系统管理 &gt;  管理节点 &gt; 新建节点，输入节点名称，记得勾选 <code>Permanent Agent</code>，点击OK。</p>
<h3 id="3-配置节点。"><a href="#3-配置节点。" class="headerlink" title="3. 配置节点。"></a>3. 配置节点。</h3><p><img src="https://ww2.sinaimg.cn/large/006tNc79ly1ff2hfwxx8ej31eg0ts0wt.jpg" alt="">其中要保证<code>/User/Shared/Jenkins/</code>目录的权限为ssh链接的用户可读写。</p>
<p>Host是Mac的ip地址，Credentials是ssh登录Mac时需要的账户和密码。可以添加一个</p>
<p><img src="https://ww4.sinaimg.cn/large/006tNc79ly1ff2hhcg0f1j31gq0r842o.jpg" alt=""></p>
<p><strong>下面的部分很重要</strong>：<img src="https://ww2.sinaimg.cn/large/006tNc79ly1ff2hiwj7mpj31gs0p4dj8.jpg" alt=""></p>
<p>PATH环境变量，需要在Mac上通过</p>
<pre><code>echo $PATH
/opt/iOSOpenDev/bin:/opt/local/bin:/opt/local/sbin:/opt/local/bin:/opt/local/sbin:/opt/local/bin:/opt/local/sbin:/opt/local/bin:/opt/local/sbin:/opt/local/bin:/opt/local/sbin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin:/opt/local/bin:/opt/local/sbin/
</code></pre><p>获取，然后copy过去。</p>
<p>Keychains and Provisioning Profiles路径要填写正确。没有这个选项的安装<a href="http://wiki.jenkins-ci.org/display/JENKINS/Keychains+and+Provisioning+Profiles+Plugin" target="_blank" rel="external">Keychains and Provisioning Profiles Management</a>插件。</p>
<h3 id="4-最后保存。"><a href="#4-最后保存。" class="headerlink" title="4. 最后保存。"></a>4. 最后保存。</h3><p>如果看到</p>
<p><img src="https://ww2.sinaimg.cn/large/006tNc79ly1ff2hwlrqw8j30e203uglm.jpg" alt=""></p>
<p>即添加Mac Slave成功，且Mac Slave在线。若连不上，请反复确认<strong>远程工作目录</strong>的权限。</p>
<h2 id="二、配置Jenkins系统设置。"><a href="#二、配置Jenkins系统设置。" class="headerlink" title="二、配置Jenkins系统设置。"></a>二、配置Jenkins系统设置。</h2><h3 id="1-上传证书和描述文件。"><a href="#1-上传证书和描述文件。" class="headerlink" title="1. 上传证书和描述文件。"></a>1. 上传证书和描述文件。</h3><p>在 <strong>Jenkins</strong> &gt; <strong>系统管理</strong> &gt; <strong>Keychains and Provisioning Profiles Management</strong>中上传打包用的证书和描述文件。如下图：</p>
<p><img src="https://ww4.sinaimg.cn/large/006tNc79ly1ff2jcabj18j31kw0tijyh.jpg" alt=""></p>
<p><img src="https://ww2.sinaimg.cn/large/006tNc79ly1ff2jclndwnj31jy0siwic.jpg" alt=""></p>
<p>保存。</p>
<h3 id="2-在-Jenkins-gt-系统管理-gt-系统设置（全局设置）中设置："><a href="#2-在-Jenkins-gt-系统管理-gt-系统设置（全局设置）中设置：" class="headerlink" title="2. 在 Jenkins &gt; 系统管理 &gt; 系统设置（全局设置）中设置："></a>2. 在 <strong>Jenkins</strong> &gt; <strong>系统管理</strong> &gt; <strong>系统设置</strong>（全局设置）中设置：</h3><p><img src="https://ww1.sinaimg.cn/large/006tNc79ly1ff2j6764qgj31ei0t6adx.jpg" alt=""></p>
<p>很关键。<strong>Keychain</strong>的路径和密码需要填写Mac中登录用户的密码。</p>
<h3 id="3-在-Jenkins-gt-系统管理-gt-Configure-Global-Security-中配置："><a href="#3-在-Jenkins-gt-系统管理-gt-Configure-Global-Security-中配置：" class="headerlink" title="3. 在 Jenkins &gt; 系统管理 &gt; Configure Global Security 中配置："></a>3. 在 <strong>Jenkins</strong> &gt; <strong>系统管理</strong> &gt; <strong>Configure Global Security</strong> 中配置：</h3><p><img src="https://ww2.sinaimg.cn/large/006tNc79ly1ff2j8ffcsrj31jw0ckjt4.jpg" alt=""></p>
<p>开启Safe HTML。</p>
<h2 id="三、配置iOS项目。"><a href="#三、配置iOS项目。" class="headerlink" title="三、配置iOS项目。"></a>三、配置iOS项目。</h2><h3 id="1-安装插件。"><a href="#1-安装插件。" class="headerlink" title="1. 安装插件。"></a>1. 安装插件。</h3><p>安装 <code>build-name-setter</code>、<code>description setter plugin</code>插件。</p>
<h3 id="2-Jenkins-gt-新建。"><a href="#2-Jenkins-gt-新建。" class="headerlink" title="2. Jenkins &gt; 新建。"></a>2. <strong>Jenkins</strong> &gt; <strong>新建</strong>。</h3><p><img src="https://ww2.sinaimg.cn/large/006tNc79ly1ff2iw797sjj318q0vidm6.jpg" alt=""></p>
<h3 id="3-General"><a href="#3-General" class="headerlink" title="3. General."></a>3. <strong>General</strong>.</h3><p><img src="https://ww3.sinaimg.cn/large/006tNc79ly1ff2jedt21qj31kw0u2afo.jpg" alt=""></p>
<p>这里添加了参数化构建过程，为了在每次Build时，可以填写更新说明，所以这里天添加了名为<code>News</code>的参数，当用户构建时填写了内容，可以在之后的脚本中通过<code>${News}</code>来获取<code>News</code>的值。</p>
<p><img src="https://ww1.sinaimg.cn/large/006tNc79ly1ff2jf005ogj31kw0o1q5k.jpg" alt=""></p>
<p>这里指定Mac Slave服务器作为构建Xcode工程的Slave服务器，Xcode打包构建全部交给这个节点（Slave服务器）来完成。</p>
<p><img src="https://ww1.sinaimg.cn/large/006tNc79ly1ff2jfc0bfij31kw0d2jsv.jpg" alt=""></p>
<h3 id="4-源码管理。"><a href="#4-源码管理。" class="headerlink" title="4. 源码管理。"></a>4. 源码管理。</h3><p><img src="https://ww4.sinaimg.cn/large/006tNc79ly1ff2jh0iaijj31jk0uk41x.jpg" alt=""></p>
<p>这里填写本地或者远程的代码仓库（如gitlab或者git）。下面的Branch填写指定分支。</p>
<h3 id="5-构建触发器。"><a href="#5-构建触发器。" class="headerlink" title="5. 构建触发器。"></a>5. 构建触发器。</h3><p>这里暂时不设置，设置了可以自动化测试，和其他脚本配合使用。</p>
<h3 id="6-构建环境。"><a href="#6-构建环境。" class="headerlink" title="6. 构建环境。"></a>6. 构建环境。</h3><p><img src="https://ww1.sinaimg.cn/large/006tNc79ly1ff2jqxdzccj31kw0txq9d.jpg" alt=""></p>
<p><img src="https://ww3.sinaimg.cn/large/006tNc79ly1ff2jssknawj31kw0pnn2s.jpg" alt=""></p>
<p>把之前上传的证书和描述文件添加上。</p>
<p>设置Build名称，这里添加了自定义名称。注意，高级里面只勾选第一个，不要勾选 <code>Set build name after build ends</code>，否则会报错。</p>
<h3 id="7-构建"><a href="#7-构建" class="headerlink" title="7. 构建"></a>7. 构建</h3><p><img src="https://ww2.sinaimg.cn/large/006tNc79ly1ff2jwre537j31kw0pygr0.jpg" alt=""></p>
<p>这里使用的脚本。</p>
<pre><code>export LANG=&quot;en_US.UTF-8&quot;

security -v unlock-keychain -p &quot;yourpassword&quot;

ipa_name=&quot;URWork_iOS_beta&quot;
build_path=&quot;${WORKSPACE}/build/&quot;
fastlane gym --workspace URWorkClient.xcworkspace --scheme URWorkClient --clean --configuration Beta --export_method ad-hoc --output_name ${ipa_name} --output_directory ${build_path}

curl -F &quot;file=@${build_path}${ipa_name}.ipa&quot; \
-F &quot;uKey=yourUKey&quot; \
-F &quot;_api_key=yourApiKey&quot; \
-F &quot;updateDescription=${News}&quot; \
https://www.pgyer.com/apiv1/app/upload
</code></pre><h4 id="最重要、最重要、最重要："><a href="#最重要、最重要、最重要：" class="headerlink" title="最重要、最重要、最重要："></a><strong>最重要、最重要、最重要：</strong></h4><p>Linux服务器上的Jenkins调用Mac Slave时，是通过之前设置的<strong>SSH</strong>登录的方式，而Apple为了安全，在ssh登录时，是不允许读取<strong>Keychains</strong>（钥匙串）的，所以 <code>security -v unlock-keychain -p &quot;yourpassword&quot;</code>这行命令就很重要了。在构建打包前，先解锁Keychains。</p>
<p>当然这里 <strong>fastlane</strong> 已经提前通过<strong>Homebrew</strong>安装好了，这里不再赘述。</p>
<blockquote>
<p><em>整体脚本的流程是，先解锁Keychain，然后用fastlane快速打包，最后上传到蒲公英平台，等待测试。</em></p>
</blockquote>
<h3 id="8-构建后操作。"><a href="#8-构建后操作。" class="headerlink" title="8. 构建后操作。"></a>8. 构建后操作。</h3><p><img src="https://ww2.sinaimg.cn/large/006tNc79ly1ff2k7cb7ptj31kw0ktjue.jpg" alt=""></p>
<p>附代码：</p>
<pre><code>&lt;h3&gt;更新说明:&lt;/h3&gt;&lt;p&gt;${News}&lt;/p&gt;&lt;a href=&quot;http://www.pgyer.com/urwork_ios&quot; style=&quot;display:block;margin:10px 0px;&quot; target=&quot;_blank&quot;&gt;点击跳转到下载页&lt;/a&gt;&lt;/br&gt;&lt;img src=&quot;http://www.pgyer.com/app/qrcode/urwork_ios&quot;&gt;
</code></pre><p>构建完成后，把之前用户输入的<strong>更新说明</strong>以及<strong>蒲公英下载地址</strong>和<strong>二维码</strong>通通显示在Build Description中。</p>
<h2 id="四、整体测试"><a href="#四、整体测试" class="headerlink" title="四、整体测试"></a>四、整体测试</h2><h3 id="1-打开Jenkins。"><a href="#1-打开Jenkins。" class="headerlink" title="1. 打开Jenkins。"></a>1. 打开Jenkins。</h3><p><img src="https://ww1.sinaimg.cn/large/006tNc79ly1ff2kbajk7cj31kw0u6jxm.jpg" alt=""></p>
<h3 id="2-点击develop-iOS。"><a href="#2-点击develop-iOS。" class="headerlink" title="2. 点击develop_iOS。"></a>2. 点击develop_iOS。</h3><p><img src="https://ww1.sinaimg.cn/large/006tNc79ly1ff2kang8dkj31kw0tf7c5.jpg" alt=""></p>
<h3 id="3-点击Build-with-Parameters"><a href="#3-点击Build-with-Parameters" class="headerlink" title="3. 点击Build with Parameters."></a>3. 点击Build with Parameters.</h3><p><img src="https://ww2.sinaimg.cn/large/006tNc79ly1ff2kdk1zdfj31kw0tktds.jpg" alt=""></p>
<h3 id="4-开始构建。"><a href="#4-开始构建。" class="headerlink" title="4. 开始构建。"></a>4. 开始构建。</h3><p><img src="https://ww4.sinaimg.cn/large/006tNc79ly1ff2keezip1j31kw0tf10n.jpg" alt=""></p>
<h3 id="5-等待构建完成即可。"><a href="#5-等待构建完成即可。" class="headerlink" title="5. 等待构建完成即可。"></a>5. 等待构建完成即可。</h3><p>这里也可以查看构建进度：点击最新的一次构建</p>
<p><img src="https://ww3.sinaimg.cn/large/006tNc79ly1ff2kg18untj31kw0s1tdq.jpg" alt=""></p>
<p>点击Console Output<br><img src="https://ww4.sinaimg.cn/large/006tNc79ly1ff2kgpirr9j31kw0sj13w.jpg" alt=""></p>
<p>在这里可以查看一些日志，如果出错了，也可以在这里查询。</p>
<h2 id="五、总结。"><a href="#五、总结。" class="headerlink" title="五、总结。"></a>五、总结。</h2><p>使用Jenkins打包Xcode工程整体过程很曲折，坑很多，按照这些来，可能还会遇到一些问题，附上一些链接，以供参考。</p>
<h2 id="附"><a href="#附" class="headerlink" title="附"></a>附</h2><ul>
<li><a href="http://www.jianshu.com/p/371595ef08fe" target="_blank" rel="external">Jenkins+ Xcode+ 蒲公英 实现IOS自动化打包和分发</a></li>
<li><a href="http://www.jianshu.com/p/41ecb06ae95f" target="_blank" rel="external">手把手教你利用Jenkins持续集成iOS项目</a></li>
<li><a href="http://www.jianshu.com/p/62fa8083b45c" target="_blank" rel="external">Jenkins签名问题</a></li>
<li><a href="https://www.pgyer.com/doc/view/jenkins_ios" target="_blank" rel="external">使用 Jenkins 实现持续集成 (iOS)</a></li>
<li><a href="https://www.pgyer.com/doc/view/jenkins" target="_blank" rel="external">使用 Jenkins 实现持续集成 (Android)</a></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;解决Linux服务器上的Jenkins无法构建Xcode工程&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;由于Linux服务器无法安装Xcode，所以Jenkins无法通
    
    </summary>
    
    
      <category term="iOS技术分享" scheme="http://blog.darkangel7.com/tags/iOS%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>iOS中UIWebView与WKWebView、JavaScript与OC交互、Cookie管理看我就够（上）</title>
    <link href="http://blog.darkangel7.com/2016/09/01/iOS%E4%B8%ADUIWebView%E4%B8%8EWKWebView%E3%80%81JavaScript%E4%B8%8EOC%E4%BA%A4%E4%BA%92%E3%80%81Cookie%E7%AE%A1%E7%90%86%E7%9C%8B%E6%88%91%E5%B0%B1%E5%A4%9F%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>http://blog.darkangel7.com/2016/09/01/iOS中UIWebView与WKWebView、JavaScript与OC交互、Cookie管理看我就够（上）/</id>
    <published>2016-09-01T07:37:29.000Z</published>
    <updated>2017-05-10T12:16:39.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1fff1sa06wrj30sg0iwwi9.jpg" alt=""></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>iOS开发中，用来显示一个html页、H5页，经常会用的一个控件是WebView。说到WebView，你知道多少呢？是简单的展示，还是要和OC交互实现比较复杂的功能呢？本文将为您介绍iOS中的WebView，并且由浅到深，一步步带你了解并掌握WebView的用法，JavaScript与Objective的交互，以及Cookie的管理、js的调试等。</p>
<p>文章因涉及到的内容较多，因此拆分成以下几部分：</p>
<ul>
<li>iOS中UIWebView与WKWebView、JavaScript与OC交互、Cookie管理看我就够（上）</li>
<li><a href="http://blog.darkangel7.com/2017/05/10/iOS中UIWebView与WKWebView、JavaScript与OC交互、Cookie管理看我就够（中）/">iOS中UIWebView与WKWebView、JavaScript与OC交互、Cookie管理看我就够（中）</a></li>
<li><a href="">iOS中UIWebView与WKWebView、JavaScript与OC交互、Cookie管理看我就够（下）</a>（待填坑…）</li>
</ul>
<p>关于文中提到的一些内容，这里我准备了个<a href="https://github.com/DarkAngel7/Demos-WebViewDemo" target="_blank" rel="external">Demo</a>，有需要的小伙伴可以下载。</p>
<h1 id="UIWebView"><a href="#UIWebView" class="headerlink" title="UIWebView"></a>UIWebView</h1><h2 id="UIWebView基本用法"><a href="#UIWebView基本用法" class="headerlink" title="UIWebView基本用法"></a>UIWebView基本用法</h2><p>首先要介绍的就是我们的老朋友<code>UIWebView</code>。相信对大多数小伙伴儿而言，<code>UIWebView</code>和<code>UILabel</code>一样，都是最早接触的控件了，其实<code>UIWebView</code>用法比较简单（功能基本能满足需求），简单的创建，并且调用</p>
<pre><code class="objective-c">- (void)loadRequest:(NSURLRequest *)request;
- (void)loadHTMLString:(NSString *)string baseURL:(nullable NSURL *)baseURL;
- (void)loadData:(NSData *)data MIMEType:(NSString *)MIMEType textEncodingName:(NSString *)textEncodingName baseURL:(NSURL *)baseURL;
</code></pre>
<p>这些方法，加载就可以了。<br>当然，如果需要监听页面加载的结果，或者需要判断是否允许打开某个URL，那需要设置<code>UIWebView</code>的<code>delegate</code>，代理只需要遵循<code>&lt;UIWebViewDelegate&gt;</code>协议，并且在代理中实现下面的这些可选方法就可以：</p>
<pre><code class="objective-c">__TVOS_PROHIBITED @protocol UIWebViewDelegate &lt;NSObject&gt;

@optional
- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType;
- (void)webViewDidStartLoad:(UIWebView *)webView;
- (void)webViewDidFinishLoad:(UIWebView *)webView;
- (void)webView:(UIWebView *)webView didFailLoadWithError:(nullable NSError *)error;

@end
</code></pre>
<h2 id="UIWebView中JavaScript与Objective的交互"><a href="#UIWebView中JavaScript与Objective的交互" class="headerlink" title="UIWebView中JavaScript与Objective的交互"></a>UIWebView中JavaScript与Objective的交互</h2><p>这里不详细讨论一些很好的第三方实现，比如<a href="https://github.com/marcuswestin/WebViewJavascriptBridge" target="_blank" rel="external">WebViewJavascriptBridge</a>，单纯的讲讲native端JS与OC的交互实现方式，读完了下面的部分，相信你也会实现一个简单的<code>bridge</code>了。</p>
<h3 id="UIWebView-OC调用JS"><a href="#UIWebView-OC调用JS" class="headerlink" title="UIWebView OC调用JS"></a>UIWebView OC调用JS</h3><h4 id="1-stringByEvaluatingJavaScriptFromString"><a href="#1-stringByEvaluatingJavaScriptFromString" class="headerlink" title="1. stringByEvaluatingJavaScriptFromString:"></a>1. stringByEvaluatingJavaScriptFromString:</h4><p>最常用的方法，很简单，只要调用<code>- (nullable NSString *)stringByEvaluatingJavaScriptFromString:(NSString *)script;</code>就可以了，如：</p>
<pre><code class="objective-c">    self.navigationItem.title = [webView stringByEvaluatingJavaScriptFromString:@&quot;document.title&quot;];
</code></pre>
<p>虽然比较方便，但是缺点也有：</p>
<ol>
<li>该方法不能判断调用了一个js方法之后，是否发生了错误。当错误发生时，返回值为nil，而当调用一个方法本身没有返回值时，返回值也为nil，所以无法判断是否调用成功了。</li>
<li>返回值类型为<code>nullable NSString *</code>，就意味着当调用的js方法有返回值时，都以字符串返回，不够灵活。当返回值是一个js的Array时，还需要解析字符串，比较麻烦。</li>
</ol>
<p>对于上述缺点，可以通过使用JavaScriptCore（iOS 7.0 +）来解决。</p>
<h4 id="2-JavaScriptCore（iOS-7-0-）"><a href="#2-JavaScriptCore（iOS-7-0-）" class="headerlink" title="2. JavaScriptCore（iOS 7.0 +）"></a>2. JavaScriptCore（iOS 7.0 +）</h4><p>想必大家不会陌生吧，前些日子弄的沸沸扬扬的<code>JSPatch</code>被禁事件中，最核心的就是它了。因为<code>JavaScriptCore</code>的JS到OC的映射，可以替换各种js方法成oc方法，所以其<strong>动态性（配合runtime的不安全性）</strong>也就成为了<code>JSPatch</code>被<strong>Apple</strong>禁掉的最主要原因。这里讲下<code>UIWebView</code>通过<code>JavaScriptCore</code>来实现OC-&gt;JS。</p>
<p>其实WebKit都有一个内嵌的js环境，一般我们在页面加载完成之后，获取js上下文，然后通过<code>JSContext</code>的<code>evaluateScript:</code>方法来获取返回值。因为该方法得到的是一个<code>JSValue</code>对象，所以支持JavaScript的Array、Number、String、对象等数据类型。</p>
<pre><code class="objective-c">- (void)webViewDidFinishLoad:(UIWebView *)webView
{
    //更新标题，这是上面的讲过的方法
    //self.navigationItem.title = [webView stringByEvaluatingJavaScriptFromString:@&quot;document.title&quot;];

    //获取该UIWebView的javascript上下文
    JSContext *jsContext = [self.webView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;];

    //这也是一种获取标题的方法。
    JSValue *value = [self.jsContext evaluateScript:@&quot;document.title&quot;];
    //更新标题
    self.navigationItem.title = value.toString;
}
</code></pre>
<p>该方法解决了<code>stringByEvaluatingJavaScriptFromString:</code>返回值只是<code>NSString</code>的问题。</p>
<p>那么如果我执行了一个不存在的方法，比如</p>
<pre><code class="objective-c">[self.jsContext evaluateScript:@&quot;document.titlexxxx&quot;];
</code></pre>
<p>那么必然会报错，报错了，可以通过<code>@property (copy) void(^exceptionHandler)(JSContext *context, JSValue *exception);</code>，设置该block来获取异常。</p>
<pre><code class="objective-c">//在调用前，设置异常回调
[self.jsContext setExceptionHandler:^(JSContext *context, JSValue *exception){
        NSLog(@&quot;%@&quot;, exception);
}];
//执行方法
JSValue *value = [self.jsContext evaluateScript:@&quot;document.titlexxxx&quot;];
</code></pre>
<p>该方法，也很好的解决了<code>stringByEvaluatingJavaScriptFromString:</code>调用js方法后，出现错误却捕获不到的缺点。</p>
<h3 id="UIWebView-JS调用OC"><a href="#UIWebView-JS调用OC" class="headerlink" title="UIWebView JS调用OC"></a>UIWebView JS调用OC</h3><h4 id="1-Custom-URL-Scheme（拦截URL）"><a href="#1-Custom-URL-Scheme（拦截URL）" class="headerlink" title="1. Custom URL Scheme（拦截URL）"></a>1. Custom URL Scheme（拦截URL）</h4><p>比如<code>darkangel://</code>。方法是在html或者js中，点击某个按钮触发事件时，跳转到自定义URL Scheme构成的链接，而Objective-C中捕获该链接，从中解析必要的参数，实现JS到OC的一次交互。比如页面中一个a标签，链接如下：</p>
<pre><code class="html">&lt;a href=&quot;darkangel://smsLogin?username=12323123&amp;code=892845&quot;&gt;短信验证登录&lt;/a&gt;
</code></pre>
<p>而在Objective-C中，只要遵循了<code>UIWebViewDelegate</code>协议，那么每次打开一个链接之前，都会触发方法</p>
<pre><code class="objective-c">- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType；
</code></pre>
<p>在该方法中，捕获该链接，并且返回NO（<strong>阻止本次跳转</strong>），从而执行对应的OC方法。</p>
<pre><code class="objective-c">- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType
{
    //标准的URL包含scheme、host、port、path、query、fragment等
    NSURL *URL = request.URL;    
    if ([URL.scheme isEqualToString:@&quot;darkangel&quot;]) {
        if ([URL.host isEqualToString:@&quot;smsLogin&quot;]) {
            NSLog(@&quot;短信验证码登录，参数为 %@&quot;, URL.query);
            return NO;
        }
    }
    return YES;
}
</code></pre>
<p>当用户点击<strong>短信验证登录</strong>时，控制台会输出<code>短信验证码登录，参数为 username=12323123&amp;code=892845</code>。参数可以是一个json格式并且URLEncode过的字符串，这样就可以实现复杂参数的传递（比如<a href="https://github.com/marcuswestin/WebViewJavascriptBridge" target="_blank" rel="external">WebViewJavascriptBridge</a>）。</p>
<p><strong>优点</strong>：泛用性强，可以配合h5实现页面动态化。比如页面中一个活动链接到活动详情页，当native尚未开发完毕时，链接可以是一个h5链接，等到native开发完毕时，可以通过该方法跳转到native页面，实现页面动态化。且该方案适用于Android和iOS，泛用性很强。</p>
<p><strong>缺点</strong>：无法直接获取本次交互的返回值，比较适合单向传参，且不关心回调的情景，比如h5页面跳转到native页面等。</p>
<p>其实，<a href="https://github.com/marcuswestin/WebViewJavascriptBridge" target="_blank" rel="external">WebViewJavascriptBridge</a>使用的方案就是<strong>拦截URL</strong>，为了解决无法直接获取返回值的缺点，它采用了将一个名为<code>callback</code>的<code>function</code>作为参数，通过一些封装，传递到OC（<strong>js-&gt;oc</strong> 传递参数和callbackId），然后在OC端执行完毕，再通过<code>block</code>来回调callback（<strong>oc-&gt;js</strong>，传递返回值参数），实现异步获取返回值，比如在js端调用</p>
<pre><code class="javascript">//JS调用OC的分享方法（当然需要OC提前注册）share为方法名，shareData为参数，后面的为回调function
WebViewJavascriptBridge.callHandler(&#39;share&#39;, shareData, function(response) {
   //OC端通过block回调分享成功或者失败的结果
   alert(response);   
});
</code></pre>
<p>具体的可以看下它的源码，还是很值得学习的。</p>
<h4 id="2-JavaScriptCore（iOS-7-0-）-1"><a href="#2-JavaScriptCore（iOS-7-0-）-1" class="headerlink" title="2. JavaScriptCore（iOS 7.0 +）"></a>2. JavaScriptCore（iOS 7.0 +）</h4><p>除了<strong>拦截URL</strong>的方法，还可以利用上面提到的<code>JavaScriptCore</code>。它十分强大，强大在哪里呢？下面我们来一探究竟。</p>
<p>当然，还是需要在页面加载完成时，先获取js上下文。获取到之后，我们就可以进行强大的方法映射了。</p>
<p>比如js中我定义了一个分享的方法</p>
<pre><code class="javascript">function share(title, imgUrl, link) {
     //这里需要OC实现
}
</code></pre>
<p>在OC中实现如下</p>
<pre><code class="objective-c">- (void)webViewDidFinishLoad:(UIWebView *)webView
{
    //将js的function映射到OC的方法
    [self convertJSFunctionsToOCMethods];
}

- (void)convertJSFunctionsToOCMethods
{
    //获取该UIWebview的javascript上下文
    //self持有jsContext
    //@property (nonatomic, strong) JSContext *jsContext;
    self.jsContext = [self.webView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;];

    //js调用oc
    //其中share就是js的方法名称，赋给是一个block 里面是oc代码
    //此方法最终将打印出所有接收到的参数，js参数是不固定的
    self.jsContext[@&quot;share&quot;] = ^() {
        NSArray *args = [JSContext currentArguments];//获取到share里的所有参数
        //args中的元素是JSValue，需要转成OC的对象
        NSMutableArray *messages = [NSMutableArray array];
        for (JSValue *obj in args) {
            [messages addObject:[obj toObject]];
        }
        NSLog(@&quot;点击分享js传回的参数：\n%@&quot;, messages);
    };
}
</code></pre>
<p>在html或者js的某处，点击a标签调用这个share方法，并传参，如</p>
<pre><code class="html">&lt;a href=&quot;javascript:void(0);&quot; class=&quot;sharebtn&quot; onClick=&quot;share(&#39;分享标题&#39;, &#39;http://cc.cocimg.com/api/uploads/170425/b2d6e7ea5b3172e6c39120b7bfd662fb.jpg&#39;, location.href)&quot;&gt;分享活动，领30元红包&lt;/a&gt;
</code></pre>
<p>此时，如果用户点击了<strong><u>分享活动，领30元红包</u></strong>这个标签，那么在控制台会打印出所有参数<img src="http://ww2.sinaimg.cn/large/006tNc79ly1fff18hle74j31ak0hiah2.jpg" alt=""></p>
<p>上面的代码实现了OC方法替换JS实现。它十分灵活，主要依赖这些Api。</p>
<pre><code class="objective-c">@interface JSContext (SubscriptSupport)
/*!
@method
@abstract Get a particular property on the global object.
@result The JSValue for the global object&#39;s property.
*/
- (JSValue *)objectForKeyedSubscript:(id)key;
/*!
@method
@abstract Set a particular property on the global object.
*/
- (void)setObject:(id)object forKeyedSubscript:(NSObject &lt;NSCopying&gt; *)key;
</code></pre>
<p><code>self.jsContext[@&quot;yourMethodName&quot;] = your block;</code>这样写不仅可以在有<code>yourMethodName</code>方法时替换该JS方法为OC实现，还会在g该方法没有时，添加方法。简而言之，<strong>有则替换，无则添加</strong>。</p>
<p>那如果我想写一个有两个参数，一个返回值的js方法，oc应该怎么替换呢？</p>
<p>js中</p>
<pre><code class="javascript">//该方法传入两个整数，求和，并返回结果
function testAddMethod(a, b) {
     //需要OC实现a+b，并返回
      return a + b;
}
//js调用
console.log(testAddMethod(1, 5));    //output  6
</code></pre>
<p>oc直接替换该方法</p>
<pre><code class="objective-c">self.jsContext[@&quot;testAddMethod&quot;] = ^NSInteger(NSInteger a, NSInteger b) {
      return a + b;
};
</code></pre>
<p>那么当在js调用</p>
<pre><code class="javascript">//js调用
console.log(testAddMethod(1, 5));    //output  6， 方法为 a + b
</code></pre>
<p>如果oc替换该方法为两数相乘</p>
<pre><code class="objective-c">self.jsContext[@&quot;testAddMethod&quot;] = ^NSInteger(NSInteger a, NSInteger b) {
      return a * b;
};
</code></pre>
<p>再次调用js</p>
<pre><code class="javascript">console.log(testAddMethod(1, 5));    //output  5，该方法变为了 a * b。
</code></pre>
<p>举一反三，调用方法原实现，并且在原结果上乘以10。</p>
<pre><code class="objective-c">//调用方法的本来实现，给原结果乘以10
JSValue *value = self.jsContext[@&quot;testAddMethod&quot;];
self.jsContext[@&quot;testAddMethod&quot;] = ^NSInteger(NSInteger a, NSInteger b) {
    JSValue *resultValue = [value callWithArguments:[JSContext currentArguments]];
    return resultValue.toInt32 * 10;
};
</code></pre>
<p>再次调用js</p>
<pre><code class="javascript">console.log(testAddMethod(1, 5));    //output  60，该方法变为了(a + b) * 10
</code></pre>
<p>上面的方法，都是同步函数，如果我想实现JS调用OC的方法，并且异步接收回调，那么该怎么做呢？比如h5中有一个分享按钮，用户点击之后，调用native分享（微信分享、微博分享等），在native分享成功或者失败时，回调h5页面，告诉其分享结果，h5页面刷新对应的UI，显示分享成功或者失败。</p>
<p>这个问题，需要对js有一定了解。下面上js代码。</p>
<pre><code class="javascript">//声明
function share(shareData) {
    var title = shareData.title;
    var imgUrl = shareData.imgUrl;
    var link = shareData.link;
    var result = shareData.result;
      //do something
    //这里模拟异步操作
    setTimeout(function(){
          //2s之后，回调true分享成功
       result(true);
    }, 2000);
}

//调用的时候需要这么写
share({
      title: &quot;title&quot;, 
     imgUrl: &quot;http://img.dd.com/xxx.png&quot;, 
     link: location.href, 
     result: function(res) {    //函数作为参数
         console.log(res ? &quot;success&quot; : &quot;failure&quot;);
    }
});
</code></pre>
<p>从封装的角度上讲，js的<code>share</code>方法的参数是一个<code>对象</code>，该对象包含了几个必要的字段，以及一个回调函数，这个回调函数有点像oc的<code>block</code>，<strong>调用者</strong>把一个<code>function</code>传入一个<code>function</code>当作参数，在适当时候，方法内<strong>实现者</strong>调用该<code>function</code>，实现对<strong>调用者</strong>的异步回调。那么如果此时OC来实现<code>share</code>方法，该怎么做呢？其实大概是这样的：</p>
<pre><code class="objective-c">//异步回调
self.jsContext[@&quot;share&quot;] = ^(JSValue *shareData) {    //首先这里要注意，回调的参数不能直接写NSDictionary类型，为何呢？
    //仔细看，打印出的确实是一个NSDictionary，但是result字段对应的不是block而是一个NSDictionary  
      NSLog(@&quot;%@&quot;, [shareData toObject]);     
    //获取shareData对象的result属性，这个JSValue对应的其实是一个javascript的function。
    JSValue *resultFunction = [shareData valueForProperty:@&quot;result&quot;];
    //回调block，将js的function转换为OC的block
    void (^result)(BOOL) = ^(BOOL isSuccess) {
        [resultFunction callWithArguments:@[@(isSuccess)]];
    };
    //模拟异步回调
    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
        NSLog(@&quot;回调分享成功&quot;);
        result(YES);
    });
};
</code></pre>
<p>其中一些坑，已经在代码的注释写的比较清楚了，这里要注意<code>JavaScript</code>的<code>function</code>和<code>Objective-C</code>的<code>block</code>的转换。</p>
<p>从上面的一些探讨和尝试来看，足以证明<code>JavaScriptCore</code>的强大，这里不再展开，小伙伴们可以自行探索。</p>
<h2 id="UIWebView的Cookie管理"><a href="#UIWebView的Cookie管理" class="headerlink" title="UIWebView的Cookie管理"></a>UIWebView的Cookie管理</h2><h3 id="Cookie简介"><a href="#Cookie简介" class="headerlink" title="Cookie简介"></a>Cookie简介</h3><p>说到<code>Cookie</code>，或许有些小伙伴会比较陌生，有些小伙伴会比较熟悉。如果项目中，所有页面都是纯原生来实现的话，一般<code>Cookie</code>这个东西或许我们永远也不会接触到。但是，这里还是要说一下<code>Cookie</code>，因为它真的很重要，由它产生的一些坑也很多。</p>
<p><code>Cookie</code>在Web利用的最多的地方，是用来记录各种状态。比如你在<code>Safari</code>中打开百度，然后登陆自己的账号，之后打开所有百度相关的页面，都会是登陆状态，而且当你关了电脑，下次开机再次打开<code>Safari</code>打开百度，会发现还是登陆状态，其实这个就利用了<code>Cookie</code>。<code>Cookie</code>中记录了你百度账号的一些信息、有效期等，也维持了跨域请求时登录状态的统计性。<img src="http://ww3.sinaimg.cn/large/006tNc79ly1fff5jbzd4cj31kw0jk11w.jpg" alt="">可以看到<code>Cookie</code>的域各不相同，有效期也各不相同，一般<code>.baidu.com</code>这样的域的<code>Cookie</code>就是为了跨域时，可以维持一些状态。</p>
<p>那么在App中，Cookie最常用的就是维持登录状态了。一般Native端都有自己的一套完整登录注册逻辑，一般大部分页面都是原生实现的。当然，也会有一些页面是h5来实现的，虽然h5页面在App中通过<code>WebView</code>加载或多或少都会有点性能问题，感觉不流畅或者体验不好，但是它的灵活性是Native App无法比拟的。那么由此，便产生了一种需求，当Native端用户是登录状态的，打开一个h5页面，h5也要维持用户的登录状态。</p>
<p>这个需求看似简单，如何实现呢？一般的解决方案是Native保存登录状态的Cookie，在打开h5页面中，把Cookie添加上，以此来维持登录状态。其实坑还是有很多的，比如用户登录或者退出了，h5页面的登录状态也变了，需要刷新，什么时候刷新？<code>WKWebView</code>中<code>Cookie</code>丢失问题？这里简单说下<code>UIWebView</code>的<code>Cookie</code>管理，后面的章节再介绍<code>WKWebView</code>。</p>
<h3 id="Cookie管理"><a href="#Cookie管理" class="headerlink" title="Cookie管理"></a>Cookie管理</h3><p><code>UIWebView</code>的<code>Cookie</code>管理很简单，一般不需要我们手动操作<code>Cookie</code>，因为所有<code>Cookie</code>都会被<code>[NSHTTPCookieStorage sharedHTTPCookieStorage]</code>这个单例管理，而且<code>UIWebView</code>会自动同步<code>CookieStorage</code>中的Cookie，所以只要我们在Native端，正常登陆退出，h5在适当时候刷新，就可以正确的维持登录状态，不需要做多余的操作。</p>
<p>可能有一些情况下，我们需要在访问某个链接时，添加一个固定<code>Cookie</code>用来做区分，那么就可以通过<code>header</code>来实现</p>
<pre><code class="objective-c">NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@&quot;http://www.baidu.com&quot;]];
[request addValue:@&quot;customCookieName=1314521;&quot; forHTTPHeaderField:@&quot;Set-Cookie&quot;];
[self.webView loadRequest:request];
</code></pre>
<p>也可以主动操作<code>NSHTTPCookieStorage</code>，添加一个自定义<code>Cookie</code></p>
<pre><code class="objective-c">NSHTTPCookie *cookie = [NSHTTPCookie cookieWithProperties:@{
    NSHTTPCookieName: @&quot;customCookieName&quot;, 
    NSHTTPCookieValue: @&quot;1314521&quot;, 
    NSHTTPCookieDomain: @&quot;.baidu.com&quot;,
    NSHTTPCookiePath: @&quot;/&quot;
}];
[[NSHTTPCookieStorage sharedHTTPCookieStorage] setCookie:cookie];    //Cookie存在则覆盖，不存在添加
</code></pre>
<p>还有一些常用的方法，如读取所有<code>Cookie</code></p>
<pre><code class="objective-c">NSArray *cookies = [NSHTTPCookieStorage sharedHTTPCookieStorage].cookies;
</code></pre>
<p><code>Cookie</code>转换成<code>HTTPHeaderFields</code>，并添加到<code>request</code>的<code>header</code>中</p>
<pre><code class="objective-c">//Cookies数组转换为requestHeaderFields
NSDictionary *requestHeaderFields = [NSHTTPCookie requestHeaderFieldsWithCookies:cookies];
//设置请求头
request.allHTTPHeaderFields = requestHeaderFields;
</code></pre>
<p>整体来说<code>UIWebView</code>的<code>Cookie</code>管理比较简单，小伙伴们可以自己写个demo测试一下，发挥你们的想象。</p>
<h1 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h1><p>关于<code>UIWebView</code>的介绍，以及使用<code>UIWebView</code>进行JS与OC的交互，<code>Cookie</code>的管理，就先简单介绍到这里。如果有小伙伴对于<a href="https://github.com/marcuswestin/WebViewJavascriptBridge" target="_blank" rel="external">WebViewJavascriptBridge</a>比较感兴趣，可以留言，根据留言我考虑一下写一篇文章，分析它的详细实现。</p>
<p>另外，后续将为您介绍<code>WKWebView</code>的用法，一些OC与JS交互，Cookie管理、如何在<code>Safari</code>中调试以及一些不为人知的坑等，敬请期待~</p>
<p>下篇文章已发布：<a href="http://blog.darkangel7.com/2017/05/10/iOS中UIWebView与WKWebView、JavaScript与OC交互、Cookie管理看我就够（中）/">iOS中UIWebView与WKWebView、JavaScript与OC交互、Cookie管理看我就够（中）</a>。</p>
<p>To be continued…</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ww4.sinaimg.cn/large/006tNc79ly1fff1sa06wrj30sg0iwwi9.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; titl
    
    </summary>
    
    
      <category term="iOS技术分享" scheme="http://blog.darkangel7.com/tags/iOS%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>Hexo+Github的Blog搭建</title>
    <link href="http://blog.darkangel7.com/2016/08/19/Hexo+Github%E7%9A%84Blog%E6%90%AD%E5%BB%BA/"/>
    <id>http://blog.darkangel7.com/2016/08/19/Hexo+Github的Blog搭建/</id>
    <published>2016-08-19T04:40:16.000Z</published>
    <updated>2017-05-08T02:38:09.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装："><a href="#安装：" class="headerlink" title="安装："></a>安装：</h1><h2 id="一、安装Homebrew"><a href="#一、安装Homebrew" class="headerlink" title="一、安装Homebrew"></a>一、安装Homebrew</h2><p>Mac上已经安装了ruby环境，只需要输入</p>
<pre><code>ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;
</code></pre><h2 id="二、安装node-js"><a href="#二、安装node-js" class="headerlink" title="二、安装node.js"></a>二、安装node.js</h2><pre><code>sudo brew install node
</code></pre><h2 id="三、安装Hexo"><a href="#三、安装Hexo" class="headerlink" title="三、安装Hexo"></a>三、安装Hexo</h2><p>Hexo是基于node.js的博客系统，这里安装就可以了。</p>
<pre><code>sudo npm install -g hexo 
npm install hexo-renderer-ejs --save
npm install hexo-renderer-stylus --save
npm install hexo-renderer-marked --save
</code></pre><p>安装完成后，找一个放blog的目录</p>
<pre><code>cd ~/Blog
</code></pre><p>然后执行初始化</p>
<pre><code>hexo init
</code></pre><p>然后可以直接预览hello word.md</p>
<pre><code>hexo g
hexo s
=&gt; [info] Hexo is running at localhost:4000/. Press Ctrl+C to stop.
</code></pre><p>g是generate, s是server，还有d是deploy（部署）推荐用首字母，方便快捷。</p>
<h2 id="四、创建Blog-Repository"><a href="#四、创建Blog-Repository" class="headerlink" title="四、创建Blog Repository"></a>四、创建Blog Repository</h2><p>在自己的Github创建Blog的仓库，如Blog-Hexo，命名无所谓。记住勾选README。</p>
<p><img src="http://ww4.sinaimg.cn/large/65e4f1e6jw1f72qarsjd9j20va0aydh0.jpg" alt="repository1"></p>
<p><img src="http://ww2.sinaimg.cn/large/65e4f1e6jw1f72qbhppqfj214a0sqq6q.jpg" alt="repository2"><br>创建完毕，直接进行到下一步。</p>
<h2 id="五、购买域名"><a href="#五、购买域名" class="headerlink" title="五、购买域名"></a>五、购买域名</h2><p>推荐在万网购买，国外的Godaddy也可以。以万网为例：<br>买好域名实名认证了之后，到<code>控制台</code> - <code>云解析DNS</code>中添加一个解析，如：</p>
<p><img src="http://ww4.sinaimg.cn/large/65e4f1e6jw1f72qblgcswj21kw01qglt.jpg" alt=""></p>
<p>CNAME映射到自己的xxx.github.io。这里的xxx是你的在github的名称，我的是<code>DarkAngel7</code>。<br>在终端中输入</p>
<pre><code>dig blog.darkangel7.com +nostats +nocomments +nocmd
</code></pre><p>如果出现下面的结果，证明解析成功。</p>
<pre><code>DarkAngel-MacBook-Pro-2:Blog DarkAngel$ dig blog.darkangel7.com +nostats +nocomments +nocmd

; &lt;&lt;&gt;&gt; DiG 9.8.3-P1 &lt;&lt;&gt;&gt; blog.darkangel7.com +nostats +nocomments +nocmd
;; global options: +cmd
;blog.darkangel7.com.        IN    A
blog.darkangel7.com.    30    IN    CNAME    darkangel7.github.io.
darkangel7.github.io.    2516    IN    CNAME    github.map.fastly.net.
github.map.fastly.net.    30    IN    CNAME    prod.github.map.fastlylb.net.
prod.github.map.fastlylb.net. 30 IN    A    151.101.100.133
</code></pre><h2 id="六、Deploy"><a href="#六、Deploy" class="headerlink" title="六、Deploy"></a>六、Deploy</h2><p>上一步完成域名到github pages的单向映射。本步完成github到域名的映射，完成输入域名解析到对应的内容。</p>
<p>首先在Blog/source里创建CNAME</p>
<pre><code>cd source
touch CNAME
vi CNAME
</code></pre><p>输入你在上一步CNAME的域名，建立映射关系。</p>
<pre><code>blog.darkangel7.com
</code></pre><p>修改<code>_config.yml</code>文件，配置一些东西。</p>
<pre><code># Deployment
## Docs: https://hexo.io/docs/deployment.html
deploy:
      type: git
      repository: git@github.com:DarkAngel7/Blog-Hexo.git
</code></pre><p>安装git插件</p>
<pre><code>npm install hexo-deployer-git --save
</code></pre><p>这里repository的地址可以是https的，也可以是git的，只不过git需要SSH证书，一般用https就可以了，如果出现443错误，替换成git。</p>
<p>然后在Blog目录下</p>
<pre><code>hexo g -d
</code></pre><p>生成静态文件并且部署出去，不出意外，已经可以外网访问了。</p>
<h1 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h1><h2 id="一、访问速度"><a href="#一、访问速度" class="headerlink" title="一、访问速度"></a>一、访问速度</h2><p>由于Google被墙，大部分主题中引用的jquery都会因为超时（可以Blog目录下搜索google），而造成页面访问很慢，这里需要将jquery改为百度的<br>​    </p>
<pre><code>&lt;script src=&quot;//apps.bdimg.com/libs/jquery/2.0.3/jquery.min.js&quot;&gt;&lt;/script&gt;
</code></pre><h2 id="二、RSS订阅"><a href="#二、RSS订阅" class="headerlink" title="二、RSS订阅"></a>二、RSS订阅</h2><p>输入命令</p>
<pre><code>$ npm install hexo-generator-feed --save
</code></pre><p>然后在_config.yml中，添加<br>​    </p>
<pre><code>rss: /atom.xml
feed:
     type: atom
    path: atom.xml
     limit: 20
</code></pre><h2 id="三、搜索支持"><a href="#三、搜索支持" class="headerlink" title="三、搜索支持"></a>三、搜索支持</h2><p>现在在百度和Google是搜不到你的网站的，为了让搜索引擎搜索到，需要做一些工作。</p>
<p>搜索引擎入口</p>
<ul>
<li><a href="https://www.google.com/webmasters/tools/home?hl=zh-CN" target="_blank" rel="external">Google搜索引擎提交入口</a></li>
<li><a href="http://www.baidu.com/search/url_submit.htm" target="_blank" rel="external">百度搜索引擎入口</a></li>
</ul>
<p>添加sitemap.xml：</p>
<p>首先输入：</p>
<pre><code>npm install hexo-generator-sitemap --save
npm install hexo-generator-baidu-sitemap --save    
npm install hexo-baidu-url-submit --save
</code></pre><p>前两个插件用于生成sitemap，后一个插件用于主动推送链接到百度（<strong>防止百度爬虫抓取失败，导致百度搜不到您的博客</strong>，这里有一篇<a href="http://guochenglai.com/2016/09/26/baidu-crow-github-page/" target="_blank" rel="external">关于百度无法爬取Github Pages静态网站解决方案</a>）。</p>
<p>然后在<code>_config.yml</code>文件中添加</p>
<pre><code>sitemap:
         path: sitemap.xml
baidusitemap:
         path: baidusitemap.xml

## BaiduUrlSubmit: http://hui-wang.info/2016/10/23/Hexo插件之百度主动提交链接/    
baidu_url_submit:        ##主动推送新文章到百度
  count: 3 ## 比如3，代表提交最新的三个链接
  host: blog.darkangel7.com ## 在百度站长平台中注册的域名
  token: your_token ## 请注意这是您的秘钥， 请不要发布在公众仓库里!
  path: baidu_urls.txt ## 文本文档的地址， 新链接会保存在此文本文档里

##同时要检查这里有没有URL值，必须包含是百度站长平台注册的域名，比如 
# URL
url: http://blog.darkangel7.com
root: /
permalink: :year/:month/:day/:title/

##最后，加入新的deployer，如
deploy:
- type: git
  repository: git@github.com:DarkAngel7/Blog-Hexo.git
- type: baidu_url_submitter  ## 百度链接主动推送
</code></pre><p>先验证网站所有权，下载html，mv到Blog/themes/yourtheme/source目录下，执行</p>
<pre><code>hexo g -d
</code></pre><p>验证成功后，添加百度自动推送脚本，最好在<code>head.ejs</code>中添加百度自动推送的代码，至于<code>head.ejs</code>文件位置，在你使用的theme文件夹下搜索吧。<br>谷歌的话，在<code>抓取</code>-<code>站点地图</code>里面添加就好。</p>
<p>这样主动推送与自动推送结合，能很好的提高您文章的曝光率。    </p>
<h2 id="四、评论功能"><a href="#四、评论功能" class="headerlink" title="四、评论功能"></a>四、评论功能</h2><p>可以使用<a href="http://duoshuo.com" target="_blank" rel="external">多说</a>来提供评论功能。首先，在<code>_config.yml</code>文件中添加</p>
<pre><code># Duoshuo
duoshuo_shortname: yoursite.doushuo.com
</code></pre><p>  然后，搜索themes文件夹下，你使用的theme文件目录下的<code>commemt.ejs</code>（不同的theme可能位置不同，请自行寻找）。修改如下：</p>
<pre><code> &lt;div id=&quot;comment&quot; class=&quot;comments-area&quot;&gt;
     &lt;% if(config.duoshuo_shortname) { %&gt;
     &lt;! -- 多说的代码 --&gt; 
     &lt;% } %&gt; 
&lt;/div&gt;    

 如果报关于data-thread-key的错误，则改成下面这样：
 &lt;div class=&quot;ds-thread&quot; data-thread-key=&quot;&lt;%= page.path %&gt;&quot; data-title=&quot;&lt;%= page.title %&gt;&quot; data-url=&quot;&lt;%= page.permalink %&gt;&quot;&gt;&lt;/div    &gt;
</code></pre><h2 id="五、分享功能"><a href="#五、分享功能" class="headerlink" title="五、分享功能"></a>五、分享功能</h2><p>可以在Blog目录下搜索<code>post/share</code>，一般在<code>article.ejs</code>文件中，或者<code>post.ejs</code>文件中，然后替换</p>
<pre><code>&lt;%- partial(&#39;post/author&#39;) %&gt;
</code></pre><p>为<a href="http://share.baidu.com/code" target="_blank" rel="external">百度分享</a>提供的代码。</p>
<h2 id="六、个人信息完善"><a href="#六、个人信息完善" class="headerlink" title="六、个人信息完善"></a>六、个人信息完善</h2><p>网站的信息一般都在<code>Blog/_config.yml</code>中修改。</p>
<p>关于Theme，去官方提供的<a href="https://github.com/tommy351/hexo/wiki/Themes" target="_blank" rel="external">主题列表</a>中选个现成的，按照里面的方法pull下来，如light主题</p>
<pre><code>$ git clone git://github.com/tommy351/hexo-theme-light.git themes/light
</code></pre><p>然后在<code>_config.yml</code>配置文件中设置：</p>
<pre><code>theme: light
</code></pre><p>关于主题的优化，一般在<code>themes/yourtheme/_config.yml</code>中配置。</p>
<h1 id="写文章"><a href="#写文章" class="headerlink" title="写文章"></a>写文章</h1><p>在Blog目录下，创建</p>
<pre><code>hexo new 文章题目
</code></pre><p>然后用Markdown编写，写好后save。</p>
<pre><code>hexo g
hexo s
</code></pre><p>生成，然后在本地localhost:4000预览一下，如果没有问题，就可以发布了。</p>
<pre><code>hexo d
</code></pre><p>所有的文章都是放在<code>Blog/source/_posts/</code>目录下的，可以随时编辑修改。</p>
<h1 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h1><p>还有一些其他的修改，这里就不一一提了，等待你慢慢发现。现在快开始写作吧~~</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;安装：&quot;&gt;&lt;a href=&quot;#安装：&quot; class=&quot;headerlink&quot; title=&quot;安装：&quot;&gt;&lt;/a&gt;安装：&lt;/h1&gt;&lt;h2 id=&quot;一、安装Homebrew&quot;&gt;&lt;a href=&quot;#一、安装Homebrew&quot; class=&quot;headerlink&quot; titl
    
    </summary>
    
    
  </entry>
  
</feed>
