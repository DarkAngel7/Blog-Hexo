<!DOCTYPE html>
<html>

<head>
  <meta http-equiv="Content-Type" content="text/html" charset="UTF-8" >
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
  <title>iOS中UIWebView与WKWebView、JavaScript与OC交互、Cookie管理看我就够（上） | Dark Angel</title>
  <meta name="description" content="" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="MobileOptimized" content="320" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" /> 
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico" />
  <link rel="stylesheet" type="text/css" href="/css/screen.css" />
  <link rel="stylesheet" type="text/css" href="/css/style.css" />
  <link rel="stylesheet" href="//cdn.bootcss.com/highlight.js/8.5/styles/github.min.css">
  <meta name="generator" content="Dark Angel">

  
  <link rel="alternate" type="application/rss+xml" title="RSS" href="/atom.xml">
  
  
  <link rel="alternate" type="application/atom+xml" title="Atom 0.3" href="atom.xml">
  
  

  
</head>

<!--
<body class="post-template">
-->
<body class="home-template">
<div id="perspective" class="perspective effect-movedown">
  <div class="container">
    <!-- wrapper -->
    <div class="wrapper">

      <header class="site-head"  style="background: #24282b url(/img/img-bg.jpg) center; background-size: cover" >
    <div class="vertical">
        <div class="site-head-content inner">
             <a class="blog-logo" href="/"><img src="/img/avatar.jpg" alt="Blog Logo"/></a> 
            <h1 class="blog-title">Dark Angel</h1>
            <h2 class="blog-description"><button id="showMenu">Show Menu</button></h2>
        </div>
    </div>
</header>

      

<main class="content" role="main">
  <article class="post">
    <span class="post-meta">
      <time datetime="2016-09-01T07:37:29.000Z" itemprop="datePublished">
          2016-09-01
      </time>
    
    
    | 
    <a href='/tags/iOS技术分享/'>iOS技术分享</a>
    
    
</span>
    <h1 class="post-title">iOS中UIWebView与WKWebView、JavaScript与OC交互、Cookie管理看我就够（上）</h1>
    <span id="busuanzi_value_page_pv"></span>次阅读
    <span class="ds-thread-count" data-thread-key="2016/09/01/iOS中UIWebView与WKWebView、JavaScript与OC交互、Cookie管理看我就够（上）/"></span>
    <section class="post-content">
     	
              <div id="toc" class="toc-article">
                <strong class="toc-title">本文目录</strong>
                <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#前言"><span class="toc-text">前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#UIWebView"><span class="toc-text">UIWebView</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#UIWebView基本用法"><span class="toc-text">UIWebView基本用法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UIWebView中JavaScript与Objective的交互"><span class="toc-text">UIWebView中JavaScript与Objective的交互</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#UIWebView-OC调用JS"><span class="toc-text">UIWebView OC调用JS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-stringByEvaluatingJavaScriptFromString"><span class="toc-text">1. stringByEvaluatingJavaScriptFromString:</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-JavaScriptCore（iOS-7-0-）"><span class="toc-text">2. JavaScriptCore（iOS 7.0 +）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UIWebView-JS调用OC"><span class="toc-text">UIWebView JS调用OC</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-Custom-URL-Scheme（拦截URL）"><span class="toc-text">1. Custom URL Scheme（拦截URL）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-JavaScriptCore（iOS-7-0-）-1"><span class="toc-text">2. JavaScriptCore（iOS 7.0 +）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UIWebView的Cookie管理"><span class="toc-text">UIWebView的Cookie管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Cookie简介"><span class="toc-text">Cookie简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cookie管理"><span class="toc-text">Cookie管理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#未完待续"><span class="toc-text">未完待续</span></a></li></ol>
              </div>
            
	 <p><img src="http://ww4.sinaimg.cn/large/006tNc79ly1fff1sa06wrj30sg0iwwi9.jpg" alt=""></p>
<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>iOS开发中，用来显示一个html页、H5页，经常会用的一个控件是WebView。说到WebView，你知道多少呢？是简单的展示，还是要和OC交互实现比较复杂的功能呢？本文将为您介绍iOS中的WebView，并且由浅到深，一步步带你了解并掌握WebView的用法，JavaScript与Objective的交互，以及Cookie的管理、js的调试等。</p>
<p>文章因涉及到的内容较多，因此拆分成以下几部分：</p>
<ul>
<li>iOS中UIWebView与WKWebView、JavaScript与OC交互、Cookie管理看我就够（上）</li>
<li><a href="http://blog.darkangel7.com/2017/05/10/iOS中UIWebView与WKWebView、JavaScript与OC交互、Cookie管理看我就够（中）/">iOS中UIWebView与WKWebView、JavaScript与OC交互、Cookie管理看我就够（中）</a></li>
<li><a href="">iOS中UIWebView与WKWebView、JavaScript与OC交互、Cookie管理看我就够（下）</a>（待填坑…）</li>
</ul>
<p>关于文中提到的一些内容，这里我准备了个<a href="https://github.com/DarkAngel7/Demos-WebViewDemo" target="_blank" rel="external">Demo</a>，有需要的小伙伴可以下载。</p>
<h1 id="UIWebView"><a href="#UIWebView" class="headerlink" title="UIWebView"></a>UIWebView</h1><h2 id="UIWebView基本用法"><a href="#UIWebView基本用法" class="headerlink" title="UIWebView基本用法"></a>UIWebView基本用法</h2><p>首先要介绍的就是我们的老朋友<code>UIWebView</code>。相信对大多数小伙伴儿而言，<code>UIWebView</code>和<code>UILabel</code>一样，都是最早接触的控件了，其实<code>UIWebView</code>用法比较简单（功能基本能满足需求），简单的创建，并且调用</p>
<pre><code class="objective-c">- (void)loadRequest:(NSURLRequest *)request;
- (void)loadHTMLString:(NSString *)string baseURL:(nullable NSURL *)baseURL;
- (void)loadData:(NSData *)data MIMEType:(NSString *)MIMEType textEncodingName:(NSString *)textEncodingName baseURL:(NSURL *)baseURL;
</code></pre>
<p>这些方法，加载就可以了。<br>当然，如果需要监听页面加载的结果，或者需要判断是否允许打开某个URL，那需要设置<code>UIWebView</code>的<code>delegate</code>，代理只需要遵循<code>&lt;UIWebViewDelegate&gt;</code>协议，并且在代理中实现下面的这些可选方法就可以：</p>
<pre><code class="objective-c">__TVOS_PROHIBITED @protocol UIWebViewDelegate &lt;NSObject&gt;

@optional
- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType;
- (void)webViewDidStartLoad:(UIWebView *)webView;
- (void)webViewDidFinishLoad:(UIWebView *)webView;
- (void)webView:(UIWebView *)webView didFailLoadWithError:(nullable NSError *)error;

@end
</code></pre>
<h2 id="UIWebView中JavaScript与Objective的交互"><a href="#UIWebView中JavaScript与Objective的交互" class="headerlink" title="UIWebView中JavaScript与Objective的交互"></a>UIWebView中JavaScript与Objective的交互</h2><p>这里不详细讨论一些很好的第三方实现，比如<a href="https://github.com/marcuswestin/WebViewJavascriptBridge" target="_blank" rel="external">WebViewJavascriptBridge</a>，单纯的讲讲native端JS与OC的交互实现方式，读完了下面的部分，相信你也会实现一个简单的<code>bridge</code>了。</p>
<h3 id="UIWebView-OC调用JS"><a href="#UIWebView-OC调用JS" class="headerlink" title="UIWebView OC调用JS"></a>UIWebView OC调用JS</h3><h4 id="1-stringByEvaluatingJavaScriptFromString"><a href="#1-stringByEvaluatingJavaScriptFromString" class="headerlink" title="1. stringByEvaluatingJavaScriptFromString:"></a>1. stringByEvaluatingJavaScriptFromString:</h4><p>最常用的方法，很简单，只要调用<code>- (nullable NSString *)stringByEvaluatingJavaScriptFromString:(NSString *)script;</code>就可以了，如：</p>
<pre><code class="objective-c">    self.navigationItem.title = [webView stringByEvaluatingJavaScriptFromString:@&quot;document.title&quot;];
</code></pre>
<p>虽然比较方便，但是缺点也有：</p>
<ol>
<li>该方法不能判断调用了一个js方法之后，是否发生了错误。当错误发生时，返回值为nil，而当调用一个方法本身没有返回值时，返回值也为nil，所以无法判断是否调用成功了。</li>
<li>返回值类型为<code>nullable NSString *</code>，就意味着当调用的js方法有返回值时，都以字符串返回，不够灵活。当返回值是一个js的Array时，还需要解析字符串，比较麻烦。</li>
</ol>
<p>对于上述缺点，可以通过使用JavaScriptCore（iOS 7.0 +）来解决。</p>
<h4 id="2-JavaScriptCore（iOS-7-0-）"><a href="#2-JavaScriptCore（iOS-7-0-）" class="headerlink" title="2. JavaScriptCore（iOS 7.0 +）"></a>2. JavaScriptCore（iOS 7.0 +）</h4><p>想必大家不会陌生吧，前些日子弄的沸沸扬扬的<code>JSPatch</code>被禁事件中，最核心的就是它了。因为<code>JavaScriptCore</code>的JS到OC的映射，可以替换各种js方法成oc方法，所以其<strong>动态性（配合runtime的不安全性）</strong>也就成为了<code>JSPatch</code>被<strong>Apple</strong>禁掉的最主要原因。这里讲下<code>UIWebView</code>通过<code>JavaScriptCore</code>来实现OC-&gt;JS。</p>
<p>其实WebKit都有一个内嵌的js环境，一般我们在页面加载完成之后，获取js上下文，然后通过<code>JSContext</code>的<code>evaluateScript:</code>方法来获取返回值。因为该方法得到的是一个<code>JSValue</code>对象，所以支持JavaScript的Array、Number、String、对象等数据类型。</p>
<pre><code class="objective-c">- (void)webViewDidFinishLoad:(UIWebView *)webView
{
    //更新标题，这是上面的讲过的方法
    //self.navigationItem.title = [webView stringByEvaluatingJavaScriptFromString:@&quot;document.title&quot;];

    //获取该UIWebView的javascript上下文
    JSContext *jsContext = [self.webView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;];

    //这也是一种获取标题的方法。
    JSValue *value = [self.jsContext evaluateScript:@&quot;document.title&quot;];
    //更新标题
    self.navigationItem.title = value.toString;
}
</code></pre>
<p>该方法解决了<code>stringByEvaluatingJavaScriptFromString:</code>返回值只是<code>NSString</code>的问题。</p>
<p>那么如果我执行了一个不存在的方法，比如</p>
<pre><code class="objective-c">[self.jsContext evaluateScript:@&quot;document.titlexxxx&quot;];
</code></pre>
<p>那么必然会报错，报错了，可以通过<code>@property (copy) void(^exceptionHandler)(JSContext *context, JSValue *exception);</code>，设置该block来获取异常。</p>
<pre><code class="objective-c">//在调用前，设置异常回调
[self.jsContext setExceptionHandler:^(JSContext *context, JSValue *exception){
        NSLog(@&quot;%@&quot;, exception);
}];
//执行方法
JSValue *value = [self.jsContext evaluateScript:@&quot;document.titlexxxx&quot;];
</code></pre>
<p>该方法，也很好的解决了<code>stringByEvaluatingJavaScriptFromString:</code>调用js方法后，出现错误却捕获不到的缺点。</p>
<h3 id="UIWebView-JS调用OC"><a href="#UIWebView-JS调用OC" class="headerlink" title="UIWebView JS调用OC"></a>UIWebView JS调用OC</h3><h4 id="1-Custom-URL-Scheme（拦截URL）"><a href="#1-Custom-URL-Scheme（拦截URL）" class="headerlink" title="1. Custom URL Scheme（拦截URL）"></a>1. Custom URL Scheme（拦截URL）</h4><p>比如<code>darkangel://</code>。方法是在html或者js中，点击某个按钮触发事件时，跳转到自定义URL Scheme构成的链接，而Objective-C中捕获该链接，从中解析必要的参数，实现JS到OC的一次交互。比如页面中一个a标签，链接如下：</p>
<pre><code class="html">&lt;a href=&quot;darkangel://smsLogin?username=12323123&amp;code=892845&quot;&gt;短信验证登录&lt;/a&gt;
</code></pre>
<p>而在Objective-C中，只要遵循了<code>UIWebViewDelegate</code>协议，那么每次打开一个链接之前，都会触发方法</p>
<pre><code class="objective-c">- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType；
</code></pre>
<p>在该方法中，捕获该链接，并且返回NO（<strong>阻止本次跳转</strong>），从而执行对应的OC方法。</p>
<pre><code class="objective-c">- (BOOL)webView:(UIWebView *)webView shouldStartLoadWithRequest:(NSURLRequest *)request navigationType:(UIWebViewNavigationType)navigationType
{
    //标准的URL包含scheme、host、port、path、query、fragment等
    NSURL *URL = request.URL;    
    if ([URL.scheme isEqualToString:@&quot;darkangel&quot;]) {
        if ([URL.host isEqualToString:@&quot;smsLogin&quot;]) {
            NSLog(@&quot;短信验证码登录，参数为 %@&quot;, URL.query);
            return NO;
        }
    }
    return YES;
}
</code></pre>
<p>当用户点击<strong>短信验证登录</strong>时，控制台会输出<code>短信验证码登录，参数为 username=12323123&amp;code=892845</code>。参数可以是一个json格式并且URLEncode过的字符串，这样就可以实现复杂参数的传递（比如<a href="https://github.com/marcuswestin/WebViewJavascriptBridge" target="_blank" rel="external">WebViewJavascriptBridge</a>）。</p>
<p><strong>优点</strong>：泛用性强，可以配合h5实现页面动态化。比如页面中一个活动链接到活动详情页，当native尚未开发完毕时，链接可以是一个h5链接，等到native开发完毕时，可以通过该方法跳转到native页面，实现页面动态化。且该方案适用于Android和iOS，泛用性很强。</p>
<p><strong>缺点</strong>：无法直接获取本次交互的返回值，比较适合单向传参，且不关心回调的情景，比如h5页面跳转到native页面等。</p>
<p>其实，<a href="https://github.com/marcuswestin/WebViewJavascriptBridge" target="_blank" rel="external">WebViewJavascriptBridge</a>使用的方案就是<strong>拦截URL</strong>，为了解决无法直接获取返回值的缺点，它采用了将一个名为<code>callback</code>的<code>function</code>作为参数，通过一些封装，传递到OC（<strong>js-&gt;oc</strong> 传递参数和callbackId），然后在OC端执行完毕，再通过<code>block</code>来回调callback（<strong>oc-&gt;js</strong>，传递返回值参数），实现异步获取返回值，比如在js端调用</p>
<pre><code class="javascript">//JS调用OC的分享方法（当然需要OC提前注册）share为方法名，shareData为参数，后面的为回调function
WebViewJavascriptBridge.callHandler(&#39;share&#39;, shareData, function(response) {
   //OC端通过block回调分享成功或者失败的结果
   alert(response);   
});
</code></pre>
<p>具体的可以看下它的源码，还是很值得学习的。</p>
<h4 id="2-JavaScriptCore（iOS-7-0-）-1"><a href="#2-JavaScriptCore（iOS-7-0-）-1" class="headerlink" title="2. JavaScriptCore（iOS 7.0 +）"></a>2. JavaScriptCore（iOS 7.0 +）</h4><p>除了<strong>拦截URL</strong>的方法，还可以利用上面提到的<code>JavaScriptCore</code>。它十分强大，强大在哪里呢？下面我们来一探究竟。</p>
<p>当然，还是需要在页面加载完成时，先获取js上下文。获取到之后，我们就可以进行强大的方法映射了。</p>
<p>比如js中我定义了一个分享的方法</p>
<pre><code class="javascript">function share(title, imgUrl, link) {
     //这里需要OC实现
}
</code></pre>
<p>在OC中实现如下</p>
<pre><code class="objective-c">- (void)webViewDidFinishLoad:(UIWebView *)webView
{
    //将js的function映射到OC的方法
    [self convertJSFunctionsToOCMethods];
}

- (void)convertJSFunctionsToOCMethods
{
    //获取该UIWebview的javascript上下文
    //self持有jsContext
    //@property (nonatomic, strong) JSContext *jsContext;
    self.jsContext = [self.webView valueForKeyPath:@&quot;documentView.webView.mainFrame.javaScriptContext&quot;];

    //js调用oc
    //其中share就是js的方法名称，赋给是一个block 里面是oc代码
    //此方法最终将打印出所有接收到的参数，js参数是不固定的
    self.jsContext[@&quot;share&quot;] = ^() {
        NSArray *args = [JSContext currentArguments];//获取到share里的所有参数
        //args中的元素是JSValue，需要转成OC的对象
        NSMutableArray *messages = [NSMutableArray array];
        for (JSValue *obj in args) {
            [messages addObject:[obj toObject]];
        }
        NSLog(@&quot;点击分享js传回的参数：\n%@&quot;, messages);
    };
}
</code></pre>
<p>在html或者js的某处，点击a标签调用这个share方法，并传参，如</p>
<pre><code class="html">&lt;a href=&quot;javascript:void(0);&quot; class=&quot;sharebtn&quot; onClick=&quot;share(&#39;分享标题&#39;, &#39;http://cc.cocimg.com/api/uploads/170425/b2d6e7ea5b3172e6c39120b7bfd662fb.jpg&#39;, location.href)&quot;&gt;分享活动，领30元红包&lt;/a&gt;
</code></pre>
<p>此时，如果用户点击了<strong><u>分享活动，领30元红包</u></strong>这个标签，那么在控制台会打印出所有参数<img src="http://ww2.sinaimg.cn/large/006tNc79ly1fff18hle74j31ak0hiah2.jpg" alt=""></p>
<p>上面的代码实现了OC方法替换JS实现。它十分灵活，主要依赖这些Api。</p>
<pre><code class="objective-c">@interface JSContext (SubscriptSupport)
/*!
@method
@abstract Get a particular property on the global object.
@result The JSValue for the global object&#39;s property.
*/
- (JSValue *)objectForKeyedSubscript:(id)key;
/*!
@method
@abstract Set a particular property on the global object.
*/
- (void)setObject:(id)object forKeyedSubscript:(NSObject &lt;NSCopying&gt; *)key;
</code></pre>
<p><code>self.jsContext[@&quot;yourMethodName&quot;] = your block;</code>这样写不仅可以在有<code>yourMethodName</code>方法时替换该JS方法为OC实现，还会在g该方法没有时，添加方法。简而言之，<strong>有则替换，无则添加</strong>。</p>
<p>那如果我想写一个有两个参数，一个返回值的js方法，oc应该怎么替换呢？</p>
<p>js中</p>
<pre><code class="javascript">//该方法传入两个整数，求和，并返回结果
function testAddMethod(a, b) {
     //需要OC实现a+b，并返回
      return a + b;
}
//js调用
console.log(testAddMethod(1, 5));    //output  6
</code></pre>
<p>oc直接替换该方法</p>
<pre><code class="objective-c">self.jsContext[@&quot;testAddMethod&quot;] = ^NSInteger(NSInteger a, NSInteger b) {
      return a + b;
};
</code></pre>
<p>那么当在js调用</p>
<pre><code class="javascript">//js调用
console.log(testAddMethod(1, 5));    //output  6， 方法为 a + b
</code></pre>
<p>如果oc替换该方法为两数相乘</p>
<pre><code class="objective-c">self.jsContext[@&quot;testAddMethod&quot;] = ^NSInteger(NSInteger a, NSInteger b) {
      return a * b;
};
</code></pre>
<p>再次调用js</p>
<pre><code class="javascript">console.log(testAddMethod(1, 5));    //output  5，该方法变为了 a * b。
</code></pre>
<p>举一反三，调用方法原实现，并且在原结果上乘以10。</p>
<pre><code class="objective-c">//调用方法的本来实现，给原结果乘以10
JSValue *value = self.jsContext[@&quot;testAddMethod&quot;];
self.jsContext[@&quot;testAddMethod&quot;] = ^NSInteger(NSInteger a, NSInteger b) {
    JSValue *resultValue = [value callWithArguments:[JSContext currentArguments]];
    return resultValue.toInt32 * 10;
};
</code></pre>
<p>再次调用js</p>
<pre><code class="javascript">console.log(testAddMethod(1, 5));    //output  60，该方法变为了(a + b) * 10
</code></pre>
<p>上面的方法，都是同步函数，如果我想实现JS调用OC的方法，并且异步接收回调，那么该怎么做呢？比如h5中有一个分享按钮，用户点击之后，调用native分享（微信分享、微博分享等），在native分享成功或者失败时，回调h5页面，告诉其分享结果，h5页面刷新对应的UI，显示分享成功或者失败。</p>
<p>这个问题，需要对js有一定了解。下面上js代码。</p>
<pre><code class="javascript">//声明
function share(shareData) {
    var title = shareData.title;
    var imgUrl = shareData.imgUrl;
    var link = shareData.link;
    var result = shareData.result;
      //do something
    //这里模拟异步操作
    setTimeout(function(){
          //2s之后，回调true分享成功
       result(true);
    }, 2000);
}

//调用的时候需要这么写
share({
      title: &quot;title&quot;, 
     imgUrl: &quot;http://img.dd.com/xxx.png&quot;, 
     link: location.href, 
     result: function(res) {    //函数作为参数
         console.log(res ? &quot;success&quot; : &quot;failure&quot;);
    }
});
</code></pre>
<p>从封装的角度上讲，js的<code>share</code>方法的参数是一个<code>对象</code>，该对象包含了几个必要的字段，以及一个回调函数，这个回调函数有点像oc的<code>block</code>，<strong>调用者</strong>把一个<code>function</code>传入一个<code>function</code>当作参数，在适当时候，方法内<strong>实现者</strong>调用该<code>function</code>，实现对<strong>调用者</strong>的异步回调。那么如果此时OC来实现<code>share</code>方法，该怎么做呢？其实大概是这样的：</p>
<pre><code class="objective-c">//异步回调
self.jsContext[@&quot;share&quot;] = ^(JSValue *shareData) {    //首先这里要注意，回调的参数不能直接写NSDictionary类型，为何呢？
    //仔细看，打印出的确实是一个NSDictionary，但是result字段对应的不是block而是一个NSDictionary  
      NSLog(@&quot;%@&quot;, [shareData toObject]);     
    //获取shareData对象的result属性，这个JSValue对应的其实是一个javascript的function。
    JSValue *resultFunction = [shareData valueForProperty:@&quot;result&quot;];
    //回调block，将js的function转换为OC的block
    void (^result)(BOOL) = ^(BOOL isSuccess) {
        [resultFunction callWithArguments:@[@(isSuccess)]];
    };
    //模拟异步回调
    dispatch_after(dispatch_time(DISPATCH_TIME_NOW, (int64_t)(3 * NSEC_PER_SEC)), dispatch_get_main_queue(), ^{
        NSLog(@&quot;回调分享成功&quot;);
        result(YES);
    });
};
</code></pre>
<p>其中一些坑，已经在代码的注释写的比较清楚了，这里要注意<code>JavaScript</code>的<code>function</code>和<code>Objective-C</code>的<code>block</code>的转换。</p>
<p>从上面的一些探讨和尝试来看，足以证明<code>JavaScriptCore</code>的强大，这里不再展开，小伙伴们可以自行探索。</p>
<h2 id="UIWebView的Cookie管理"><a href="#UIWebView的Cookie管理" class="headerlink" title="UIWebView的Cookie管理"></a>UIWebView的Cookie管理</h2><h3 id="Cookie简介"><a href="#Cookie简介" class="headerlink" title="Cookie简介"></a>Cookie简介</h3><p>说到<code>Cookie</code>，或许有些小伙伴会比较陌生，有些小伙伴会比较熟悉。如果项目中，所有页面都是纯原生来实现的话，一般<code>Cookie</code>这个东西或许我们永远也不会接触到。但是，这里还是要说一下<code>Cookie</code>，因为它真的很重要，由它产生的一些坑也很多。</p>
<p><code>Cookie</code>在Web利用的最多的地方，是用来记录各种状态。比如你在<code>Safari</code>中打开百度，然后登陆自己的账号，之后打开所有百度相关的页面，都会是登陆状态，而且当你关了电脑，下次开机再次打开<code>Safari</code>打开百度，会发现还是登陆状态，其实这个就利用了<code>Cookie</code>。<code>Cookie</code>中记录了你百度账号的一些信息、有效期等，也维持了跨域请求时登录状态的统计性。<img src="http://ww3.sinaimg.cn/large/006tNc79ly1fff5jbzd4cj31kw0jk11w.jpg" alt="">可以看到<code>Cookie</code>的域各不相同，有效期也各不相同，一般<code>.baidu.com</code>这样的域的<code>Cookie</code>就是为了跨域时，可以维持一些状态。</p>
<p>那么在App中，Cookie最常用的就是维持登录状态了。一般Native端都有自己的一套完整登录注册逻辑，一般大部分页面都是原生实现的。当然，也会有一些页面是h5来实现的，虽然h5页面在App中通过<code>WebView</code>加载或多或少都会有点性能问题，感觉不流畅或者体验不好，但是它的灵活性是Native App无法比拟的。那么由此，便产生了一种需求，当Native端用户是登录状态的，打开一个h5页面，h5也要维持用户的登录状态。</p>
<p>这个需求看似简单，如何实现呢？一般的解决方案是Native保存登录状态的Cookie，在打开h5页面中，把Cookie添加上，以此来维持登录状态。其实坑还是有很多的，比如用户登录或者退出了，h5页面的登录状态也变了，需要刷新，什么时候刷新？<code>WKWebView</code>中<code>Cookie</code>丢失问题？这里简单说下<code>UIWebView</code>的<code>Cookie</code>管理，后面的章节再介绍<code>WKWebView</code>。</p>
<h3 id="Cookie管理"><a href="#Cookie管理" class="headerlink" title="Cookie管理"></a>Cookie管理</h3><p><code>UIWebView</code>的<code>Cookie</code>管理很简单，一般不需要我们手动操作<code>Cookie</code>，因为所有<code>Cookie</code>都会被<code>[NSHTTPCookieStorage sharedHTTPCookieStorage]</code>这个单例管理，而且<code>UIWebView</code>会自动同步<code>CookieStorage</code>中的Cookie，所以只要我们在Native端，正常登陆退出，h5在适当时候刷新，就可以正确的维持登录状态，不需要做多余的操作。</p>
<p>可能有一些情况下，我们需要在访问某个链接时，添加一个固定<code>Cookie</code>用来做区分，那么就可以通过<code>header</code>来实现</p>
<pre><code class="objective-c">NSMutableURLRequest *request = [NSMutableURLRequest requestWithURL:[NSURL URLWithString:@&quot;http://www.baidu.com&quot;]];
[request addValue:@&quot;customCookieName=1314521;&quot; forHTTPHeaderField:@&quot;Set-Cookie&quot;];
[self.webView loadRequest:request];
</code></pre>
<p>也可以主动操作<code>NSHTTPCookieStorage</code>，添加一个自定义<code>Cookie</code></p>
<pre><code class="objective-c">NSHTTPCookie *cookie = [NSHTTPCookie cookieWithProperties:@{
    NSHTTPCookieName: @&quot;customCookieName&quot;, 
    NSHTTPCookieValue: @&quot;1314521&quot;, 
    NSHTTPCookieDomain: @&quot;.baidu.com&quot;,
    NSHTTPCookiePath: @&quot;/&quot;
}];
[[NSHTTPCookieStorage sharedHTTPCookieStorage] setCookie:cookie];    //Cookie存在则覆盖，不存在添加
</code></pre>
<p>还有一些常用的方法，如读取所有<code>Cookie</code></p>
<pre><code class="objective-c">NSArray *cookies = [NSHTTPCookieStorage sharedHTTPCookieStorage].cookies;
</code></pre>
<p><code>Cookie</code>转换成<code>HTTPHeaderFields</code>，并添加到<code>request</code>的<code>header</code>中</p>
<pre><code class="objective-c">//Cookies数组转换为requestHeaderFields
NSDictionary *requestHeaderFields = [NSHTTPCookie requestHeaderFieldsWithCookies:cookies];
//设置请求头
request.allHTTPHeaderFields = requestHeaderFields;
</code></pre>
<p>整体来说<code>UIWebView</code>的<code>Cookie</code>管理比较简单，小伙伴们可以自己写个demo测试一下，发挥你们的想象。</p>
<h1 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h1><p>关于<code>UIWebView</code>的介绍，以及使用<code>UIWebView</code>进行JS与OC的交互，<code>Cookie</code>的管理，就先简单介绍到这里。如果有小伙伴对于<a href="https://github.com/marcuswestin/WebViewJavascriptBridge" target="_blank" rel="external">WebViewJavascriptBridge</a>比较感兴趣，可以留言，根据留言我考虑一下写一篇文章，分析它的详细实现。</p>
<p>另外，后续将为您介绍<code>WKWebView</code>的用法，一些OC与JS交互，Cookie管理、如何在<code>Safari</code>中调试以及一些不为人知的坑等，敬请期待~</p>
<p>下篇文章已发布：<a href="http://blog.darkangel7.com/2017/05/10/iOS中UIWebView与WKWebView、JavaScript与OC交互、Cookie管理看我就够（中）/">iOS中UIWebView与WKWebView、JavaScript与OC交互、Cookie管理看我就够（中）</a>。</p>
<p>To be continued…</p>

    </section>
    <footer class="post-footer">
      <section class="author">
    <h4>Dark Angel</h4>
    <p>iOS界的低调探索者</p>
</section>
    <div class="bdsharebuttonbox"><a href="#" class="bds_more" data-cmd="more"></a><a href="#" class="bds_qzone" data-cmd="qzone"></a><a href="#" class="bds_tsina" data-cmd="tsina"></a><a href="#" class="bds_tqq" data-cmd="tqq"></a><a href="#" class="bds_renren" data-cmd="renren"></a><a href="#" class="bds_weixin" data-cmd="weixin"></a></div>
<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdPic":"","bdStyle":"0","bdSize":"16"},"share":{},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"},"selectShare":{"bdContainerClass":null,"bdSelectMiniList":["qzone","tsina","tqq","renren","weixin"]}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>
    </footer>
  </article>
  <nav class="pagination" role="pagination">
    
    <a class="newer-posts" href="/2017/04/28/Jenkins部署MacOS Slave实现持续集成(iOS)/">
        ← Jenkins部署MacOS Slave实现持续集成(iOS)
    </a>
    
    <span class="icon-logo">•</span>
    
    <a class="older-posts" href="/2016/08/19/Hexo+Github的Blog搭建/">
        Hexo+Github的Blog搭建 →
    </a>
    
</nav>

  <div id="comment" class="comments-area">
    
    	<!-- 多说评论框 start -->
　	<div class="ds-thread" data-thread-key="2016/09/01/iOS中UIWebView与WKWebView、JavaScript与OC交互、Cookie管理看我就够（上）/" data-title="iOS中UIWebView与WKWebView、JavaScript与OC交互、Cookie管理看我就够（上）" data-url="http://blog.darkangel7.com/2016/09/01/iOS中UIWebView与WKWebView、JavaScript与OC交互、Cookie管理看我就够（上）/" data-auth-key="1"</div>	
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
		var duoshuoQuery = {short_name:"darkangel"};
		(function() {
			var ds = document.createElement('script');
			ds.type = 'text/javascript';ds.async = true;
			ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
			ds.charset = 'UTF-8';
			(document.getElementsByTagName('head')[0] 
		 	|| document.getElementsByTagName('body')[0]).appendChild(ds);
		})();
	</script>
	<!-- 多说公共JS代码 end -->
    
</div>

</main>


      
<footer class="site-footer">
  
  <a class="subscribe icon-feed" href="/atom.xml"><span class="tooltip">Subscribe!</span></a>
  
  <div class="inner">
     <section class="copyright">原创文章，版权声明：署名-非商业性使用-相同方式共享 2.5</section>
     <section class="copyright"><a href="/">Dark Angel</a> &copy; 2016 &bull; All Rights Reserved.</section>
     <section class="poweredby">Powered By Hexo</section>
  </div>
</footer>

      <script src="//apps.bdimg.com/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="//cdn.bootcss.com/highlight.js/8.5/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad();</script>

<script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js">
</script>

<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https'){
   bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
  }
  else{
  bp.src = 'http://push.zhanzhang.baidu.com/push.js';
  }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>

<script type="text/javascript" src="/js/jquery.fitvids.js"></script>
<script type="text/javascript" src="/js/index.js"></script>
<script type="text/javascript" src="/js/menu.js"></script>





  </div>
</div>

<nav  class="outer-nav top horizontal">

          <a class="icon-home"  href="/"><span>Home</span></a>

          <a class="icon-news"  href="/archives"><span>Archive</span></a>

          <a class="icon-wiki"  href="https://github.com/DarkAngel7"><span>Github</span></a>

          <a class="icon-Favorites"  href="/atom.xml"><span>Rss</span></a>

</nav>

</div>
</body>
</html>
